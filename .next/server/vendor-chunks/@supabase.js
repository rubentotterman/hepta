"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase";
exports.ids = ["vendor-chunks/@supabase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-nextjs/dist/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    createBrowserSupabaseClient: ()=>createBrowserSupabaseClient,\n    createClientComponentClient: ()=>createClientComponentClient,\n    createMiddlewareClient: ()=>createMiddlewareClient,\n    createMiddlewareSupabaseClient: ()=>createMiddlewareSupabaseClient,\n    createPagesBrowserClient: ()=>createPagesBrowserClient,\n    createPagesServerClient: ()=>createPagesServerClient,\n    createRouteHandlerClient: ()=>createRouteHandlerClient,\n    createServerActionClient: ()=>createServerActionClient,\n    createServerComponentClient: ()=>createServerComponentClient,\n    createServerSupabaseClient: ()=>createServerSupabaseClient\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/clientComponentClient.ts\nvar import_auth_helpers_shared = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar supabase;\nfunction createClientComponentClient({ supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions, isSingleton = true } = {}) {\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    const createNewClient = ()=>{\n        var _a;\n        return (0, import_auth_helpers_shared.createSupabaseClient)(supabaseUrl, supabaseKey, {\n            ...options,\n            global: {\n                ...options == null ? void 0 : options.global,\n                headers: {\n                    ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                    \"X-Client-Info\": `${\"@supabase/auth-helpers-nextjs\"}@${\"0.8.7\"}`\n                }\n            },\n            auth: {\n                storage: new import_auth_helpers_shared.BrowserCookieAuthStorageAdapter(cookieOptions)\n            }\n        });\n    };\n    if (isSingleton) {\n        const _supabase = supabase ?? createNewClient();\n        if (true) return _supabase;\n        if (!supabase) supabase = _supabase;\n        return supabase;\n    }\n    return createNewClient();\n}\n// src/pagesBrowserClient.ts\nvar createPagesBrowserClient = createClientComponentClient;\n// src/pagesServerClient.ts\nvar import_auth_helpers_shared2 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar import_set_cookie_parser = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar NextServerAuthStorageAdapter = class extends import_auth_helpers_shared2.CookieAuthStorageAdapter {\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n    getCookie(name) {\n        var _a, _b, _c;\n        const setCookie = (0, import_set_cookie_parser.splitCookiesString)(((_b = (_a = this.context.res) == null ? void 0 : _a.getHeader(\"set-cookie\")) == null ? void 0 : _b.toString()) ?? \"\").map((c)=>(0, import_auth_helpers_shared2.parseCookies)(c)[name]).find((c)=>!!c);\n        const value = setCookie ?? ((_c = this.context.req) == null ? void 0 : _c.cookies[name]);\n        return value;\n    }\n    setCookie(name, value) {\n        this._setCookie(name, value);\n    }\n    deleteCookie(name) {\n        this._setCookie(name, \"\", {\n            maxAge: 0\n        });\n    }\n    _setCookie(name, value, options) {\n        var _a;\n        const setCookies = (0, import_set_cookie_parser.splitCookiesString)(((_a = this.context.res.getHeader(\"set-cookie\")) == null ? void 0 : _a.toString()) ?? \"\").filter((c)=>!(name in (0, import_auth_helpers_shared2.parseCookies)(c)));\n        const cookieStr = (0, import_auth_helpers_shared2.serializeCookie)(name, value, {\n            ...this.cookieOptions,\n            ...options,\n            // Allow supabase-js on the client to read the cookie as well\n            httpOnly: false\n        });\n        this.context.res.setHeader(\"set-cookie\", [\n            ...setCookies,\n            cookieStr\n        ]);\n    }\n};\nfunction createPagesServerClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared2.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": `${\"@supabase/auth-helpers-nextjs\"}@${\"0.8.7\"}`\n            }\n        },\n        auth: {\n            storage: new NextServerAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/middlewareClient.ts\nvar import_auth_helpers_shared3 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar import_set_cookie_parser2 = __webpack_require__(/*! set-cookie-parser */ \"(ssr)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar NextMiddlewareAuthStorageAdapter = class extends import_auth_helpers_shared3.CookieAuthStorageAdapter {\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n    getCookie(name) {\n        var _a;\n        const setCookie = (0, import_set_cookie_parser2.splitCookiesString)(((_a = this.context.res.headers.get(\"set-cookie\")) == null ? void 0 : _a.toString()) ?? \"\").map((c)=>(0, import_auth_helpers_shared3.parseCookies)(c)[name]).find((c)=>!!c);\n        if (setCookie) {\n            return setCookie;\n        }\n        const cookies = (0, import_auth_helpers_shared3.parseCookies)(this.context.req.headers.get(\"cookie\") ?? \"\");\n        return cookies[name];\n    }\n    setCookie(name, value) {\n        this._setCookie(name, value);\n    }\n    deleteCookie(name) {\n        this._setCookie(name, \"\", {\n            maxAge: 0\n        });\n    }\n    _setCookie(name, value, options) {\n        const newSessionStr = (0, import_auth_helpers_shared3.serializeCookie)(name, value, {\n            ...this.cookieOptions,\n            ...options,\n            // Allow supabase-js on the client to read the cookie as well\n            httpOnly: false\n        });\n        if (this.context.res.headers) {\n            this.context.res.headers.append(\"set-cookie\", newSessionStr);\n        }\n    }\n};\nfunction createMiddlewareClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared3.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": `${\"@supabase/auth-helpers-nextjs\"}@${\"0.8.7\"}`\n            }\n        },\n        auth: {\n            storage: new NextMiddlewareAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/serverComponentClient.ts\nvar import_auth_helpers_shared4 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar NextServerComponentAuthStorageAdapter = class extends import_auth_helpers_shared4.CookieAuthStorageAdapter {\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n    getCookie(name) {\n        var _a;\n        const nextCookies = this.context.cookies();\n        return (_a = nextCookies.get(name)) == null ? void 0 : _a.value;\n    }\n    setCookie(name, value) {}\n    deleteCookie(name) {}\n};\nfunction createServerComponentClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared4.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": `${\"@supabase/auth-helpers-nextjs\"}@${\"0.8.7\"}`\n            }\n        },\n        auth: {\n            storage: new NextServerComponentAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/routeHandlerClient.ts\nvar import_auth_helpers_shared5 = __webpack_require__(/*! @supabase/auth-helpers-shared */ \"(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\");\nvar NextRouteHandlerAuthStorageAdapter = class extends import_auth_helpers_shared5.CookieAuthStorageAdapter {\n    constructor(context, cookieOptions){\n        super(cookieOptions);\n        this.context = context;\n    }\n    getCookie(name) {\n        var _a;\n        const nextCookies = this.context.cookies();\n        return (_a = nextCookies.get(name)) == null ? void 0 : _a.value;\n    }\n    setCookie(name, value) {\n        const nextCookies = this.context.cookies();\n        nextCookies.set(name, value, this.cookieOptions);\n    }\n    deleteCookie(name) {\n        const nextCookies = this.context.cookies();\n        nextCookies.set(name, \"\", {\n            ...this.cookieOptions,\n            maxAge: 0\n        });\n    }\n};\nfunction createRouteHandlerClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    var _a;\n    if (!supabaseUrl || !supabaseKey) {\n        throw new Error(\"either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!\");\n    }\n    return (0, import_auth_helpers_shared5.createSupabaseClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        global: {\n            ...options == null ? void 0 : options.global,\n            headers: {\n                ...(_a = options == null ? void 0 : options.global) == null ? void 0 : _a.headers,\n                \"X-Client-Info\": `${\"@supabase/auth-helpers-nextjs\"}@${\"0.8.7\"}`\n            }\n        },\n        auth: {\n            storage: new NextRouteHandlerAuthStorageAdapter(context, cookieOptions)\n        }\n    });\n}\n// src/serverActionClient.ts\nvar createServerActionClient = createRouteHandlerClient;\n// src/deprecated.ts\nfunction createBrowserSupabaseClient({ supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    console.warn(\"Please utilize the `createPagesBrowserClient` function instead of the deprecated `createBrowserSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages\");\n    return createPagesBrowserClient({\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\nfunction createServerSupabaseClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    console.warn(\"Please utilize the `createPagesServerClient` function instead of the deprecated `createServerSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages\");\n    return createPagesServerClient(context, {\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\nfunction createMiddlewareSupabaseClient(context, { supabaseUrl = \"https://pwcibfnmmndbdwxdjmdj.supabase.co/\", supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB3Y2liZm5tbW5kYmR3eGRqbWRqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDEwMDUxMTYsImV4cCI6MjA1NjU4MTExNn0.r7yjNeA4AWA2dd1y4MmS_unB7ERpSKNjWxNKHRGo6zU\", options, cookieOptions } = {}) {\n    console.warn(\"Please utilize the `createMiddlewareClient` function instead of the deprecated `createMiddlewareSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs#middleware\");\n    return createMiddlewareClient(context, {\n        supabaseUrl,\n        supabaseKey,\n        options,\n        cookieOptions\n    });\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CRixPQUFPRyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CSixPQUFPSyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZU4sT0FBT08sU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmWixVQUFVVyxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9oQixrQkFBa0JhLE1BQ2hDLElBQUksQ0FBQ1gsYUFBYWUsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT2pCLGlCQUFpQmUsTUFBTUcsSUFBRyxLQUFNRCxLQUFLTCxVQUFVO1FBQUM7SUFDdEg7SUFDQSxPQUFPRTtBQUNUO0FBQ0EsSUFBSU0sZUFBZSxDQUFDQyxNQUFRUixZQUFZaEIsVUFBVSxDQUFDLEdBQUcsY0FBYztRQUFFeUIsT0FBTztJQUFLLElBQUlEO0FBRXRGLGVBQWU7QUFDZixJQUFJRSxjQUFjLENBQUM7QUFDbkJoQixTQUFTZ0IsYUFBYTtJQUNwQkMsNkJBQTZCLElBQU1BO0lBQ25DQyw2QkFBNkIsSUFBTUE7SUFDbkNDLHdCQUF3QixJQUFNQTtJQUM5QkMsZ0NBQWdDLElBQU1BO0lB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QywyQ0FBb0MsRUFDbERHLGNBQWNILGtOQUF5QyxFQUN2REssT0FBTyxFQUNQQyxhQUFhLEVBQ2QsR0FBRyxDQUFDLENBQUM7SUFDSm9ELFFBQVFDLElBQUksQ0FDVjtJQUVGLE9BQU96RSx1QkFBdUJxQyxTQUFTO1FBQ3JDeEI7UUFDQUk7UUFDQUU7UUFDQUM7SUFDRjtBQUNGO0FBQ0EsNkRBQTZEO0FBQzdELEtBQU1aLENBQUFBLENBV04sR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMvZGlzdC9pbmRleC5qcz9jZjkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudDogKCkgPT4gY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50LFxuICBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQ6ICgpID0+IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCxcbiAgY3JlYXRlTWlkZGxld2FyZUNsaWVudDogKCkgPT4gY3JlYXRlTWlkZGxld2FyZUNsaWVudCxcbiAgY3JlYXRlTWlkZGxld2FyZVN1cGFiYXNlQ2xpZW50OiAoKSA9PiBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQsXG4gIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudDogKCkgPT4gY3JlYXRlUGFnZXNCcm93c2VyQ2xpZW50LFxuICBjcmVhdGVQYWdlc1NlcnZlckNsaWVudDogKCkgPT4gY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQsXG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudDogKCkgPT4gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50LFxuICBjcmVhdGVTZXJ2ZXJBY3Rpb25DbGllbnQ6ICgpID0+IGNyZWF0ZVNlcnZlckFjdGlvbkNsaWVudCxcbiAgY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50OiAoKSA9PiBjcmVhdGVTZXJ2ZXJDb21wb25lbnRDbGllbnQsXG4gIGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50OiAoKSA9PiBjcmVhdGVTZXJ2ZXJTdXBhYmFzZUNsaWVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG5cbi8vIHNyYy9jbGllbnRDb21wb25lbnRDbGllbnQudHNcbnZhciBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZCA9IHJlcXVpcmUoXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXNoYXJlZFwiKTtcbnZhciBzdXBhYmFzZTtcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCh7XG4gIHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMLFxuICBzdXBhYmFzZUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZLFxuICBvcHRpb25zLFxuICBjb29raWVPcHRpb25zLFxuICBpc1NpbmdsZXRvbiA9IHRydWVcbn0gPSB7fSkge1xuICBpZiAoIXN1cGFiYXNlVXJsIHx8ICFzdXBhYmFzZUtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiZWl0aGVyIE5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCBhbmQgTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgZW52IHZhcmlhYmxlcyBvciBzdXBhYmFzZVVybCBhbmQgc3VwYWJhc2VLZXkgYXJlIHJlcXVpcmVkIVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBjcmVhdGVOZXdDbGllbnQgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQuY3JlYXRlU3VwYWJhc2VDbGllbnQpKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdsb2JhbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgICBcIlgtQ2xpZW50LUluZm9cIjogYCR7XCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wifUAke1wiMC44LjdcIn1gXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhdXRoOiB7XG4gICAgICAgIHN0b3JhZ2U6IG5ldyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZC5Ccm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyKGNvb2tpZU9wdGlvbnMpXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGlmIChpc1NpbmdsZXRvbikge1xuICAgIGNvbnN0IF9zdXBhYmFzZSA9IHN1cGFiYXNlID8/IGNyZWF0ZU5ld0NsaWVudCgpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuIF9zdXBhYmFzZTtcbiAgICBpZiAoIXN1cGFiYXNlKVxuICAgICAgc3VwYWJhc2UgPSBfc3VwYWJhc2U7XG4gICAgcmV0dXJuIHN1cGFiYXNlO1xuICB9XG4gIHJldHVybiBjcmVhdGVOZXdDbGllbnQoKTtcbn1cblxuLy8gc3JjL3BhZ2VzQnJvd3NlckNsaWVudC50c1xudmFyIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCA9IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudDtcblxuLy8gc3JjL3BhZ2VzU2VydmVyQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlciA9IHJlcXVpcmUoXCJzZXQtY29va2llLXBhcnNlclwiKTtcbnZhciBOZXh0U2VydmVyQXV0aFN0b3JhZ2VBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIuQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgY29va2llT3B0aW9ucykge1xuICAgIHN1cGVyKGNvb2tpZU9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbiAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZXRDb29raWUgPSAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZykoXG4gICAgICAoKF9iID0gKF9hID0gdGhpcy5jb250ZXh0LnJlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEhlYWRlcihcInNldC1jb29raWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpKSA/PyBcIlwiXG4gICAgKS5tYXAoKGMpID0+ICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIucGFyc2VDb29raWVzKShjKVtuYW1lXSkuZmluZCgoYykgPT4gISFjKTtcbiAgICBjb25zdCB2YWx1ZSA9IHNldENvb2tpZSA/PyAoKF9jID0gdGhpcy5jb250ZXh0LnJlcSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNvb2tpZXNbbmFtZV0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zZXRDb29raWUobmFtZSwgdmFsdWUpO1xuICB9XG4gIGRlbGV0ZUNvb2tpZShuYW1lKSB7XG4gICAgdGhpcy5fc2V0Q29va2llKG5hbWUsIFwiXCIsIHtcbiAgICAgIG1heEFnZTogMFxuICAgIH0pO1xuICB9XG4gIF9zZXRDb29raWUobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2V0Q29va2llcyA9ICgwLCBpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIuc3BsaXRDb29raWVzU3RyaW5nKShcbiAgICAgICgoX2EgPSB0aGlzLmNvbnRleHQucmVzLmdldEhlYWRlcihcInNldC1jb29raWVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSA/PyBcIlwiXG4gICAgKS5maWx0ZXIoKGMpID0+ICEobmFtZSBpbiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyLnBhcnNlQ29va2llcykoYykpKTtcbiAgICBjb25zdCBjb29raWVTdHIgPSAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyLnNlcmlhbGl6ZUNvb2tpZSkobmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBBbGxvdyBzdXBhYmFzZS1qcyBvbiB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGNvb2tpZSBhcyB3ZWxsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRleHQucmVzLnNldEhlYWRlcihcInNldC1jb29raWVcIiwgWy4uLnNldENvb2tpZXMsIGNvb2tpZVN0cl0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIHZhciBfYTtcbiAgaWYgKCFzdXBhYmFzZVVybCB8fCAhc3VwYWJhc2VLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImVpdGhlciBORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgYW5kIE5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIGVudiB2YXJpYWJsZXMgb3Igc3VwYWJhc2VVcmwgYW5kIHN1cGFiYXNlS2V5IGFyZSByZXF1aXJlZCFcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDIuY3JlYXRlU3VwYWJhc2VDbGllbnQpKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZ2xvYmFsOiB7XG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmdsb2JhbCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5oZWFkZXJzLFxuICAgICAgICBcIlgtQ2xpZW50LUluZm9cIjogYCR7XCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLW5leHRqc1wifUAke1wiMC44LjdcIn1gXG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRoOiB7XG4gICAgICBzdG9yYWdlOiBuZXcgTmV4dFNlcnZlckF1dGhTdG9yYWdlQWRhcHRlcihjb250ZXh0LCBjb29raWVPcHRpb25zKVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIGltcG9ydF9zZXRfY29va2llX3BhcnNlcjIgPSByZXF1aXJlKFwic2V0LWNvb2tpZS1wYXJzZXJcIik7XG52YXIgTmV4dE1pZGRsZXdhcmVBdXRoU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkMy5Db29raWVBdXRoU3RvcmFnZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb29raWVPcHRpb25zKSB7XG4gICAgc3VwZXIoY29va2llT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBnZXRDb29raWUobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZXRDb29raWUgPSAoMCwgaW1wb3J0X3NldF9jb29raWVfcGFyc2VyMi5zcGxpdENvb2tpZXNTdHJpbmcpKFxuICAgICAgKChfYSA9IHRoaXMuY29udGV4dC5yZXMuaGVhZGVycy5nZXQoXCJzZXQtY29va2llXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgPz8gXCJcIlxuICAgICkubWFwKChjKSA9PiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLnBhcnNlQ29va2llcykoYylbbmFtZV0pLmZpbmQoKGMpID0+ICEhYyk7XG4gICAgaWYgKHNldENvb2tpZSkge1xuICAgICAgcmV0dXJuIHNldENvb2tpZTtcbiAgICB9XG4gICAgY29uc3QgY29va2llcyA9ICgwLCBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDMucGFyc2VDb29raWVzKSh0aGlzLmNvbnRleHQucmVxLmhlYWRlcnMuZ2V0KFwiY29va2llXCIpID8/IFwiXCIpO1xuICAgIHJldHVybiBjb29raWVzW25hbWVdO1xuICB9XG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX3NldENvb2tpZShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZGVsZXRlQ29va2llKG5hbWUpIHtcbiAgICB0aGlzLl9zZXRDb29raWUobmFtZSwgXCJcIiwge1xuICAgICAgbWF4QWdlOiAwXG4gICAgfSk7XG4gIH1cbiAgX3NldENvb2tpZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5ld1Nlc3Npb25TdHIgPSAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLnNlcmlhbGl6ZUNvb2tpZSkobmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAvLyBBbGxvdyBzdXBhYmFzZS1qcyBvbiB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGNvb2tpZSBhcyB3ZWxsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAodGhpcy5jb250ZXh0LnJlcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzLmhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBuZXdTZXNzaW9uU3RyKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlQ2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQzLmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRNaWRkbGV3YXJlQXV0aFN0b3JhZ2VBZGFwdGVyKGNvbnRleHQsIGNvb2tpZU9wdGlvbnMpXG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3NlcnZlckNvbXBvbmVudENsaWVudC50c1xudmFyIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkNCA9IHJlcXVpcmUoXCJAc3VwYWJhc2UvYXV0aC1oZWxwZXJzLXNoYXJlZFwiKTtcbnZhciBOZXh0U2VydmVyQ29tcG9uZW50QXV0aFN0b3JhZ2VBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDQuQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoY29udGV4dCwgY29va2llT3B0aW9ucykge1xuICAgIHN1cGVyKGNvb2tpZU9wdGlvbnMpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIH1cbiAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbmV4dENvb2tpZXMgPSB0aGlzLmNvbnRleHQuY29va2llcygpO1xuICAgIHJldHVybiAoX2EgPSBuZXh0Q29va2llcy5nZXQobmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS52YWx1ZTtcbiAgfVxuICBzZXRDb29raWUobmFtZSwgdmFsdWUpIHtcbiAgfVxuICBkZWxldGVDb29raWUobmFtZSkge1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU2VydmVyQ29tcG9uZW50Q2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ0LmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRTZXJ2ZXJDb21wb25lbnRBdXRoU3RvcmFnZUFkYXB0ZXIoY29udGV4dCwgY29va2llT3B0aW9ucylcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvcm91dGVIYW5kbGVyQ2xpZW50LnRzXG52YXIgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1ID0gcmVxdWlyZShcIkBzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkXCIpO1xudmFyIE5leHRSb3V0ZUhhbmRsZXJBdXRoU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkNS5Db29raWVBdXRoU3RvcmFnZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjb29raWVPcHRpb25zKSB7XG4gICAgc3VwZXIoY29va2llT3B0aW9ucyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgfVxuICBnZXRDb29raWUobmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuZXh0Q29va2llcyA9IHRoaXMuY29udGV4dC5jb29raWVzKCk7XG4gICAgcmV0dXJuIChfYSA9IG5leHRDb29raWVzLmdldChuYW1lKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnZhbHVlO1xuICB9XG4gIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xuICAgIGNvbnN0IG5leHRDb29raWVzID0gdGhpcy5jb250ZXh0LmNvb2tpZXMoKTtcbiAgICBuZXh0Q29va2llcy5zZXQobmFtZSwgdmFsdWUsIHRoaXMuY29va2llT3B0aW9ucyk7XG4gIH1cbiAgZGVsZXRlQ29va2llKG5hbWUpIHtcbiAgICBjb25zdCBuZXh0Q29va2llcyA9IHRoaXMuY29udGV4dC5jb29raWVzKCk7XG4gICAgbmV4dENvb2tpZXMuc2V0KG5hbWUsIFwiXCIsIHtcbiAgICAgIC4uLnRoaXMuY29va2llT3B0aW9ucyxcbiAgICAgIG1heEFnZTogMFxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50KGNvbnRleHQsIHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICB2YXIgX2E7XG4gIGlmICghc3VwYWJhc2VVcmwgfHwgIXN1cGFiYXNlS2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJlaXRoZXIgTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIGFuZCBORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSBlbnYgdmFyaWFibGVzIG9yIHN1cGFiYXNlVXJsIGFuZCBzdXBhYmFzZUtleSBhcmUgcmVxdWlyZWQhXCJcbiAgICApO1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1LmNyZWF0ZVN1cGFiYXNlQ2xpZW50KShzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGdsb2JhbDoge1xuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nbG9iYWwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLihfYSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2xvYmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaGVhZGVycyxcbiAgICAgICAgXCJYLUNsaWVudC1JbmZvXCI6IGAke1wiQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anNcIn1AJHtcIjAuOC43XCJ9YFxuICAgICAgfVxuICAgIH0sXG4gICAgYXV0aDoge1xuICAgICAgc3RvcmFnZTogbmV3IE5leHRSb3V0ZUhhbmRsZXJBdXRoU3RvcmFnZUFkYXB0ZXIoY29udGV4dCwgY29va2llT3B0aW9ucylcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvc2VydmVyQWN0aW9uQ2xpZW50LnRzXG52YXIgY3JlYXRlU2VydmVyQWN0aW9uQ2xpZW50ID0gY3JlYXRlUm91dGVIYW5kbGVyQ2xpZW50O1xuXG4vLyBzcmMvZGVwcmVjYXRlZC50c1xuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50KHtcbiAgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwsXG4gIHN1cGFiYXNlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVksXG4gIG9wdGlvbnMsXG4gIGNvb2tpZU9wdGlvbnNcbn0gPSB7fSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJQbGVhc2UgdXRpbGl6ZSB0aGUgYGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudGAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVwcmVjYXRlZCBgY3JlYXRlQnJvd3NlclN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzLXBhZ2VzXCJcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCh7XG4gICAgc3VwYWJhc2VVcmwsXG4gICAgc3VwYWJhc2VLZXksXG4gICAgb3B0aW9ucyxcbiAgICBjb29raWVPcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmVyU3VwYWJhc2VDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIGNvbnNvbGUud2FybihcbiAgICBcIlBsZWFzZSB1dGlsaXplIHRoZSBgY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnRgIGZ1bmN0aW9uIGluc3RlYWQgb2YgdGhlIGRlcHJlY2F0ZWQgYGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzLXBhZ2VzXCJcbiAgKTtcbiAgcmV0dXJuIGNyZWF0ZVBhZ2VzU2VydmVyQ2xpZW50KGNvbnRleHQsIHtcbiAgICBzdXBhYmFzZVVybCxcbiAgICBzdXBhYmFzZUtleSxcbiAgICBvcHRpb25zLFxuICAgIGNvb2tpZU9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQoY29udGV4dCwge1xuICBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcbiAgc3VwYWJhc2VLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSxcbiAgb3B0aW9ucyxcbiAgY29va2llT3B0aW9uc1xufSA9IHt9KSB7XG4gIGNvbnNvbGUud2FybihcbiAgICBcIlBsZWFzZSB1dGlsaXplIHRoZSBgY3JlYXRlTWlkZGxld2FyZUNsaWVudGAgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVwcmVjYXRlZCBgY3JlYXRlTWlkZGxld2FyZVN1cGFiYXNlQ2xpZW50YCBmdW5jdGlvbi4gTGVhcm4gbW9yZTogaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvYXV0aC9hdXRoLWhlbHBlcnMvbmV4dGpzI21pZGRsZXdhcmVcIlxuICApO1xuICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZUNsaWVudChjb250ZXh0LCB7XG4gICAgc3VwYWJhc2VVcmwsXG4gICAgc3VwYWJhc2VLZXksXG4gICAgb3B0aW9ucyxcbiAgICBjb29raWVPcHRpb25zXG4gIH0pO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudCxcbiAgY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50LFxuICBjcmVhdGVNaWRkbGV3YXJlQ2xpZW50LFxuICBjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQsXG4gIGNyZWF0ZVBhZ2VzQnJvd3NlckNsaWVudCxcbiAgY3JlYXRlUGFnZXNTZXJ2ZXJDbGllbnQsXG4gIGNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCxcbiAgY3JlYXRlU2VydmVyQWN0aW9uQ2xpZW50LFxuICBjcmVhdGVTZXJ2ZXJDb21wb25lbnRDbGllbnQsXG4gIGNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX190b0NvbW1vbkpTIiwibW9kIiwidmFsdWUiLCJzcmNfZXhwb3J0cyIsImNyZWF0ZUJyb3dzZXJTdXBhYmFzZUNsaWVudCIsImNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCIsImNyZWF0ZU1pZGRsZXdhcmVDbGllbnQiLCJjcmVhdGVNaWRkbGV3YXJlU3VwYWJhc2VDbGllbnQiLCJjcmVhdGVQYWdlc0Jyb3dzZXJDbGllbnQiLCJjcmVhdGVQYWdlc1NlcnZlckNsaWVudCIsImNyZWF0ZVJvdXRlSGFuZGxlckNsaWVudCIsImNyZWF0ZVNlcnZlckFjdGlvbkNsaWVudCIsImNyZWF0ZVNlcnZlckNvbXBvbmVudENsaWVudCIsImNyZWF0ZVNlcnZlclN1cGFiYXNlQ2xpZW50IiwibW9kdWxlIiwiZXhwb3J0cyIsImltcG9ydF9hdXRoX2hlbHBlcnNfc2hhcmVkIiwicmVxdWlyZSIsInN1cGFiYXNlIiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VLZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIm9wdGlvbnMiLCJjb29raWVPcHRpb25zIiwiaXNTaW5nbGV0b24iLCJFcnJvciIsImNyZWF0ZU5ld0NsaWVudCIsIl9hIiwiY3JlYXRlU3VwYWJhc2VDbGllbnQiLCJnbG9iYWwiLCJoZWFkZXJzIiwiYXV0aCIsInN0b3JhZ2UiLCJCcm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIiwiX3N1cGFiYXNlIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQyIiwiaW1wb3J0X3NldF9jb29raWVfcGFyc2VyIiwiTmV4dFNlcnZlckF1dGhTdG9yYWdlQWRhcHRlciIsIkNvb2tpZUF1dGhTdG9yYWdlQWRhcHRlciIsImNvbnN0cnVjdG9yIiwiY29udGV4dCIsImdldENvb2tpZSIsIl9iIiwiX2MiLCJzZXRDb29raWUiLCJzcGxpdENvb2tpZXNTdHJpbmciLCJyZXMiLCJnZXRIZWFkZXIiLCJ0b1N0cmluZyIsIm1hcCIsImMiLCJwYXJzZUNvb2tpZXMiLCJmaW5kIiwicmVxIiwiY29va2llcyIsIl9zZXRDb29raWUiLCJkZWxldGVDb29raWUiLCJtYXhBZ2UiLCJzZXRDb29raWVzIiwiZmlsdGVyIiwiY29va2llU3RyIiwic2VyaWFsaXplQ29va2llIiwiaHR0cE9ubHkiLCJzZXRIZWFkZXIiLCJpbXBvcnRfYXV0aF9oZWxwZXJzX3NoYXJlZDMiLCJpbXBvcnRfc2V0X2Nvb2tpZV9wYXJzZXIyIiwiTmV4dE1pZGRsZXdhcmVBdXRoU3RvcmFnZUFkYXB0ZXIiLCJuZXdTZXNzaW9uU3RyIiwiYXBwZW5kIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ0IiwiTmV4dFNlcnZlckNvbXBvbmVudEF1dGhTdG9yYWdlQWRhcHRlciIsIm5leHRDb29raWVzIiwiaW1wb3J0X2F1dGhfaGVscGVyc19zaGFyZWQ1IiwiTmV4dFJvdXRlSGFuZGxlckF1dGhTdG9yYWdlQWRhcHRlciIsInNldCIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQzlDLE1BQU1DLGVBQWVELHVEQUFjQTtBQUNuQyxpRUFBZUMsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzPzIwNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuY29uc3QgQXV0aEFkbWluQXBpID0gR29UcnVlQWRtaW5BcGk7XG5leHBvcnQgZGVmYXVsdCBBdXRoQWRtaW5BcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiQXV0aEFkbWluQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUMxQyxNQUFNQyxhQUFhRCxxREFBWUE7QUFDL0IsaUVBQWVDLFVBQVVBLEVBQUMsQ0FDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0F1dGhDbGllbnQuanM/NGY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmNvbnN0IEF1dGhDbGllbnQgPSBHb1RydWVDbGllbnQ7XG5leHBvcnQgZGVmYXVsdCBBdXRoQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aENsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQ2xpZW50IiwiQXV0aENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\nclass GoTrueAdminApi {\n    constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = \"global\") {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = __rest(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLFNBQVMsU0FBSyxJQUFJLFNBQUksQ0FBQ0EsTUFBTSxJQUFLLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztJQUNoRCxJQUFJQyxJQUFJLENBQUM7SUFDVCxJQUFLLElBQUlDLEtBQUtILEVBQUcsSUFBSUksT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1AsR0FBR0csTUFBTUYsRUFBRU8sT0FBTyxDQUFDTCxLQUFLLEdBQzlFRCxDQUFDLENBQUNDLEVBQUUsR0FBR0gsQ0FBQyxDQUFDRyxFQUFFO0lBQ2YsSUFBSUgsS0FBSyxRQUFRLE9BQU9JLE9BQU9LLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHUCxJQUFJQyxPQUFPSyxxQkFBcUIsQ0FBQ1QsSUFBSVUsSUFBSVAsRUFBRVEsTUFBTSxFQUFFRCxJQUFLO1FBQ3BFLElBQUlULEVBQUVPLE9BQU8sQ0FBQ0wsQ0FBQyxDQUFDTyxFQUFFLElBQUksS0FBS04sT0FBT0MsU0FBUyxDQUFDTyxvQkFBb0IsQ0FBQ0wsSUFBSSxDQUFDUCxHQUFHRyxDQUFDLENBQUNPLEVBQUUsR0FDekVSLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDTyxFQUFFLENBQUMsR0FBR1YsQ0FBQyxDQUFDRyxDQUFDLENBQUNPLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9SO0FBQ1g7QUFDc0c7QUFDekQ7QUFDRjtBQUM1QixNQUFNaUI7SUFDakJDLFlBQVksRUFBRUMsTUFBTSxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLEtBQUssRUFBRyxDQUFFO1FBQzVDLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHTiwwREFBWUEsQ0FBQ007UUFDMUIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7WUFDUEMsYUFBYSxJQUFJLENBQUNDLFlBQVksQ0FBQ0MsSUFBSSxDQUFDLElBQUk7WUFDeENDLGNBQWMsSUFBSSxDQUFDQyxhQUFhLENBQUNGLElBQUksQ0FBQyxJQUFJO1FBQzlDO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTUcsUUFBUUMsR0FBRyxFQUFFQyxRQUFRLFFBQVEsRUFBRTtRQUNqQyxJQUFJO1lBQ0EsTUFBTWpCLG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGNBQWMsRUFBRVcsTUFBTSxDQUFDLEVBQUU7Z0JBQ3BFVixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDckJTO2dCQUNBRSxlQUFlO1lBQ25CO1lBQ0EsT0FBTztnQkFBRUMsTUFBTTtnQkFBTUMsT0FBTztZQUFLO1FBQ3JDLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUlqQix3REFBV0EsQ0FBQ2lCLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNELE1BQU1DLGtCQUFrQkMsS0FBSyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3pDLElBQUk7WUFDQSxPQUFPLE1BQU12QixvREFBUUEsQ0FBQyxJQUFJLENBQUNRLEtBQUssRUFBRSxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDNURrQixNQUFNO29CQUFFRjtvQkFBT0gsTUFBTUksUUFBUUosSUFBSTtnQkFBQztnQkFDbENaLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQmtCLFlBQVlGLFFBQVFFLFVBQVU7Z0JBQzlCQyxPQUFPekIscURBQWFBO1lBQ3hCO1FBQ0osRUFDQSxPQUFPbUIsT0FBTztZQUNWLElBQUlqQix3REFBV0EsQ0FBQ2lCLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUVRLE1BQU07b0JBQUs7b0JBQUdQO2dCQUFNO1lBQ3pDO1lBQ0EsTUFBTUE7UUFDVjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0QsTUFBTVEsYUFBYUMsTUFBTSxFQUFFO1FBQ3ZCLElBQUk7WUFDQSxNQUFNLEVBQUVOLE9BQU8sRUFBRSxHQUFHTSxRQUFRQyxPQUFPOUMsT0FBTzZDLFFBQVE7Z0JBQUM7YUFBVTtZQUM3RCxNQUFNTCxPQUFPbkMsT0FBTzBDLE1BQU0sQ0FBQzFDLE9BQU8wQyxNQUFNLENBQUMsQ0FBQyxHQUFHRCxPQUFPUDtZQUNwRCxJQUFJLGNBQWNPLE1BQU07Z0JBQ3BCLGtEQUFrRDtnQkFDbEROLEtBQUtRLFNBQVMsR0FBR0YsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtHLFFBQVE7Z0JBQzFFLE9BQU9ULElBQUksQ0FBQyxXQUFXO1lBQzNCO1lBQ0EsT0FBTyxNQUFNeEIsb0RBQVFBLENBQUMsSUFBSSxDQUFDUSxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsb0JBQW9CLENBQUMsRUFBRTtnQkFDekVrQixNQUFNQTtnQkFDTmpCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQm1CLE9BQU81Qiw2REFBcUJBO2dCQUM1QjJCLFlBQVlGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRSxVQUFVO1lBQ3BGO1FBQ0osRUFDQSxPQUFPTCxPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFDSEQsTUFBTTt3QkFDRmUsWUFBWTt3QkFDWlAsTUFBTTtvQkFDVjtvQkFDQVA7Z0JBQ0o7WUFDSjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBLGlCQUFpQjtJQUNqQjs7O0tBR0MsR0FDRCxNQUFNZSxXQUFXQyxVQUFVLEVBQUU7UUFDekIsSUFBSTtZQUNBLE9BQU8sTUFBTXBDLG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNqRWtCLE1BQU1ZO2dCQUNON0IsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCbUIsT0FBT3pCLHFEQUFhQTtZQUN4QjtRQUNKLEVBQ0EsT0FBT21CLE9BQU87WUFDVixJQUFJakIsd0RBQVdBLENBQUNpQixRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO3dCQUFFUSxNQUFNO29CQUFLO29CQUFHUDtnQkFBTTtZQUN6QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWlCLFVBQVVSLE1BQU0sRUFBRTtRQUNwQixJQUFJUyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUM1QixJQUFJO1lBQ0EsTUFBTUMsYUFBYTtnQkFBRUMsVUFBVTtnQkFBTUMsVUFBVTtnQkFBR0MsT0FBTztZQUFFO1lBQzNELE1BQU1DLFdBQVcsTUFBTWpELG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUMxRUMsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCVyxlQUFlO2dCQUNmZ0MsT0FBTztvQkFDSEMsTUFBTSxDQUFDWixLQUFLLENBQUNELEtBQUtULFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPc0IsSUFBSSxNQUFNLFFBQVFiLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2MsUUFBUSxFQUFDLE1BQU8sUUFBUWIsT0FBTyxLQUFLLElBQUlBLEtBQUs7b0JBQ3BLYyxVQUFVLENBQUNaLEtBQUssQ0FBQ0QsS0FBS1gsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSSxLQUFLLElBQUlBLE9BQU95QixPQUFPLE1BQU0sUUFBUWQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHWSxRQUFRLEVBQUMsTUFBTyxRQUFRWCxPQUFPLEtBQUssSUFBSUEsS0FBSztnQkFDL0s7Z0JBQ0FmLE9BQU8zQiw4REFBc0JBO1lBQ2pDO1lBQ0EsSUFBSWtELFNBQVM3QixLQUFLLEVBQ2QsTUFBTTZCLFNBQVM3QixLQUFLO1lBQ3hCLE1BQU1tQyxRQUFRLE1BQU1OLFNBQVNPLElBQUk7WUFDakMsTUFBTVIsUUFBUSxDQUFDTixLQUFLTyxTQUFTMUMsT0FBTyxDQUFDa0QsR0FBRyxDQUFDLGdCQUFlLE1BQU8sUUFBUWYsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDNUYsTUFBTWdCLFFBQVEsQ0FBQ2QsS0FBSyxDQUFDRCxLQUFLTSxTQUFTMUMsT0FBTyxDQUFDa0QsR0FBRyxDQUFDLE9BQU0sTUFBTyxRQUFRZCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdnQixLQUFLLENBQUMsSUFBRyxNQUFPLFFBQVFmLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7WUFDL0ksSUFBSWMsTUFBTTlELE1BQU0sR0FBRyxHQUFHO2dCQUNsQjhELE1BQU1FLE9BQU8sQ0FBQyxDQUFDQztvQkFDWCxNQUFNVixPQUFPVyxTQUFTRCxLQUFLRixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNJLFNBQVMsQ0FBQyxHQUFHO29CQUNwRSxNQUFNQyxNQUFNQyxLQUFLQyxLQUFLLENBQUNMLEtBQUtGLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ3ZEZCxVQUFVLENBQUMsQ0FBQyxFQUFFbUIsSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHYjtnQkFDL0I7Z0JBQ0FOLFdBQVdHLEtBQUssR0FBR2MsU0FBU2Q7WUFDaEM7WUFDQSxPQUFPO2dCQUFFN0IsTUFBTTlCLE9BQU8wQyxNQUFNLENBQUMxQyxPQUFPMEMsTUFBTSxDQUFDLENBQUMsR0FBR3dCLFFBQVFWO2dCQUFhekIsT0FBTztZQUFLO1FBQ3BGLEVBQ0EsT0FBT0EsT0FBTztZQUNWLElBQUlqQix3REFBV0EsQ0FBQ2lCLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07d0JBQUVvQyxPQUFPLEVBQUU7b0JBQUM7b0JBQUduQztnQkFBTTtZQUN4QztZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU0rQyxZQUFZQyxHQUFHLEVBQUU7UUFDbkIsSUFBSTtZQUNBLE9BQU8sTUFBTXBFLG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGFBQWEsRUFBRThELElBQUksQ0FBQyxFQUFFO2dCQUN2RTdELFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQm1CLE9BQU96QixxREFBYUE7WUFDeEI7UUFDSixFQUNBLE9BQU9tQixPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVEsTUFBTTtvQkFBSztvQkFBR1A7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRCxNQUFNaUQsZUFBZUQsR0FBRyxFQUFFaEMsVUFBVSxFQUFFO1FBQ2xDLElBQUk7WUFDQSxPQUFPLE1BQU1wQyxvREFBUUEsQ0FBQyxJQUFJLENBQUNRLEtBQUssRUFBRSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxhQUFhLEVBQUU4RCxJQUFJLENBQUMsRUFBRTtnQkFDdkU1QyxNQUFNWTtnQkFDTjdCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQm1CLE9BQU96QixxREFBYUE7WUFDeEI7UUFDSixFQUNBLE9BQU9tQixPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVEsTUFBTTtvQkFBSztvQkFBR1A7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1rRCxXQUFXQyxFQUFFLEVBQUVDLG1CQUFtQixLQUFLLEVBQUU7UUFDM0MsSUFBSTtZQUNBLE9BQU8sTUFBTXhFLG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGFBQWEsRUFBRWlFLEdBQUcsQ0FBQyxFQUFFO2dCQUN6RWhFLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUNyQmlCLE1BQU07b0JBQ0ZpRCxvQkFBb0JEO2dCQUN4QjtnQkFDQTlDLE9BQU96QixxREFBYUE7WUFDeEI7UUFDSixFQUNBLE9BQU9tQixPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTt3QkFBRVEsTUFBTTtvQkFBSztvQkFBR1A7Z0JBQU07WUFDekM7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQSxNQUFNVCxhQUFha0IsTUFBTSxFQUFFO1FBQ3ZCLElBQUk7WUFDQSxNQUFNLEVBQUVWLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTXBCLG9EQUFRQSxDQUFDLElBQUksQ0FBQ1EsS0FBSyxFQUFFLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLGFBQWEsRUFBRXVCLE9BQU82QyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzFHbkUsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCbUIsT0FBTyxDQUFDaUQ7b0JBQ0osT0FBTzt3QkFBRXhELE1BQU07NEJBQUV3RDt3QkFBUTt3QkFBR3ZELE9BQU87b0JBQUs7Z0JBQzVDO1lBQ0o7WUFDQSxPQUFPO2dCQUFFRDtnQkFBTUM7WUFBTTtRQUN6QixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJakIsd0RBQVdBLENBQUNpQixRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtJQUNBLE1BQU1OLGNBQWNlLE1BQU0sRUFBRTtRQUN4QixJQUFJO1lBQ0EsTUFBTVYsT0FBTyxNQUFNbkIsb0RBQVFBLENBQUMsSUFBSSxDQUFDUSxLQUFLLEVBQUUsVUFBVSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsYUFBYSxFQUFFdUIsT0FBTzZDLE1BQU0sQ0FBQyxTQUFTLEVBQUU3QyxPQUFPMEMsRUFBRSxDQUFDLENBQUMsRUFBRTtnQkFDL0doRSxTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUN6QjtZQUNBLE9BQU87Z0JBQUVZO2dCQUFNQyxPQUFPO1lBQUs7UUFDL0IsRUFDQSxPQUFPQSxPQUFPO1lBQ1YsSUFBSWpCLHdEQUFXQSxDQUFDaUIsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcz80YTA4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSwgX25vUmVzb2x2ZUpzb25SZXNwb25zZSwgX3JlcXVlc3QsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgY29uc3RydWN0b3IoeyB1cmwgPSAnJywgaGVhZGVycyA9IHt9LCBmZXRjaCwgfSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChqd3QsIHNjb3BlID0gJ2dsb2JhbCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyYW1zLCByZXN0ID0gX19yZXN0KHBhcmFtcywgW1wib3B0aW9uc1wiXSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5uZXdFbWFpbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VXNlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VycyksIHBhZ2luYXRpb24pLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyQnlJZCh1aWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIGZyb20gdGhlIGF1dGggc2NoZW1hLiBTb2Z0IGRlbGV0aW9uIGFsbG93cyB1c2VyIGlkZW50aWZpY2F0aW9uIGZyb20gdGhlIGhhc2hlZCB1c2VyIElEIGJ1dCBpcyBub3QgcmV2ZXJzaWJsZS5cbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVXNlcihpZCwgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlRmFjdG9yKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwiX25vUmVzb2x2ZUpzb25SZXNwb25zZSIsIl9yZXF1ZXN0IiwiX3VzZXJSZXNwb25zZSIsInJlc29sdmVGZXRjaCIsImlzQXV0aEVycm9yIiwiR29UcnVlQWRtaW5BcGkiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJmZXRjaCIsIm1mYSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiYmluZCIsImRlbGV0ZUZhY3RvciIsIl9kZWxldGVGYWN0b3IiLCJzaWduT3V0Iiwiand0Iiwic2NvcGUiLCJub1Jlc29sdmVKc29uIiwiZGF0YSIsImVycm9yIiwiaW52aXRlVXNlckJ5RW1haWwiLCJlbWFpbCIsIm9wdGlvbnMiLCJib2R5IiwicmVkaXJlY3RUbyIsInhmb3JtIiwidXNlciIsImdlbmVyYXRlTGluayIsInBhcmFtcyIsInJlc3QiLCJhc3NpZ24iLCJuZXdfZW1haWwiLCJuZXdFbWFpbCIsInByb3BlcnRpZXMiLCJjcmVhdGVVc2VyIiwiYXR0cmlidXRlcyIsImxpc3RVc2VycyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwicGFnaW5hdGlvbiIsIm5leHRQYWdlIiwibGFzdFBhZ2UiLCJ0b3RhbCIsInJlc3BvbnNlIiwicXVlcnkiLCJwYWdlIiwidG9TdHJpbmciLCJwZXJfcGFnZSIsInBlclBhZ2UiLCJ1c2VycyIsImpzb24iLCJnZXQiLCJsaW5rcyIsInNwbGl0IiwiZm9yRWFjaCIsImxpbmsiLCJwYXJzZUludCIsInN1YnN0cmluZyIsInJlbCIsIkpTT04iLCJwYXJzZSIsImdldFVzZXJCeUlkIiwidWlkIiwidXBkYXRlVXNlckJ5SWQiLCJkZWxldGVVc2VyIiwiaWQiLCJzaG91bGRTb2Z0RGVsZXRlIiwic2hvdWxkX3NvZnRfZGVsZXRlIiwidXNlcklkIiwiZmFjdG9ycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueClient)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/polyfills */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_6__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\nclass GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     */ constructor(options){\n        var _a, _b;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the the auth state is known and it's save to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        this.instanceID = GoTrueClient.nextInstanceID;\n        GoTrueClient.nextInstanceID += 1;\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            console.warn(\"Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.\");\n        }\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        this.persistSession = settings.persistSession;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_8__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageAdapter;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_7__.version}) ${new Date().toISOString()}`, ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(-1, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n            let callbackUrlType = \"none\";\n            if (this._isImplicitGrantCallback(params)) {\n                callbackUrlType = \"implicit\";\n            } else if (await this._isPKCECallback(params)) {\n                callbackUrlType = \"pkce\";\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // failed login attempt via url,\n                    // remove old session as in verifyOtp, signUp and signInWith*\n                    await this._removeSession();\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    error\n                };\n            }\n            return {\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            };\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(-1, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                throw new Error(\"An error occurred on token verification.\");\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.storage.isServer) {\n                    let suppressWarning = this.suppressGetSessionWarning;\n                    const proxySession = new Proxy(currentSession, {\n                        get: (target, prop, receiver)=>{\n                            if (!suppressWarning && prop === \"user\") {\n                                // only show warning when the user object is being accessed from the server\n                                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                                suppressWarning = true; // keeps this proxy instance from logging additional warnings\n                                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning\n                            }\n                            return Reflect.get(target, prop, receiver);\n                        }\n                    });\n                    currentSession = proxySession;\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error\n                };\n            }\n            return {\n                data: {\n                    session\n                },\n                error: null\n            };\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return await this._getUser();\n        });\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) throw userError;\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return {\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */ _decodeJWT(jwt) {\n        return (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWTPayload)(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const payload = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWTPayload)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { session: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                return {\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return {\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */ _isImplicitGrantCallback(params) {\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return {\n                    error: sessionError\n                };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return {\n                            error\n                        };\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return {\n                error: null\n            };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */ onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(-1, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return {\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Links an oauth identity to an existing user.\n     * This method supports the PKCE flow.\n     */ async linkIdentity(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return {\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                session: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    session: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, session);\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_8__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(-1, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : {\n                    issuer: params.issuer\n                });\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                if (params.factorType === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return {\n                    data,\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */ async _verify(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body: {\n                            code: params.code,\n                            challenge_id: params.challengeId\n                        },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return {\n                        data,\n                        error\n                    };\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */ async _challenge(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: {\n                            channel: params.channel\n                        },\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return {\n                data: null,\n                error: challengeError\n            };\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n        const totp = factors.filter((factor)=>factor.factor_type === \"totp\" && factor.status === \"verified\");\n        const phone = factors.filter((factor)=>factor.factor_type === \"phone\" && factor.status === \"verified\");\n        return {\n            data: {\n                all: factors,\n                totp,\n                phone\n            },\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel() {\n        return this._acquireLock(-1, async ()=>{\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: {\n                            currentLevel: null,\n                            nextLevel: null,\n                            currentAuthenticationMethods: []\n                        },\n                        error: null\n                    };\n                }\n                const payload = this._decodeJWT(session.access_token);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = \"aal2\";\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return {\n                    data: {\n                        currentLevel,\n                        nextLevel,\n                        currentAuthenticationMethods\n                    },\n                    error: null\n                };\n            });\n        });\n    }\n}\nGoTrueClient.nextInstanceID = 0; //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDNEc7QUFDaUs7QUFDMU07QUFDa0g7QUFDOUk7QUFDaEM7QUFDYjtBQUM2QjtBQUNyRXNDLGtFQUFrQkEsSUFBSSw4QkFBOEI7QUFDcEQsTUFBTUksa0JBQWtCO0lBQ3BCQyxLQUFLdEMsc0RBQVVBO0lBQ2Z1QyxZQUFZdEMsdURBQVdBO0lBQ3ZCdUMsa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsU0FBUy9DLDJEQUFlQTtJQUN4QmdELFVBQVU7SUFDVkMsT0FBTztJQUNQQyw4QkFBOEI7QUFDbEM7QUFDQSxlQUFlQyxTQUFTQyxJQUFJLEVBQUVDLGNBQWMsRUFBRUMsRUFBRTtJQUM1QyxPQUFPLE1BQU1BO0FBQ2pCO0FBQ2UsTUFBTUM7SUFDakI7O0tBRUMsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUlDLElBQUlDO1FBQ1IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRyxJQUFJQztRQUMvQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MseUJBQXlCLEdBQUc7UUFDakMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQjs7Ozs7U0FLQyxHQUNELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDcEIsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDSSw0QkFBNEIsR0FBRztRQUNwQyxJQUFJLENBQUNpQix5QkFBeUIsR0FBRztRQUNqQyxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLE1BQU0sR0FBR0Ms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QUFhb0IsY0FBYyxHQUFHLEdBQzlCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanM/ZjY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU5fTVMsIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TLCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQsIEdPVFJVRV9VUkwsIFNUT1JBR0VfS0VZLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciwgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEFwaUVycm9yLCBpc0F1dGhFcnJvciwgaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmltcG9ydCB7IF9yZXF1ZXN0LCBfc2Vzc2lvblJlc3BvbnNlLCBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsIF91c2VyUmVzcG9uc2UsIF9zc29SZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyBkZWNvZGVKV1RQYXlsb2FkLCBEZWZlcnJlZCwgZ2V0SXRlbUFzeW5jLCBpc0Jyb3dzZXIsIHJlbW92ZUl0ZW1Bc3luYywgcmVzb2x2ZUZldGNoLCBzZXRJdGVtQXN5bmMsIHV1aWQsIHJldHJ5YWJsZSwgc2xlZXAsIHN1cHBvcnRzTG9jYWxTdG9yYWdlLCBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kLCB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgbG9jYWxTdG9yYWdlQWRhcHRlciwgbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vbGliL2xvY2FsLXN0b3JhZ2UnO1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJztcbmltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yLCBuYXZpZ2F0b3JMb2NrIH0gZnJvbSAnLi9saWIvbG9ja3MnO1xucG9seWZpbGxHbG9iYWxUaGlzKCk7IC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdXJsOiBHT1RSVUVfVVJMLFxuICAgIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgICBmbG93VHlwZTogJ2ltcGxpY2l0JyxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG59O1xuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3AobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgcmV0dXJuIGF3YWl0IGZuKCk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgICAgICAgKiBPbmNlIHJlc29sdmVkIHRoZSB0aGUgYXV0aCBzdGF0ZSBpcyBrbm93biBhbmQgaXQncyBzYXZlIHRvIGNhbGwgYW55IGZ1cnRoZXIgY2xpZW50IG1ldGhvZHMuXG4gICAgICAgICAqIEtlZXAgZXh0cmEgY2FyZSB0byBuZXZlciByZWplY3Qgb3IgdGhyb3cgdW5jYXVnaHQgZXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0luTG9jayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBicm9hZGNhc3Qgc3RhdGUgY2hhbmdlIGV2ZW50cyB0byBvdGhlciB0YWJzIGxpc3RlbmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29uc29sZS5sb2c7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VJRCA9IEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRDtcbiAgICAgICAgR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEICs9IDE7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlSUQgPiAwICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ011bHRpcGxlIEdvVHJ1ZUNsaWVudCBpbnN0YW5jZXMgZGV0ZWN0ZWQgaW4gdGhlIHNhbWUgYnJvd3NlciBjb250ZXh0LiBJdCBpcyBub3QgYW4gZXJyb3IsIGJ1dCB0aGlzIHNob3VsZCBiZSBhdm9pZGVkIGFzIGl0IG1heSBwcm9kdWNlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGVuIHVzZWQgY29uY3VycmVudGx5IHVuZGVyIHRoZSBzYW1lIHN0b3JhZ2Uga2V5LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z01lc3NhZ2VzID0gISFzZXR0aW5ncy5kZWJ1ZztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBzZXR0aW5ncy5kZWJ1ZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RTZXNzaW9uID0gc2V0dGluZ3MucGVyc2lzdFNlc3Npb247XG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSA9IHNldHRpbmdzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGkoe1xuICAgICAgICAgICAgdXJsOiBzZXR0aW5ncy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBzZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2g6IHNldHRpbmdzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnM7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goc2V0dGluZ3MuZmV0Y2gpO1xuICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrIHx8IGxvY2tOb09wO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHNldHRpbmdzLmRldGVjdFNlc3Npb25JblVybDtcbiAgICAgICAgdGhpcy5mbG93VHlwZSA9IHNldHRpbmdzLmZsb3dUeXBlO1xuICAgICAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBzZXR0aW5ncy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyO1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jaykge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jyb3dzZXIoKSAmJiAoKF9hID0gZ2xvYmFsVGhpcyA9PT0gbnVsbCB8fCBnbG9iYWxUaGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2tzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbmF2aWdhdG9yTG9jaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IGxvY2tOb09wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0U2Vzc2lvbikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzZXR0aW5ncy5zdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gbG9jYWxTdG9yYWdlQWRhcHRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCwgbXVsdGktdGFiIHN0YXRlIGNoYW5nZXMgd2lsbCBub3QgYmUgYXZhaWxhYmxlJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJyb2FkY2FzdENoYW5uZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpOyAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoYEdvVHJ1ZUNsaWVudEAke3RoaXMuaW5zdGFuY2VJRH0gKCR7dmVyc2lvbn0pICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tVcmxUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAnaW1wbGljaXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXdhaXQgdGhpcy5faXNQS0NFQ2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdwa2NlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWxlZCBsb2dpbiBhdHRlbXB0IHZpYSB1cmwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgc2Vzc2lvbiBhcyBpbiB2ZXJpZnlPdHAsIHNpZ25VcCBhbmQgc2lnbkluV2l0aCpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZGV0ZWN0ZWQgc2Vzc2lvbiBpbiBVUkwnLCBzZXNzaW9uLCAncmVkaXJlY3QgdHlwZScsIHJlZGlyZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09ICdyZWNvdmVyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdQQVNTV09SRF9SRUNPVkVSWScsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB3aXRoIGFuIGVtYWlsIGFuZCBwYXNzd29yZCBvciBwaG9uZSBhbmQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IgdGhhdCB0aGVcbiAgICAgKiBlbWFpbC9waG9uZSBhbmQgcGFzc3dvcmQgY29tYmluYXRpb24gaXMgd3Jvbmcgb3IgdGhhdCB0aGUgYWNjb3VudCBjYW4gb25seVxuICAgICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aFBhc3N3b3JkKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9IChzdG9yYWdlSXRlbSAhPT0gbnVsbCAmJiBzdG9yYWdlSXRlbSAhPT0gdm9pZCAwID8gc3RvcmFnZUl0ZW0gOiAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyByZWRpcmVjdFR5cGU6IHJlZGlyZWN0VHlwZSAhPT0gbnVsbCAmJiByZWRpcmVjdFR5cGUgIT09IHZvaWQgMCA/IHJlZGlyZWN0VHlwZSA6IG51bGwgfSksIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBzaWduaW5nIGluIHdpdGggYW4gT0lEQyBJRCB0b2tlbi4gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHVzZWRcbiAgICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoSWRUb2tlbihjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgICAqXG4gICAgICogSWYgdGhlIGB7eyAuQ29uZmlybWF0aW9uVVJMIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhIG1hZ2ljbGluayB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAgICogY2FuIG9ubHkgYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKlxuICAgICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICAgKiBpZiB5b3UgYXJlIHVzaW5nIHBob25lIHNpZ24gaW4gd2l0aCB0aGUgJ3doYXRzYXBwJyBjaGFubmVsLiBUaGUgd2hhdHNhcHBcbiAgICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICogYXQgdGhpcyB0aW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIFBLQ0Ugd2hlbiBhbiBlbWFpbCBpcyBwYXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgZ2l2ZW4gYSBVc2VyIHN1cHBsaWVkIE9UUCBvciBUb2tlbkhhc2ggcmVjZWl2ZWQgdGhyb3VnaCBtb2JpbGUgb3IgZW1haWwuXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0VG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FwdGNoYVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgIGNhcHRjaGFUb2tlbiA9IChfYiA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY2FwdGNoYVRva2VuIH0gfSksXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIG9uIHRva2VuIHZlcmlmaWNhdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhwYXJhbXMudHlwZSA9PSAncmVjb3ZlcnknID8gJ1BBU1NXT1JEX1JFQ09WRVJZJyA6ICdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAgICogc3VjY2Vzc2Z1bCBTU08gYXR0ZW1wdCB3aWxsIHJlZGlyZWN0IHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGlkZW50aXR5XG4gICAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAgICogcmVnaXN0ZXJlZCBvbiB0aGUgQXV0aCBpbnN0YW5jZSB0aGUgcmVkaXJlY3Qgd2lsbCB1c2UgdGhhdCBvcmdhbml6YXRpb24nc1xuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBidWlsdCBhbiBvcmdhbml6YXRpb24tc3BlY2lmaWMgbG9naW4gcGFnZSwgeW91IGNhbiB1c2UgdGhlXG4gICAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoU1NPKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlYXV0aGVudGljYXRpb24gT1RQIHRvIHRoZSB1c2VyJ3MgZW1haWwgb3IgcGhvbmUgbnVtYmVyLlxuICAgICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1cHByZXNzV2FybmluZyA9IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHlTZXNzaW9uID0gbmV3IFByb3h5KGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB3YXJuaW5nIHdoZW4gdGhlIHVzZXIgb2JqZWN0IGlzIGJlaW5nIGFjY2Vzc2VkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlOyAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7IC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB7IGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBKV1QgKHdpdGhvdXQgcGVyZm9ybWluZyBhbnkgdmFsaWRhdGlvbikuXG4gICAgICovXG4gICAgX2RlY29kZUpXVChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZUpXVFBheWxvYWQoand0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBleHBpcmVkLCBzZXRTZXNzaW9uIHdpbGwgdGFrZSBjYXJlIG9mIHJlZnJlc2hpbmcgaXQgdG8gb2J0YWluIGEgbmV3IHNlc3Npb24uXG4gICAgICogSWYgdGhlIHJlZnJlc2ggdG9rZW4gb3IgYWNjZXNzIHRva2VuIGluIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24gdGhhdCBtaW5pbWFsbHkgY29udGFpbnMgYW4gYWNjZXNzIHRva2VuIGFuZCByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHNldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4gfHwgIWN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgICAgIGxldCBleHBpcmVzQXQgPSB0aW1lTm93O1xuICAgICAgICAgICAgbGV0IGhhc0V4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZUpXVFBheWxvYWQoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmV4cCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBheWxvYWQuZXhwO1xuICAgICAgICAgICAgICAgIGhhc0V4cGlyZWQgPSBleHBpcmVzQXQgPD0gdGltZU5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZXNzaW9uOiByZWZyZXNoZWRTZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlZnJlc2hlZFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSByZWZyZXNoZWRTZXNzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IGRhdGEudXNlcixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5fdHlwZTogJ2JlYXJlcicsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfaW46IGV4cGlyZXNBdCAtIHRpbWVOb3csXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHNlc3Npb24sIHJlZ2FyZGxlc3Mgb2YgZXhwaXJ5IHN0YXR1cy5cbiAgICAgKiBUYWtlcyBpbiBhbiBvcHRpb25hbCBjdXJyZW50IHNlc3Npb24uIElmIG5vdCBwYXNzZWQgaW4sIHRoZW4gcmVmcmVzaFNlc3Npb24oKSB3aWxsIGF0dGVtcHQgdG8gcmV0cmlldmUgaXQgZnJvbSBnZXRTZXNzaW9uKCkuXG4gICAgICogSWYgdGhlIGN1cnJlbnQgc2Vzc2lvbidzIHJlZnJlc2ggdG9rZW4gaXMgaW52YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgICogQHBhcmFtIGN1cnJlbnRTZXNzaW9uIFRoZSBjdXJyZW50IHNlc3Npb24uIElmIHBhc3NlZCBpbiwgaXQgbXVzdCBjb250YWluIGEgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24gPSAoX2EgPSBkYXRhLnNlc3Npb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudFNlc3Npb24gPT09IG51bGwgfHwgY3VycmVudFNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2Vzc2lvbiBkYXRhIGZyb20gYSBVUkwgc3RyaW5nXG4gICAgICovXG4gICAgYXN5bmMgX2dldFNlc3Npb25Gcm9tVVJMKHBhcmFtcywgY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIGJyb3dzZXIgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yIGluIHRoZSBVUkwsIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgZmxvdyBpdCBpcywgd2UganVzdCByZXR1cm4gdGhlIGVycm9yLlxuICAgICAgICAgICAgaWYgKHBhcmFtcy5lcnJvciB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgcGFyYW1zLmVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXJyb3IgY2xhc3MgcmV0dXJuZWQgaW1wbGllcyB0aGF0IHRoZSByZWRpcmVjdCBpcyBmcm9tIGFuIGltcGxpY2l0IGdyYW50IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgYWxzbyBiZSBmcm9tIGEgcmVkaXJlY3QgZXJyb3IgZnJvbSBhIFBLQ0UgZmxvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbiB8fCAnRXJyb3IgaW4gVVJMIHdpdGggdW5zcGVjaWZpZWQgZXJyb3JfZGVzY3JpcHRpb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IgfHwgJ3Vuc3BlY2lmaWVkX2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcGFyYW1zLmVycm9yX2NvZGUgfHwgJ3Vuc3BlY2lmaWVkX2NvZGUnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGZvciBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIGZsb3dUeXBlIGluaXRpYWxpc2VkIGluIHRoZSBjbGllbnQgYW5kIHRoZSBVUkwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgc3dpdGNoIChjYWxsYmFja1VybFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpbXBsaWNpdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vdCBhIHZhbGlkIFBLQ0UgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncGtjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdOb3QgYSB2YWxpZCBpbXBsaWNpdCBncmFudCBmbG93IHVybC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbWlzbWF0Y2ggc28gd2UgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSByZWRpcmVjdCBmb3IgUEtDRSwgd2UgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgY29kZSBmcm9tIHRoZSBVUkwgZm9yIHRoZSBjb2RlIGV4Y2hhbmdlXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tVcmxUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnYmVnaW4nLCAnaXMgUEtDRSBmbG93JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcignTm8gY29kZSBkZXRlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKHBhcmFtcy5jb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdjb2RlJyk7XG4gICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHdpbmRvdy5oaXN0b3J5LnN0YXRlLCAnJywgdXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogZGF0YS5zZXNzaW9uLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvdmlkZXJfdG9rZW4sIHByb3ZpZGVyX3JlZnJlc2hfdG9rZW4sIGFjY2Vzc190b2tlbiwgcmVmcmVzaF90b2tlbiwgZXhwaXJlc19pbiwgZXhwaXJlc19hdCwgdG9rZW5fdHlwZSwgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmICghYWNjZXNzX3Rva2VuIHx8ICFleHBpcmVzX2luIHx8ICFyZWZyZXNoX3Rva2VuIHx8ICF0b2tlbl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm8gc2Vzc2lvbiBkZWZpbmVkIGluIFVSTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gcGFyc2VJbnQoZXhwaXJlc19pbik7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdyArIGV4cGlyZXNJbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGFyc2VJbnQoZXhwaXJlc19hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxseUV4cGlyZXNJbiA9IGV4cGlyZXNBdCAtIHRpbWVOb3c7XG4gICAgICAgICAgICBpZiAoYWN0dWFsbHlFeHBpcmVzSW4gKiAxMDAwIDw9IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCBleHBpcmVzIGluICR7YWN0dWFsbHlFeHBpcmVzSW59cywgc2hvdWxkIGhhdmUgYmVlbiBjbG9zZXIgdG8gJHtleHBpcmVzSW59c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNzdWVkQXQgPSBleHBpcmVzQXQgLSBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAodGltZU5vdyAtIGlzc3VlZEF0ID49IDEyMCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgd2FzIGlzc3VlZCBvdmVyIDEyMHMgYWdvLCBVUkwgY291bGQgYmUgc3RhbGUnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgaW4gdGhlIGZ1dHVyZT8gQ2hlY2sgdGhlIGRldmljZSBjbG9jayBmb3Igc2tldycsIGlzc3VlZEF0LCBleHBpcmVzQXQsIHRpbWVOb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihhY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcl90b2tlbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzSW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19hdDogZXhwaXJlc0F0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5fdHlwZSxcbiAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRva2VucyBmcm9tIFVSTFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2dldFNlc3Npb25Gcm9tVVJMKCknLCAnY2xlYXJpbmcgd2luZG93LmxvY2F0aW9uLmhhc2gnKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBwYXJhbXMudHlwZSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGNvbnRhaW5zIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYW4gaW1wbGljaXQgb2F1dGggZ3JhbnQgZmxvdyAoaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY3NDkuaHRtbCNzZWN0aW9uLTQuMilcbiAgICAgKi9cbiAgICBfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHBhcmFtcy5hY2Nlc3NfdG9rZW4gfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBhbmQgYmFja2luZyBzdG9yYWdlIGNvbnRhaW4gcGFyYW1ldGVycyBnaXZlbiBieSBhIFBLQ0UgZmxvd1xuICAgICAqL1xuICAgIGFzeW5jIF9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0b3JhZ2VDb250ZW50ID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIHJldHVybiAhIShwYXJhbXMuY29kZSAmJiBjdXJyZW50U3RvcmFnZUNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNpZGUgYSBicm93c2VyIGNvbnRleHQsIGBzaWduT3V0KClgIHdpbGwgcmVtb3ZlIHRoZSBsb2dnZWQgaW4gdXNlciBmcm9tIHRoZSBicm93c2VyIHNlc3Npb24gYW5kIGxvZyB0aGVtIG91dCAtIHJlbW92aW5nIGFsbCBpdGVtcyBmcm9tIGxvY2Fsc3RvcmFnZSBhbmQgdGhlbiB0cmlnZ2VyIGEgYFwiU0lHTkVEX09VVFwiYCBldmVudC5cbiAgICAgKlxuICAgICAqIEZvciBzZXJ2ZXItc2lkZSBtYW5hZ2VtZW50LCB5b3UgY2FuIHJldm9rZSBhbGwgcmVmcmVzaCB0b2tlbnMgZm9yIGEgdXNlciBieSBwYXNzaW5nIGEgdXNlcidzIEpXVCB0aHJvdWdoIHRvIGBhdXRoLmFwaS5zaWduT3V0KEpXVDogc3RyaW5nKWAuXG4gICAgICogVGhlcmUgaXMgbm8gd2F5IHRvIHJldm9rZSBhIHVzZXIncyBhY2Nlc3MgdG9rZW4gand0IHVudGlsIGl0IGV4cGlyZXMuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBhIHNob3J0ZXIgZXhwaXJ5IG9uIHRoZSBqd3QgZm9yIHRoaXMgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdXNpbmcgYG90aGVyc2Agc2NvcGUsIG5vIGBTSUdORURfT1VUYCBldmVudCBpcyBmaXJlZCFcbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KG9wdGlvbnMgPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NpZ25PdXQob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2lnbk91dCh7IHNjb3BlIH0gPSB7IHNjb3BlOiAnZ2xvYmFsJyB9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuO1xuICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5hZG1pbi5zaWduT3V0KGFjY2Vzc1Rva2VuLCBzY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDRzIHNpbmNlIHVzZXIgbWlnaHQgbm90IGV4aXN0IGFueW1vcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIDQwMXMgc2luY2UgYW4gaW52YWxpZCBvciBleHBpcmVkIEpXVCBzaG91bGQgc2lnbiBvdXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc0F1dGhBcGlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvci5zdGF0dXMgPT09IDQwNCB8fCBlcnJvci5zdGF0dXMgPT09IDQwMSB8fCBlcnJvci5zdGF0dXMgPT09IDQwMykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlICE9PSAnb3RoZXJzJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIGEgbm90aWZpY2F0aW9uIGV2ZXJ5IHRpbWUgYW4gYXV0aCBldmVudCBoYXBwZW5zLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiBhbiBhdXRoIGV2ZW50IGhhcHBlbnMuXG4gICAgICovXG4gICAgb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW5rcyBhbiBvYXV0aCBpZGVudGl0eSB0byBhbiBleGlzdGluZyB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgbGlua0lkZW50aXR5KGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy9hdXRob3JpemVgLCBjcmVkZW50aWFscy5wcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogKF9jID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgdXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2UgPSAoX2QgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICEoKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNraXBCcm93c2VyUmVkaXJlY3QpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmxpbmtzIGFuIGlkZW50aXR5IGZyb20gYSB1c2VyIGJ5IGRlbGV0aW5nIGl0LiBUaGUgdXNlciB3aWxsIG5vIGxvbmdlciBiZSBhYmxlIHRvIHNpZ24gaW4gd2l0aCB0aGF0IGlkZW50aXR5IG9uY2UgaXQncyB1bmxpbmtlZC5cbiAgICAgKi9cbiAgICBhc3luYyB1bmxpbmtJZGVudGl0eShpZGVudGl0eSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzLyR7aWRlbnRpdHkuaWRlbnRpdHlfaWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IEpXVC5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEEgdmFsaWQgcmVmcmVzaCB0b2tlbiB0aGF0IHdhcyByZXR1cm5lZCBvbiBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19yZWZyZXNoQWNjZXNzVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHdpbGwgYXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXRyeWFibGUoYXN5bmMgKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKTsgLy8gMjAwLCA0MDAsIDgwMCwgLi4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2hpbmcgYXR0ZW1wdCcsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAoYXR0ZW1wdCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0QmFja09mZkludGVydmFsID0gMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2lzVmFsaWRTZXNzaW9uKG1heWJlU2Vzc2lvbikge1xuICAgICAgICBjb25zdCBpc1ZhbGlkU2Vzc2lvbiA9IHR5cGVvZiBtYXliZVNlc3Npb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBtYXliZVNlc3Npb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgICdhY2Nlc3NfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nIGluIG1heWJlU2Vzc2lvbiAmJlxuICAgICAgICAgICAgJ2V4cGlyZXNfYXQnIGluIG1heWJlU2Vzc2lvbjtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRTZXNzaW9uO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlUHJvdmlkZXJTaWduSW4ocHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgdGhpcy5fZ2V0VXJsRm9yUHJvdmlkZXIoYCR7dGhpcy51cmx9L2F1dGhvcml6ZWAsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICBzY29wZXM6IG9wdGlvbnMuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVQcm92aWRlclNpZ25JbigpJywgJ3Byb3ZpZGVyJywgcHJvdmlkZXIsICdvcHRpb25zJywgb3B0aW9ucywgJ3VybCcsIHVybCk7XG4gICAgICAgIC8vIHRyeSB0byBvcGVuIG9uIHRoZSBicm93c2VyXG4gICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlciwgdXJsIH0sIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBzZXNzaW9uIGZyb20gTG9jYWxTdG9yYWdlIGFuZCByZWZyZXNoZXMgdGhlIHRva2VuXG4gICAgICogTm90ZTogdGhpcyBtZXRob2QgaXMgYXN5bmMgdG8gYWNjb21tb2RhdGUgZm9yIEFzeW5jU3RvcmFnZSBlLmcuIGluIFJlYWN0IG5hdGl2ZS5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVjb3ZlckFuZFJlZnJlc2goKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGZyb20gc3RvcmFnZScsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFNlc3Npb24oY3VycmVudFNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnc2Vzc2lvbiBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzV2l0aE1hcmdpbiA9ICgoX2EgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eSkgKiAxMDAwIC0gRGF0ZS5ub3coKSA8IEVYUElSWV9NQVJHSU5fTVM7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsIGBzZXNzaW9uIGhhcyR7ZXhwaXJlc1dpdGhNYXJnaW4gPyAnJyA6ICcgbm90J30gZXhwaXJlZCB3aXRoIG1hcmdpbiBvZiAke0VYUElSWV9NQVJHSU5fTVN9c2ApO1xuICAgICAgICAgICAgaWYgKGV4cGlyZXNXaXRoTWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbiAmJiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaCBmYWlsZWQgd2l0aCBhIG5vbi1yZXRyeWFibGUgZXJyb3IsIHJlbW92aW5nIHRoZSBzZXNzaW9uJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcGVyc2lzdCBjdXJyZW50U2Vzc2lvbiBhZ2FpbiwgYXMgd2UganVzdCBsb2FkZWQgaXQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHN0b3JhZ2U7IHBlcnNpc3RpbmcgaXQgYWdhaW4gbWF5IG92ZXJ3cml0ZSBhIHZhbHVlIHNhdmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBjbGllbnQgd2l0aCBhY2Nlc3MgdG8gdGhlIHNhbWUgbG9jYWwgc3RvcmFnZVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBjdXJyZW50U2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2NhbGxSZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWZyZXNoaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19jYWxsUmVmcmVzaFRva2VuKCR7cmVmcmVzaFRva2VuLnN1YnN0cmluZygwLCA1KX0uLi4pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmICghZGF0YS5zZXNzaW9uKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdUT0tFTl9SRUZSRVNIRUQnLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBkYXRhLnNlc3Npb24sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBzZXNzaW9uOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQsIHNlc3Npb24sIGJyb2FkY2FzdCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gYCNfbm90aWZ5QWxsU3Vic2NyaWJlcnMoJHtldmVudH0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnYmVnaW4nLCBzZXNzaW9uLCBgYnJvYWRjYXN0ID0gJHticm9hZGNhc3R9YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5icm9hZGNhc3RDaGFubmVsICYmIGJyb2FkY2FzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbC5wb3N0TWVzc2FnZSh7IGV2ZW50LCBzZXNzaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnZhbHVlcygpKS5tYXAoYXN5bmMgKHgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB4LmNhbGxiYWNrKGV2ZW50LCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVycm9ycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCBjdXJyZW50U2Vzc2lvbiBhbmQgY3VycmVudFVzZXJcbiAgICAgKiBwcm9jZXNzIHRvIF9zdGFydEF1dG9SZWZyZXNoVG9rZW4gaWYgcG9zc2libGVcbiAgICAgKi9cbiAgICBhc3luYyBfc2F2ZVNlc3Npb24oc2Vzc2lvbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zYXZlU2Vzc2lvbigpJywgc2Vzc2lvbik7XG4gICAgICAgIC8vIF9zYXZlU2Vzc2lvbiBpcyBhbHdheXMgY2FsbGVkIHdoZW5ldmVyIGEgbmV3IHNlc3Npb24gaGFzIGJlZW4gYWNxdWlyZWRcbiAgICAgICAgLy8gc28gd2UgY2FuIHNhZmVseSBzdXBwcmVzcyB0aGUgd2FybmluZyByZXR1cm5lZCBieSBmdXR1cmUgZ2V0U2Vzc2lvbiBjYWxsc1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIHNlc3Npb24pO1xuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlU2Vzc2lvbigpJyk7XG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfT1VUJywgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW55IHJlZ2lzdGVyZWQgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIHtAc2VlICNzdGFydEF1dG9SZWZyZXNofVxuICAgICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAgICovXG4gICAgX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKScpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaztcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc0Jyb3dzZXIoKSAmJiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlbW92aW5nIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2sgZmFpbGVkJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBhc3luYyBfc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0YXJ0QXV0b1JlZnJlc2goKScpO1xuICAgICAgICBjb25zdCB0aWNrZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpLCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyk7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSB0aWNrZXI7XG4gICAgICAgIGlmICh0aWNrZXIgJiYgdHlwZW9mIHRpY2tlciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRpY2tlci51bnJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gdGlja2VyIGlzIGEgTm9kZUpTIFRpbWVvdXQgb2JqZWN0IHRoYXQgaGFzIGFuIGB1bnJlZmAgbWV0aG9kXG4gICAgICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVvdXR1bnJlZlxuICAgICAgICAgICAgLy8gV2hlbiBhdXRvIHJlZnJlc2ggaXMgdXNlZCBpbiBOb2RlSlMgKGxpa2UgZm9yIHRlc3RpbmcpIHRoZVxuICAgICAgICAgICAgLy8gYHNldEludGVydmFsYCBpcyBwcmV2ZW50aW5nIHRoZSBwcm9jZXNzIGZyb20gYmVpbmcgbWFya2VkIGFzXG4gICAgICAgICAgICAvLyBmaW5pc2hlZCBhbmQgdGVzdHMgcnVuIGVuZGxlc3NseS4gVGhpcyBjYW4gYmUgcHJldmVudGVkIGJ5IGNhbGxpbmdcbiAgICAgICAgICAgIC8vIGB1bnJlZigpYCBvbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICAgICAgICAgICAgdGlja2VyLnVucmVmKCk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gc2ltaWxhciBsaWtlIGZvciBOb2RlSlMsIGJ1dCB3aXRoIHRoZSBEZW5vIEFQSVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZW5vLmxhbmQvYXBpQGxhdGVzdD91bnN0YWJsZSZzPURlbm8udW5yZWZUaW1lclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgICAgICBEZW5vLnVucmVmVGltZXIodGlja2VyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBydW4gdGhlIHRpY2sgaW1tZWRpYXRlbHksIGJ1dCBpbiB0aGUgbmV4dCBwYXNzIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXRcbiAgICAgICAgLy8gI19pbml0aWFsaXplIGNhbiBiZSBhbGxvd2VkIHRvIGNvbXBsZXRlIHdpdGhvdXQgcmVjdXJzaXZlbHkgd2FpdGluZyBvblxuICAgICAgICAvLyBpdHNlbGZcbiAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdG9wQXV0b1JlZnJlc2h9LiBVc2UgdGhpc1xuICAgICAqIHdpdGhpbiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBhc3luYyBfc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdG9wQXV0b1JlZnJlc2goKScpO1xuICAgICAgICBjb25zdCB0aWNrZXIgPSB0aGlzLmF1dG9SZWZyZXNoVGlja2VyO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHRpY2tlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aWNrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhbiBhdXRvLXJlZnJlc2ggcHJvY2VzcyBpbiB0aGUgYmFja2dyb3VuZC4gVGhlIHNlc3Npb24gaXMgY2hlY2tlZFxuICAgICAqIGV2ZXJ5IGZldyBzZWNvbmRzLiBDbG9zZSB0byB0aGUgdGltZSBvZiBleHBpcmF0aW9uIGEgcHJvY2VzcyBpcyBzdGFydGVkIHRvXG4gICAgICogcmVmcmVzaCB0aGUgc2Vzc2lvbi4gSWYgcmVmcmVzaGluZyBmYWlscyBpdCB3aWxsIGJlIHJldHJpZWQgZm9yIGFzIGxvbmcgYXNcbiAgICAgKiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugc2V0IHRoZSB7QGxpbmsgR29UcnVlQ2xpZW50T3B0aW9ucyNhdXRvUmVmcmVzaFRva2VufSB5b3UgZG9uJ3QgbmVlZFxuICAgICAqIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIE9uIGJyb3dzZXJzIHRoZSByZWZyZXNoIHByb2Nlc3Mgd29ya3Mgb25seSB3aGVuIHRoZSB0YWIvd2luZG93IGlzIGluIHRoZVxuICAgICAqIGZvcmVncm91bmQgdG8gY29uc2VydmUgcmVzb3VyY2VzIGFzIHdlbGwgYXMgcHJldmVudCByYWNlIGNvbmRpdGlvbnMgYW5kXG4gICAgICogZmxvb2RpbmcgYXV0aCB3aXRoIHJlcXVlc3RzLiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZFxuICAgICAqIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmUgcmVtb3ZlZCBhbmQgeW91IG11c3QgbWFuYWdlIHZpc2liaWxpdHlcbiAgICAgKiBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogT24gbm9uLWJyb3dzZXIgcGxhdGZvcm1zIHRoZSByZWZyZXNoIHByb2Nlc3Mgd29ya3MgKmNvbnRpbnVvdXNseSogaW4gdGhlXG4gICAgICogYmFja2dyb3VuZCwgd2hpY2ggbWF5IG5vdCBiZSBkZXNpcmFibGUuIFlvdSBzaG91bGQgaG9vayBpbnRvIHlvdXJcbiAgICAgKiBwbGF0Zm9ybSdzIGZvcmVncm91bmQgaW5kaWNhdGlvbiBtZWNoYW5pc20gYW5kIGNhbGwgdGhlc2UgbWV0aG9kc1xuICAgICAqIGFwcHJvcHJpYXRlbHkgdG8gY29uc2VydmUgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBhc3luYyBzdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgYW4gYWN0aXZlIGF1dG8gcmVmcmVzaCBwcm9jZXNzIHJ1bm5pbmcgaW4gdGhlIGJhY2tncm91bmQgKGlmIGFueSkuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBhbnkgbWFuYWdlZCB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlXG4gICAgICogcmVtb3ZlZCBhbmQgeW91IG11c3QgbWFuYWdlIHZpc2liaWxpdHkgY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgI3N0YXJ0QXV0b1JlZnJlc2h9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgc3RvcEF1dG9SZWZyZXNoKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBhdXRvIHJlZnJlc2ggdG9rZW4gdGljay5cbiAgICAgKi9cbiAgICBhc3luYyBfYXV0b1JlZnJlc2hUb2tlblRpY2soKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKDAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uIHx8ICFzZXNzaW9uLnJlZnJlc2hfdG9rZW4gfHwgIXNlc3Npb24uZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ25vIHNlc3Npb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIHdpbGwgZXhwaXJlIGluIHRoaXMgbWFueSB0aWNrcyAob3IgaGFzIGFscmVhZHkgZXhwaXJlZCBpZiA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJblRpY2tzID0gTWF0aC5mbG9vcigoc2Vzc2lvbi5leHBpcmVzX2F0ICogMTAwMCAtIG5vdykgLyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsIGBhY2Nlc3MgdG9rZW4gZXhwaXJlcyBpbiAke2V4cGlyZXNJblRpY2tzfSB0aWNrcywgYSB0aWNrIGxhc3RzICR7QVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVN9bXMsIHJlZnJlc2ggdGhyZXNob2xkIGlzICR7QVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEfSB0aWNrc2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBpcmVzSW5UaWNrcyA8PSBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihzZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBdXRvIHJlZnJlc2ggdGljayBmYWlsZWQgd2l0aCBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSB0cmFuc2llbnQgZXJyb3IuJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmlzQWNxdWlyZVRpbWVvdXQgfHwgZSBpbnN0YW5jZW9mIExvY2tBY3F1aXJlVGltZW91dEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2F1dG8gcmVmcmVzaCB0b2tlbiB0aWNrIGxvY2sgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIG9uIHRoZSBicm93c2VyIC8gcGxhdGZvcm0sIHdoaWNoIGluLXR1cm4gcnVuXG4gICAgICogYWxnb3JpdGhtcyB3aGVuIHRoZSBicm93c2VyIHdpbmRvdy90YWIgYXJlIGluIGZvcmVncm91bmQuIE9uIG5vbi1icm93c2VyXG4gICAgICogcGxhdGZvcm1zIGl0IGFzc3VtZXMgYWx3YXlzIGZvcmVncm91bmQuXG4gICAgICovXG4gICAgYXN5bmMgX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKScpO1xuICAgICAgICBpZiAoIWlzQnJvd3NlcigpIHx8ICEod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIGFsd2F5c1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIG5vdyBpbW1lZGlhdGVseSBjYWxsIHRoZSB2aXNiaWxpdHkgY2hhbmdlZCBjYWxsYmFjayB0byBzZXR1cCB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCB2aXNiaWxpdHkgc3RhdGVcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQodHJ1ZSk7IC8vIGluaXRpYWwgY2FsbFxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgcmVnaXN0ZXJlZCB3aXRoIGB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScpYC5cbiAgICAgKi9cbiAgICBhc3luYyBfb25WaXNpYmlsaXR5Q2hhbmdlZChjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICBjb25zdCBtZXRob2ROYW1lID0gYCNfb25WaXNpYmlsaXR5Q2hhbmdlZCgke2NhbGxlZEZyb21Jbml0aWFsaXplfSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAndmlzaWJpbGl0eVN0YXRlJywgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgb25seSBvbiBmb2N1c2VkIHRhYnNcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBwcmV2ZW50cyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhlIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQsIGkuZS4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2l0aW9uZWQgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSBzbyB3ZSBuZWVkIHRvIHNlZSBpZiB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSByZWNvdmVyZWQgaW1tZWRpYXRlbHkuLi4gYnV0IHRvIGRvIHRoYXQgd2UgbmVlZCB0byBhY3F1aXJlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxvY2sgZmlyc3QgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ2FjcXVpcmVkIHRoZSBsb2NrIHRvIHJlY292ZXIgdGhlIHNlc3Npb24sIGJ1dCB0aGUgYnJvd3NlciB2aXNpYmlsaXR5U3RhdGUgaXMgbm8gbG9uZ2VyIHZpc2libGUsIGFib3J0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBsb2NrLCBhYm9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY292ZXIgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSByZWxldmFudCBsb2dpbiBVUkwgZm9yIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBBIFVSTCBvciBtb2JpbGUgYWRkcmVzcyB0byBzZW5kIHRoZSB1c2VyIHRvIGFmdGVyIHRoZXkgYXJlIGNvbmZpcm1lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zY29wZXMgQSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiBzY29wZXMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVlcnlQYXJhbXMgQW4gb2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyBjb250YWluaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgZ3JhbnRlZCB0byB0aGUgT0F1dGggYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgX2dldFVybEZvclByb3ZpZGVyKHVybCwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gW2Bwcm92aWRlcj0ke2VuY29kZVVSSUNvbXBvbmVudChwcm92aWRlcil9YF07XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHJlZGlyZWN0X3RvPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMucmVkaXJlY3RUbyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY29wZXMpIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGBzY29wZXM9JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5zY29wZXMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgY29uc3QgZmxvd1BhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZSl9YCxcbiAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlTWV0aG9kKX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChmbG93UGFyYW1zLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhvcHRpb25zLnF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKHF1ZXJ5LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNraXBfaHR0cF9yZWRpcmVjdD0ke29wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dXJsfT8ke3VybFBhcmFtcy5qb2luKCcmJyl9YDtcbiAgICB9XG4gICAgYXN5bmMgX3VuZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Vucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oeyBmcmllbmRseV9uYW1lOiBwYXJhbXMuZnJpZW5kbHlOYW1lLCBmYWN0b3JfdHlwZTogcGFyYW1zLmZhY3RvclR5cGUgfSwgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAncGhvbmUnID8geyBwaG9uZTogcGFyYW1zLnBob25lIH0gOiB7IGlzc3VlcjogcGFyYW1zLmlzc3VlciB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZhY3RvclR5cGUgPT09ICd0b3RwJyAmJiAoKF9iID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnRvdHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5xcl9jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSN2ZXJpZnl9XG4gICAgICovXG4gICAgYXN5bmMgX3ZlcmlmeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS92ZXJpZnlgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7IGNvZGU6IHBhcmFtcy5jb2RlLCBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihPYmplY3QuYXNzaWduKHsgZXhwaXJlc19hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkgKyBkYXRhLmV4cGlyZXNfaW4gfSwgZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnTUZBX0NIQUxMRU5HRV9WRVJJRklFRCcsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNjaGFsbGVuZ2V9XG4gICAgICovXG4gICAgYXN5bmMgX2NoYWxsZW5nZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH0vY2hhbGxlbmdlYCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogeyBjaGFubmVsOiBwYXJhbXMuY2hhbm5lbCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KHBhcmFtcykge1xuICAgICAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VEYXRhLmlkLFxuICAgICAgICAgICAgY29kZTogcGFyYW1zLmNvZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjbGlzdEZhY3RvcnN9XG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKCkge1xuICAgICAgICAvLyB1c2UgI2dldFVzZXIgaW5zdGVhZCBvZiAjX2dldFVzZXIgYXMgdGhlIGZvcm1lciBhY3F1aXJlcyBhIGxvY2tcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9ycyA9ICh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuZmFjdG9ycykgfHwgW107XG4gICAgICAgIGNvbnN0IHRvdHAgPSBmYWN0b3JzLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICd0b3RwJyAmJiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKTtcbiAgICAgICAgY29uc3QgcGhvbmUgPSBmYWN0b3JzLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3IuZmFjdG9yX3R5cGUgPT09ICdwaG9uZScgJiYgZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgYWxsOiBmYWN0b3JzLFxuICAgICAgICAgICAgICAgIHRvdHAsXG4gICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAgICovXG4gICAgYXN5bmMgX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgY3VycmVudExldmVsOiBudWxsLCBuZXh0TGV2ZWw6IG51bGwsIGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHM6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuX2RlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHBheWxvYWQuYWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmaWVkRmFjdG9ycyA9IChfYiA9IChfYSA9IHNlc3Npb24udXNlci5mYWN0b3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChmYWN0b3IpID0+IGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAodmVyaWZpZWRGYWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzID0gcGF5bG9hZC5hbXIgfHwgW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRCA9IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Hb1RydWVDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiREVGQVVMVF9IRUFERVJTIiwiRVhQSVJZX01BUkdJTl9NUyIsIkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TIiwiQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEIiwiR09UUlVFX1VSTCIsIlNUT1JBR0VfS0VZIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJpc0F1dGhBcGlFcnJvciIsImlzQXV0aEVycm9yIiwiaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsImlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIl9yZXF1ZXN0IiwiX3Nlc3Npb25SZXNwb25zZSIsIl9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJkZWNvZGVKV1RQYXlsb2FkIiwiRGVmZXJyZWQiLCJnZXRJdGVtQXN5bmMiLCJpc0Jyb3dzZXIiLCJyZW1vdmVJdGVtQXN5bmMiLCJyZXNvbHZlRmV0Y2giLCJzZXRJdGVtQXN5bmMiLCJ1dWlkIiwicmV0cnlhYmxlIiwic2xlZXAiLCJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kIiwibG9jYWxTdG9yYWdlQWRhcHRlciIsIm1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIiLCJwb2x5ZmlsbEdsb2JhbFRoaXMiLCJ2ZXJzaW9uIiwiTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJuYXZpZ2F0b3JMb2NrIiwiREVGQVVMVF9PUFRJT05TIiwidXJsIiwic3RvcmFnZUtleSIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImhlYWRlcnMiLCJmbG93VHlwZSIsImRlYnVnIiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsImxvY2tOb09wIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJHb1RydWVDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYSIsIl9iIiwibWVtb3J5U3RvcmFnZSIsInN0YXRlQ2hhbmdlRW1pdHRlcnMiLCJNYXAiLCJhdXRvUmVmcmVzaFRpY2tlciIsInZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2siLCJyZWZyZXNoaW5nRGVmZXJyZWQiLCJpbml0aWFsaXplUHJvbWlzZSIsInN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmciLCJsb2NrQWNxdWlyZWQiLCJwZW5kaW5nSW5Mb2NrIiwiYnJvYWRjYXN0Q2hhbm5lbCIsImxvZ2dlciIsImNvbnNvbGUiLCJsb2ciLCJpbnN0YW5jZUlEIiwibmV4dEluc3RhbmNlSUQiLCJ3YXJuIiwic2V0dGluZ3MiLCJPYmplY3QiLCJhc3NpZ24iLCJsb2dEZWJ1Z01lc3NhZ2VzIiwiYWRtaW4iLCJmZXRjaCIsImxvY2siLCJnbG9iYWxUaGlzIiwibmF2aWdhdG9yIiwibG9ja3MiLCJtZmEiLCJ2ZXJpZnkiLCJfdmVyaWZ5IiwiYmluZCIsImVucm9sbCIsIl9lbnJvbGwiLCJ1bmVucm9sbCIsIl91bmVucm9sbCIsImNoYWxsZW5nZSIsIl9jaGFsbGVuZ2UiLCJsaXN0RmFjdG9ycyIsIl9saXN0RmFjdG9ycyIsImNoYWxsZW5nZUFuZFZlcmlmeSIsIl9jaGFsbGVuZ2VBbmRWZXJpZnkiLCJnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsIiwic3RvcmFnZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJfZGVidWciLCJfbm90aWZ5QWxsU3Vic2NyaWJlcnMiLCJkYXRhIiwic2Vzc2lvbiIsImluaXRpYWxpemUiLCJhcmdzIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiX2FjcXVpcmVMb2NrIiwiX2luaXRpYWxpemUiLCJwYXJhbXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJjYWxsYmFja1VybFR5cGUiLCJfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2siLCJfaXNQS0NFQ2FsbGJhY2siLCJfZ2V0U2Vzc2lvbkZyb21VUkwiLCJlcnJvckNvZGUiLCJkZXRhaWxzIiwiY29kZSIsIl9yZW1vdmVTZXNzaW9uIiwicmVkaXJlY3RUeXBlIiwiX3NhdmVTZXNzaW9uIiwic2V0VGltZW91dCIsIl9yZWNvdmVyQW5kUmVmcmVzaCIsIl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwic2lnbkluQW5vbnltb3VzbHkiLCJjcmVkZW50aWFscyIsIl9jIiwicmVzIiwiYm9keSIsImdvdHJ1ZV9tZXRhX3NlY3VyaXR5IiwiY2FwdGNoYV90b2tlbiIsImNhcHRjaGFUb2tlbiIsInhmb3JtIiwidXNlciIsInNpZ25VcCIsImVtYWlsIiwicGFzc3dvcmQiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsInJlZGlyZWN0VG8iLCJlbWFpbFJlZGlyZWN0VG8iLCJjb2RlX2NoYWxsZW5nZSIsImNvZGVfY2hhbGxlbmdlX21ldGhvZCIsInBob25lIiwiY2hhbm5lbCIsInNpZ25JbldpdGhQYXNzd29yZCIsIndlYWtfcGFzc3dvcmQiLCJ3ZWFrUGFzc3dvcmQiLCJzaWduSW5XaXRoT0F1dGgiLCJfZCIsIl9oYW5kbGVQcm92aWRlclNpZ25JbiIsInByb3ZpZGVyIiwic2NvcGVzIiwicXVlcnlQYXJhbXMiLCJza2lwQnJvd3NlclJlZGlyZWN0IiwiZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbiIsImF1dGhDb2RlIiwiX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJzdG9yYWdlSXRlbSIsImNvZGVWZXJpZmllciIsInNwbGl0IiwiYXV0aF9jb2RlIiwiY29kZV92ZXJpZmllciIsInNpZ25JbldpdGhJZFRva2VuIiwidG9rZW4iLCJhY2Nlc3NfdG9rZW4iLCJub25jZSIsImlkX3Rva2VuIiwic2lnbkluV2l0aE90cCIsIl9lIiwiY3JlYXRlX3VzZXIiLCJzaG91bGRDcmVhdGVVc2VyIiwibWVzc2FnZUlkIiwibWVzc2FnZV9pZCIsInZlcmlmeU90cCIsInVuZGVmaW5lZCIsIkVycm9yIiwidHlwZSIsInNpZ25JbldpdGhTU08iLCJwcm92aWRlcl9pZCIsInByb3ZpZGVySWQiLCJkb21haW4iLCJyZWRpcmVjdF90byIsInNraXBfaHR0cF9yZWRpcmVjdCIsInJlYXV0aGVudGljYXRlIiwiX3JlYXV0aGVudGljYXRlIiwiX3VzZVNlc3Npb24iLCJyZXN1bHQiLCJzZXNzaW9uRXJyb3IiLCJqd3QiLCJyZXNlbmQiLCJlbmRwb2ludCIsImdldFNlc3Npb24iLCJsYXN0IiwibGVuZ3RoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwdXNoIiwid2FpdE9uIiwiYWxsIiwic3BsaWNlIiwiX19sb2FkU2Vzc2lvbiIsInN0YWNrIiwiY3VycmVudFNlc3Npb24iLCJtYXliZVNlc3Npb24iLCJfaXNWYWxpZFNlc3Npb24iLCJoYXNFeHBpcmVkIiwiZXhwaXJlc19hdCIsIm5vdyIsImlzU2VydmVyIiwic3VwcHJlc3NXYXJuaW5nIiwicHJveHlTZXNzaW9uIiwiUHJveHkiLCJnZXQiLCJ0YXJnZXQiLCJwcm9wIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiX2NhbGxSZWZyZXNoVG9rZW4iLCJyZWZyZXNoX3Rva2VuIiwiZ2V0VXNlciIsIl9nZXRVc2VyIiwidXBkYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJfdXBkYXRlVXNlciIsInNlc3Npb25EYXRhIiwidXNlckVycm9yIiwiX2RlY29kZUpXVCIsInNldFNlc3Npb24iLCJfc2V0U2Vzc2lvbiIsInRpbWVOb3ciLCJleHBpcmVzQXQiLCJwYXlsb2FkIiwiZXhwIiwicmVmcmVzaGVkU2Vzc2lvbiIsInRva2VuX3R5cGUiLCJleHBpcmVzX2luIiwicmVmcmVzaFNlc3Npb24iLCJfcmVmcmVzaFNlc3Npb24iLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yX2NvZGUiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJkZWxldGUiLCJoaXN0b3J5IiwicmVwbGFjZVN0YXRlIiwic3RhdGUiLCJ0b1N0cmluZyIsInByb3ZpZGVyX3Rva2VuIiwicHJvdmlkZXJfcmVmcmVzaF90b2tlbiIsIk1hdGgiLCJyb3VuZCIsImV4cGlyZXNJbiIsInBhcnNlSW50IiwiYWN0dWFsbHlFeHBpcmVzSW4iLCJpc3N1ZWRBdCIsImhhc2giLCJCb29sZWFuIiwiY3VycmVudFN0b3JhZ2VDb250ZW50Iiwic2lnbk91dCIsInNjb3BlIiwiX3NpZ25PdXQiLCJhY2Nlc3NUb2tlbiIsInN0YXR1cyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiY2FsbGJhY2siLCJpZCIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic2V0IiwiX2VtaXRJbml0aWFsU2Vzc2lvbiIsImVyciIsInJlc2V0UGFzc3dvcmRGb3JFbWFpbCIsImdldFVzZXJJZGVudGl0aWVzIiwiaWRlbnRpdGllcyIsImxpbmtJZGVudGl0eSIsIl9nZXRVcmxGb3JQcm92aWRlciIsInVubGlua0lkZW50aXR5IiwiaWRlbnRpdHkiLCJpZGVudGl0eV9pZCIsIl9yZWZyZXNoQWNjZXNzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJkZWJ1Z05hbWUiLCJzdWJzdHJpbmciLCJzdGFydGVkQXQiLCJhdHRlbXB0IiwicG93IiwibmV4dEJhY2tPZmZJbnRlcnZhbCIsImlzVmFsaWRTZXNzaW9uIiwiZXhwaXJlc1dpdGhNYXJnaW4iLCJJbmZpbml0eSIsInByb21pc2UiLCJyZWplY3QiLCJicm9hZGNhc3QiLCJwb3N0TWVzc2FnZSIsImVycm9ycyIsInByb21pc2VzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwibWFwIiwieCIsImkiLCJfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJfc3RhcnRBdXRvUmVmcmVzaCIsIl9zdG9wQXV0b1JlZnJlc2giLCJ0aWNrZXIiLCJzZXRJbnRlcnZhbCIsIl9hdXRvUmVmcmVzaFRva2VuVGljayIsInVucmVmIiwiRGVubyIsInVucmVmVGltZXIiLCJjbGVhckludGVydmFsIiwic3RhcnRBdXRvUmVmcmVzaCIsInN0b3BBdXRvUmVmcmVzaCIsImV4cGlyZXNJblRpY2tzIiwiZmxvb3IiLCJpc0FjcXVpcmVUaW1lb3V0IiwiX29uVmlzaWJpbGl0eUNoYW5nZWQiLCJjYWxsZWRGcm9tSW5pdGlhbGl6ZSIsIm1ldGhvZE5hbWUiLCJkb2N1bWVudCIsInZpc2liaWxpdHlTdGF0ZSIsInVybFBhcmFtcyIsImVuY29kZVVSSUNvbXBvbmVudCIsImZsb3dQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJxdWVyeSIsImpvaW4iLCJmYWN0b3JJZCIsImZyaWVuZGx5X25hbWUiLCJmcmllbmRseU5hbWUiLCJmYWN0b3JfdHlwZSIsImZhY3RvclR5cGUiLCJpc3N1ZXIiLCJ0b3RwIiwicXJfY29kZSIsImNoYWxsZW5nZV9pZCIsImNoYWxsZW5nZUlkIiwiY2hhbGxlbmdlRGF0YSIsImNoYWxsZW5nZUVycm9yIiwiZmFjdG9ycyIsImZpbHRlciIsImZhY3RvciIsImN1cnJlbnRMZXZlbCIsIm5leHRMZXZlbCIsImN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMiLCJhYWwiLCJ2ZXJpZmllZEZhY3RvcnMiLCJhbXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNKO0FBQ0E7QUFDSjtBQUM0QjtBQUN0QztBQUNDO0FBQzhFLENBQzNHLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9pbmRleC5qcz81NTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuaW1wb3J0IEF1dGhBZG1pbkFwaSBmcm9tICcuL0F1dGhBZG1pbkFwaSc7XG5pbXBvcnQgQXV0aENsaWVudCBmcm9tICcuL0F1dGhDbGllbnQnO1xuZXhwb3J0IHsgR29UcnVlQWRtaW5BcGksIEdvVHJ1ZUNsaWVudCwgQXV0aEFkbWluQXBpLCBBdXRoQ2xpZW50IH07XG5leHBvcnQgKiBmcm9tICcuL2xpYi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHsgbmF2aWdhdG9yTG9jaywgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIGludGVybmFscyBhcyBsb2NrSW50ZXJuYWxzLCB9IGZyb20gJy4vbGliL2xvY2tzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkdvVHJ1ZUNsaWVudCIsIkF1dGhBZG1pbkFwaSIsIkF1dGhDbGllbnQiLCJuYXZpZ2F0b3JMb2NrIiwiTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJpbnRlcm5hbHMiLCJsb2NrSW50ZXJuYWxzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFvQztBQUNwQyxrRUFBa0UsR0FDM0QsTUFBTUMsZ0NBQWdDLEtBQUssS0FBSztBQUN2RDt5RkFDeUYsR0FDbEYsTUFBTUMsOEJBQThCLEVBQUU7QUFDN0M7O0NBRUMsR0FDTSxNQUFNQyxtQkFBbUJELDhCQUE4QkQsOEJBQThCO0FBQ3JGLE1BQU1HLGFBQWEsd0JBQXdCO0FBQzNDLE1BQU1DLGNBQWMsc0JBQXNCO0FBQzFDLE1BQU1DLFdBQVcsR0FBRztBQUNwQixNQUFNQyxrQkFBa0I7SUFBRSxpQkFBaUIsQ0FBQyxVQUFVLEVBQUVQLDZDQUFPQSxDQUFDLENBQUM7QUFBQyxFQUFFO0FBQ3BFLE1BQU1RLGtCQUFrQjtJQUMzQkMsYUFBYTtJQUNiQyxnQkFBZ0I7QUFDcEIsRUFBRTtBQUNLLE1BQU1DLDBCQUEwQix5QkFBeUI7QUFDekQsTUFBTUMsZUFBZTtJQUN4QixjQUFjO1FBQ1ZDLFdBQVdDLEtBQUtDLEtBQUssQ0FBQztRQUN0QkMsTUFBTTtJQUNWO0FBQ0osRUFBRSxDQUNGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2YwNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TID0gMzAgKiAxMDAwO1xuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gMztcbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOX01TID0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVM7XG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nO1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJyc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gICAgTUFYX1JFVFJJRVM6IDEwLFxuICAgIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufTtcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICAgJzIwMjQtMDEtMDEnOiB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgICAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyIsIkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCIsIkVYUElSWV9NQVJHSU5fTVMiLCJHT1RSVUVfVVJMIiwiU1RPUkFHRV9LRVkiLCJBVURJRU5DRSIsIkRFRkFVTFRfSEVBREVSUyIsIk5FVFdPUktfRkFJTFVSRSIsIk1BWF9SRVRSSUVTIiwiUkVUUllfSU5URVJWQUwiLCJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsIkFQSV9WRVJTSU9OUyIsInRpbWVzdGFtcCIsIkRhdGUiLCJwYXJzZSIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\nclass AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\nclass AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\nclass AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\nclass CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nclass AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\nclass AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\nclass AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\nclass AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\nclass AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nclass AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPLE1BQU1BLGtCQUFrQkM7SUFDM0JDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTRyxZQUFZQyxLQUFLO0lBQzdCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsbUJBQW1CQTtBQUM3RTtBQUNPLE1BQU1DLHFCQUFxQlY7SUFDOUJFLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRixTQUFTQyxRQUFRQztRQUN2QixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ08sU0FBU00sZUFBZUYsS0FBSztJQUNoQyxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDTyxNQUFNSyx5QkFBeUJaO0lBQ2xDRSxZQUFZQyxPQUFPLEVBQUVVLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNWO1FBQ04sSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNNLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNPLE1BQU1DLHdCQUF3QmQ7SUFDakNFLFlBQVlDLE9BQU8sRUFBRUksSUFBSSxFQUFFSCxNQUFNLEVBQUVDLElBQUksQ0FBRTtRQUNyQyxLQUFLLENBQUNGLFNBQVNDLFFBQVFDO1FBQ3ZCLElBQUksQ0FBQ0UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtJQUNsQjtBQUNKO0FBQ08sTUFBTVcsZ0NBQWdDRDtJQUN6Q1osYUFBYztRQUNWLEtBQUssQ0FBQyx5QkFBeUIsMkJBQTJCLEtBQUtjO0lBQ25FO0FBQ0o7QUFDTyxTQUFTQywwQkFBMEJSLEtBQUs7SUFDM0MsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ08sTUFBTVcsc0NBQXNDSjtJQUMvQ1osYUFBYztRQUNWLEtBQUssQ0FBQyxnQ0FBZ0MsaUNBQWlDLEtBQUtjO0lBQ2hGO0FBQ0o7QUFDTyxNQUFNRyxvQ0FBb0NMO0lBQzdDWixZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQSxTQUFTLCtCQUErQixLQUFLYTtJQUN2RDtBQUNKO0FBQ08sTUFBTUksdUNBQXVDTjtJQUNoRFosWUFBWUMsT0FBTyxFQUFFa0IsVUFBVSxJQUFJLENBQUU7UUFDakMsS0FBSyxDQUFDbEIsU0FBUyxrQ0FBa0MsS0FBS2E7UUFDdEQsSUFBSSxDQUFDSyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNMLE9BQU87WUFDSGYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CaUIsU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDekI7SUFDSjtBQUNKO0FBQ08sU0FBU0UsaUNBQWlDZCxLQUFLO0lBQ2xELE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNPLE1BQU1pQix1Q0FBdUNWO0lBQ2hEWixZQUFZQyxPQUFPLEVBQUVrQixVQUFVLElBQUksQ0FBRTtRQUNqQyxLQUFLLENBQUNsQixTQUFTLGtDQUFrQyxLQUFLYTtRQUN0RCxJQUFJLENBQUNLLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBQyxTQUFTO1FBQ0wsT0FBTztZQUNIZixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmSixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQkMsUUFBUSxJQUFJLENBQUNBLE1BQU07WUFDbkJpQixTQUFTLElBQUksQ0FBQ0EsT0FBTztRQUN6QjtJQUNKO0FBQ0o7QUFDTyxNQUFNSSxnQ0FBZ0NYO0lBQ3pDWixZQUFZQyxPQUFPLEVBQUVDLE1BQU0sQ0FBRTtRQUN6QixLQUFLLENBQUNELFNBQVMsMkJBQTJCQyxRQUFRWTtJQUN0RDtBQUNKO0FBQ08sU0FBU1UsMEJBQTBCakIsS0FBSztJQUMzQyxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7OztDQUlDLEdBQ00sTUFBTW9CLDhCQUE4QmI7SUFDdkNaLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFd0IsT0FBTyxDQUFFO1FBQ2xDLEtBQUssQ0FBQ3pCLFNBQVMseUJBQXlCQyxRQUFRO1FBQ2hELElBQUksQ0FBQ3dCLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUNPLFNBQVNDLHdCQUF3QnBCLEtBQUs7SUFDekMsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hELEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9lcnJvcnMuanM/ZGRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzQXV0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzQXV0aEVycm9yJyBpbiBlcnJvcjtcbn1cbmV4cG9ydCBjbGFzcyBBdXRoQXBpRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEFwaUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aEFwaUVycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoVW5rbm93bkVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aFVua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEN1c3RvbUF1dGhFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gbWlzc2luZyEnLCAnQXV0aFNlc3Npb25NaXNzaW5nRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcic7XG59XG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcic7XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiQXV0aEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJjb2RlIiwiX19pc0F1dGhFcnJvciIsIm5hbWUiLCJpc0F1dGhFcnJvciIsImVycm9yIiwiQXV0aEFwaUVycm9yIiwiaXNBdXRoQXBpRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwib3JpZ2luYWxFcnJvciIsIkN1c3RvbUF1dGhFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwidW5kZWZpbmVkIiwiaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiZGV0YWlscyIsInRvSlNPTiIsImlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiQXV0aFdlYWtQYXNzd29yZEVycm9yIiwicmVhc29ucyIsImlzQXV0aFdlYWtQYXNzd29yZEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = undefined && undefined.__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSUEsU0FBUyxTQUFLLElBQUksU0FBSSxDQUFDQSxNQUFNLElBQUssU0FBVUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hELElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUNvRTtBQUNtQjtBQUM2QztBQUNwSSxNQUFNcUIsbUJBQW1CLENBQUNDLE1BQVFBLElBQUlDLEdBQUcsSUFBSUQsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSUksS0FBSyxJQUFJQyxLQUFLQyxTQUFTLENBQUNOO0FBQ2pILE1BQU1PLHNCQUFzQjtJQUFDO0lBQUs7SUFBSztDQUFJO0FBQ3BDLGVBQWVDLFlBQVlKLEtB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U0FBUzRELHNCQUFzQnBELElBQUk7SUFDdEMsTUFBTSxFQUFFcUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHekQsTUFBTTBELE9BQU8vRixPQUFPcUMsTUFBTTtRQUFDO1FBQWU7UUFBYTtRQUFnQjtRQUFlO0tBQW9CO0lBQzNMLE1BQU0yRCxhQUFhO1FBQ2ZOO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7SUFDQSxNQUFNVixPQUFPL0UsT0FBT3NELE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0gxRCxNQUFNO1lBQ0YyRDtZQUNBWjtRQUNKO1FBQ0F2RCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVNvRSx1QkFBdUI1RCxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzRDLFdBQVc1QyxJQUFJO0lBQ3BCLE9BQU9BLEtBQUs2RCxZQUFZLElBQUk3RCxLQUFLOEQsYUFBYSxJQUFJOUQsS0FBSzhDLFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzPzAyMzAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgQXV0aEFwaUVycm9yLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgQXV0aFdlYWtQYXNzd29yZEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICAgICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YDtcbiAgICB9XG4gICAgY29uc3QgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUbztcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCArIHF1ZXJ5U3RyaW5nLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uLFxuICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0pID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKGRhdGEpIDogeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3I6IG51bGwgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwgT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IF9fcmVzdChkYXRhLCBbXCJhY3Rpb25fbGlua1wiLCBcImVtYWlsX290cFwiLCBcImhhc2hlZF90b2tlblwiLCBcInJlZGlyZWN0X3RvXCIsIFwidmVyaWZpY2F0aW9uX3R5cGVcIl0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGFjdGlvbl9saW5rLFxuICAgICAgICBlbWFpbF9vdHAsXG4gICAgICAgIGhhc2hlZF90b2tlbixcbiAgICAgICAgcmVkaXJlY3RfdG8sXG4gICAgICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICAgIH07XG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJzIiwiZSIsInQiLCJwIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkFQSV9WRVJTSU9OUyIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiZXhwaXJlc0F0IiwibG9va3NMaWtlRmV0Y2hSZXNwb25zZSIsInBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIiwiQXV0aEFwaUVycm9yIiwiQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJBdXRoV2Vha1Bhc3N3b3JkRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwiQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiZXJyIiwibXNnIiwibWVzc2FnZSIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiTkVUV09SS19FUlJPUl9DT0RFUyIsImhhbmRsZUVycm9yIiwiX2EiLCJpbmNsdWRlcyIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwiZXJyb3JDb2RlIiwidW5kZWZpbmVkIiwicmVzcG9uc2VBUElWZXJzaW9uIiwiZ2V0VGltZSIsInRpbWVzdGFtcCIsImNvZGUiLCJlcnJvcl9jb2RlIiwid2Vha19wYXNzd29yZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYXNvbnMiLCJyZWR1Y2UiLCJhIiwiX2dldFJlcXVlc3RQYXJhbXMiLCJtZXRob2QiLCJvcHRpb25zIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiYXNzaWduIiwiX3JlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwibmFtZSIsImp3dCIsInFzIiwicXVlcnkiLCJyZWRpcmVjdFRvIiwicXVlcnlTdHJpbmciLCJrZXlzIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJfaGFuZGxlUmVxdWVzdCIsIm5vUmVzb2x2ZUpzb24iLCJ4Zm9ybSIsInJlcXVlc3RQYXJhbXMiLCJyZXN1bHQiLCJjb25zb2xlIiwib2siLCJfc2Vzc2lvblJlc3BvbnNlIiwic2Vzc2lvbiIsImhhc1Nlc3Npb24iLCJleHBpcmVzX2F0IiwiZXhwaXJlc19pbiIsInVzZXIiLCJfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQiLCJyZXNwb25zZSIsIl91c2VyUmVzcG9uc2UiLCJfc3NvUmVzcG9uc2UiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJhY3Rpb25fbGluayIsImVtYWlsX290cCIsImhhc2hlZF90b2tlbiIsInJlZGlyZWN0X3RvIiwidmVyaWZpY2F0aW9uX3R5cGUiLCJyZXN0IiwicHJvcGVydGllcyIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJhY2Nlc3NfdG9rZW4iLCJyZWZyZXNoX3Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeBase64URL: () => (/* binding */ decodeBase64URL),\n/* harmony export */   decodeJWTPayload: () => (/* binding */ decodeJWTPayload),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   uuid: () => (/* binding */ uuid)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst isBrowser = ()=> false && 0;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\nfunction decodeBase64URL(value) {\n    const key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let base64 = \"\";\n    let chr1, chr2, chr3;\n    let enc1, enc2, enc3, enc4;\n    let i = 0;\n    value = value.replace(\"-\", \"+\").replace(\"_\", \"/\");\n    while(i < value.length){\n        enc1 = key.indexOf(value.charAt(i++));\n        enc2 = key.indexOf(value.charAt(i++));\n        enc3 = key.indexOf(value.charAt(i++));\n        enc4 = key.indexOf(value.charAt(i++));\n        chr1 = enc1 << 2 | enc2 >> 4;\n        chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n        chr3 = (enc3 & 3) << 6 | enc4;\n        base64 = base64 + String.fromCharCode(chr1);\n        if (enc3 != 64 && chr2 != 0) {\n            base64 = base64 + String.fromCharCode(chr2);\n        }\n        if (enc4 != 64 && chr3 != 0) {\n            base64 = base64 + String.fromCharCode(chr3);\n        }\n    }\n    return base64;\n}\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\n// Taken from: https://stackoverflow.com/questions/38552003/how-to-decode-jwt-token-in-javascript-without-using-a-library\nfunction decodeJWTPayload(token) {\n    // Regex checks for base64url format\n    const base64UrlRegex = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i;\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new Error(\"JWT is not valid: not a JWT structure\");\n    }\n    if (!base64UrlRegex.test(parts[1])) {\n        throw new Error(\"JWT is not valid: payload is not in base64url format\");\n    }\n    const base64Url = parts[1];\n    return JSON.parse(decodeBase64URL(base64Url));\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nfunction base64urlencode(str) {\n    return btoa(str).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return base64urlencode(hashed);\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0Q7QUFDL0MsU0FBU0MsVUFBVUMsU0FBUztJQUMvQixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLEtBQUtDLEdBQUcsS0FBSztJQUN4QyxPQUFPSixVQUFVRDtBQUNyQjtBQUNPLFNBQVNNO0lBQ1osT0FBTyx1Q0FBdUNDLE9BQU8sQ0FBQyxTQUFTLFNBQVVDLENBQUM7UUFDdEUsTUFBTUMsSUFBSSxLQUFNQyxNQUFNLEtBQUssS0FBTSxHQUFHQyxJQUFJSCxLQUFLLE1BQU1DLElBQUksSUFBSyxNQUFPO1FBQ25FLE9BQU9FLEVBQUVDLFFBQVEsQ0FBQztJQUN0QjtBQUNKO0FBQ08sTUFBTUMsWUFBWSxJQUFNLE1BQWtCLElBQWUsQ0FBb0IsQ0FBWTtBQUNoRyxNQUFNRSx5QkFBeUI7SUFDM0JDLFFBQVE7SUFDUkMsVUFBVTtBQUNkO0FBQ0E7O0NBRUMsR0FDTSxNQUFNQyx1QkFBdUI7SUFDaEMsSUFBSSxDQUFDTCxhQUFhO1FBQ2QsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLElBQUksT0FBT00sV0FBV0MsWUFBWSxLQUFLLFVBQVU7WUFDN0MsT0FBTztRQUNYO0lBQ0osRUFDQSxPQUFPQyxHQUFHO1FBQ04sOENBQThDO1FBQzlDLE9BQU87SUFDWDtJQUNBLElBQUlOLHVCQUF1QkMsTUFBTSxFQUFFO1FBQy9CLE9BQU9ELHVCQUF1QkUsUUFBUTtJQUMxQztJQUNBLE1BQU1LLFlBQVksQ0FBQyxLQUFLLEVBQUVwQixLQUFLUSxNQUFNLEdBQUcsRUFBRVIsS0FBS1EsTUFBTSxHQUFHLENBQUM7SUFDekQsSUFBSTtRQUNBUyxXQUFXQyxZQUFZLENBQUNHLE9BQU8sQ0FBQ0QsV0FBV0E7UUFDM0NILFdBQVdDLFlBQVksQ0FBQ0ksVUFBVSxDQUFDRjtRQUNuQ1AsdUJBQXVCQyxNQUFNLEdBQUc7UUFDaENELHVCQUF1QkUsUUFBUSxHQUFHO0lBQ3RDLEVBQ0EsT0FBT0ksR0FBRztRQUNOLG1DQUFtQztRQUNuQywrS0FBK0s7UUFDL0tOLHVCQUF1QkMsTUFBTSxHQUFHO1FBQ2hDRCx1QkFBdUJFLFFBQVEsR0FBRztJQUN0QztJQUNBLE9BQU9GLHVCQUF1QkUsUUFBUTtBQUMxQyxFQUFFO0FBQ0Y7O0NBRUMsR0FDTSxTQUFTUSx1QkFBdUJDLElBQUk7SUFDdkMsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLE1BQU1DLE1BQU0sSUFBSUMsSUFBSUg7SUFDcEIsSUFBSUUsSUFBSUUsSUFBSSxJQUFJRixJQUFJRSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUs7UUFDakMsSUFBSTtZQUNBLE1BQU1DLG1CQUFtQixJQUFJQyxnQkFBZ0JKLElBQUlFLElBQUksQ0FBQ0csU0FBUyxDQUFDO1lBQ2hFRixpQkFBaUJHLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztnQkFDN0JULE1BQU0sQ0FBQ1MsSUFBSSxHQUFHRDtZQUNsQjtRQUNKLEVBQ0EsT0FBT2QsR0FBRztRQUNOLDZCQUE2QjtRQUNqQztJQUNKO0lBQ0EseURBQXlEO0lBQ3pETyxJQUFJUyxZQUFZLENBQUNILE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUM3QlQsTUFBTSxDQUFDUyxJQUFJLEdBQUdEO0lBQ2xCO0lBQ0EsT0FBT1I7QUFDWDtBQUNPLE1BQU1XLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUM7SUFDSixJQUFJRCxhQUFhO1FBQ2JDLFNBQVNEO0lBQ2IsT0FDSyxJQUFJLE9BQU9FLFVBQVUsYUFBYTtRQUNuQ0QsU0FBUyxDQUFDLEdBQUdFLE9BQVMsZ0xBQU8sQ0FBd0JDLElBQUksQ0FBQyxDQUFDLEVBQUVDLFNBQVNILE1BQUssRUFBRSxHQUFLQSxVQUFTQztJQUMvRixPQUNLO1FBQ0RGLFNBQVNDO0lBQ2I7SUFDQSxPQUFPLENBQUMsR0FBR0MsT0FBU0YsVUFBVUU7QUFDbEMsRUFBRTtBQUNLLE1BQU1HLHlCQUF5QixDQUFDQztJQUNuQyxPQUFRLE9BQU9BLGtCQUFrQixZQUM3QkEsa0JBQWtCLFFBQ2xCLFlBQVlBLGlCQUNaLFFBQVFBLGlCQUNSLFVBQVVBLGlCQUNWLE9BQU9BLGNBQWNDLElBQUksS0FBSztBQUN0QyxFQUFFO0FBQ0Ysa0JBQWtCO0FBQ1gsTUFBTUMsZUFBZSxPQUFPQyxTQUFTYixLQUFLYztJQUM3QyxNQUFNRCxRQUFRMUIsT0FBTyxDQUFDYSxLQUFLZSxLQUFLQyxTQUFTLENBQUNGO0FBQzlDLEVBQUU7QUFDSyxNQUFNRyxlQUFlLE9BQU9KLFNBQVNiO0lBQ3hDLE1BQU1ELFFBQVEsTUFBTWMsUUFBUUssT0FBTyxDQUFDbEI7SUFDcEMsSUFBSSxDQUFDRCxPQUFPO1FBQ1IsT0FBTztJQUNYO0lBQ0EsSUFBSTtRQUNBLE9BQU9nQixLQUFLSSxLQUFLLENBQUNwQjtJQUN0QixFQUNBLE9BQU9xQixJQUFJO1FBQ1AsT0FBT3JCO0lBQ1g7QUFDSixFQUFFO0FBQ0ssTUFBTXNCLGtCQUFrQixPQUFPUixTQUFTYjtJQUMzQyxNQUFNYSxRQUFRekIsVUFBVSxDQUFDWTtBQUM3QixFQUFFO0FBQ0ssU0FBU3NCLGdCQUFnQnZCLEtBQUs7SUFDakMsTUFBTUMsTUFBTTtJQUNaLElBQUl1QixTQUFTO0lBQ2IsSUFBSUMsTUFBTUMsTUFBTUM7SUFDaEIsSUFBSUMsTUFBTUMsTUFBTUMsTUFBTUM7SUFDdEIsSUFBSUMsSUFBSTtJQUNSaEMsUUFBUUEsTUFBTTVCLE9BQU8sQ0FBQyxLQUFLLEtBQUtBLE9BQU8sQ0FBQyxLQUFLO0lBQzdDLE1BQU80RCxJQUFJaEMsTUFBTWlDLE1BQU0sQ0FBRTtRQUNyQkwsT0FBTzNCLElBQUlpQyxPQUFPLENBQUNsQyxNQUFNbUMsTUFBTSxDQUFDSDtRQUNoQ0gsT0FBTzVCLElBQUlpQyxPQUFPLENBQUNsQyxNQUFNbUMsTUFBTSxDQUFDSDtRQUNoQ0YsT0FBTzdCLElBQUlpQyxPQUFPLENBQUNsQyxNQUFNbUMsTUFBTSxDQUFDSDtRQUNoQ0QsT0FBTzlCLElBQUlpQyxPQUFPLENBQUNsQyxNQUFNbUMsTUFBTSxDQUFDSDtRQUNoQ1AsT0FBTyxRQUFTLElBQU1JLFFBQVE7UUFDOUJILE9BQU8sQ0FBRUcsT0FBTyxFQUFDLEtBQU0sSUFBTUMsUUFBUTtRQUNyQ0gsT0FBTyxDQUFFRyxPQUFPLE1BQU0sSUFBS0M7UUFDM0JQLFNBQVNBLFNBQVNZLE9BQU9DLFlBQVksQ0FBQ1o7UUFDdEMsSUFBSUssUUFBUSxNQUFNSixRQUFRLEdBQUc7WUFDekJGLFNBQVNBLFNBQVNZLE9BQU9DLFlBQVksQ0FBQ1g7UUFDMUM7UUFDQSxJQUFJSyxRQUFRLE1BQU1KLFFBQVEsR0FBRztZQUN6QkgsU0FBU0EsU0FBU1ksT0FBT0MsWUFBWSxDQUFDVjtRQUMxQztJQUNKO0lBQ0EsT0FBT0g7QUFDWDtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNYztJQUNUQyxhQUFjO1FBQ1YsNERBQTREOztRQUU1RCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJRixTQUFTRyxrQkFBa0IsQ0FBQyxDQUFDQyxLQUFLQztZQUNqRCw0REFBNEQ7O1lBRTVELElBQUksQ0FBQ0MsT0FBTyxHQUFHRjtZQUNmLElBQUksQ0FBQ0csTUFBTSxHQUFHRjtRQUNsQjtJQUNKO0FBQ0o7QUFDQUwsU0FBU0csa0JBQWtCLEdBQUdLO0FBQzlCLHlIQUF5SDtBQUNsSCxTQUFTQyxpQkFBaUJDLEtBQUs7SUFDbEMsb0NBQW9DO0lBQ3BDLE1BQU1DLGlCQUFpQjtJQUN2QixNQUFNQyxRQUFRRixNQUFNRyxLQUFLLENBQUM7SUFDMUIsSUFBSUQsTUFBTWpCLE1BQU0sS0FBSyxHQUFHO1FBQ3BCLE1BQU0sSUFBSW1CLE1BQU07SUFDcEI7SUFDQSxJQUFJLENBQUNILGVBQWVJLElBQUksQ0FBQ0gsS0FBSyxDQUFDLEVBQUUsR0FBRztRQUNoQyxNQUFNLElBQUlFLE1BQU07SUFDcEI7SUFDQSxNQUFNRSxZQUFZSixLQUFLLENBQUMsRUFBRTtJQUMxQixPQUFPbEMsS0FBS0ksS0FBSyxDQUFDRyxnQkFBZ0IrQjtBQUN0QztBQUNBOztDQUVDLEdBQ00sZUFBZUMsTUFBTUMsSUFBSTtJQUM1QixPQUFPLE1BQU0sSUFBSVYsUUFBUSxDQUFDVztRQUN0QkMsV0FBVyxJQUFNRCxPQUFPLE9BQU9EO0lBQ25DO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0csVUFBVUMsRUFBRSxFQUFFQyxXQUFXO0lBQ3JDLE1BQU1yQixVQUFVLElBQUlNLFFBQVEsQ0FBQ1csUUFBUVo7UUFDakMsNERBQTREOztRQUUzRDtZQUNHLElBQUssSUFBSWlCLFVBQVUsR0FBR0EsVUFBVUMsVUFBVUQsVUFBVztnQkFDakQsSUFBSTtvQkFDQSxNQUFNdEUsU0FBUyxNQUFNb0UsR0FBR0U7b0JBQ3hCLElBQUksQ0FBQ0QsWUFBWUMsU0FBUyxNQUFNdEUsU0FBUzt3QkFDckNpRSxPQUFPakU7d0JBQ1A7b0JBQ0o7Z0JBQ0osRUFDQSxPQUFPTixHQUFHO29CQUNOLElBQUksQ0FBQzJFLFlBQVlDLFNBQVM1RSxJQUFJO3dCQUMxQjJELE9BQU8zRDt3QkFDUDtvQkFDSjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9zRDtBQUNYO0FBQ0EsU0FBU3dCLFFBQVFDLEdBQUc7SUFDaEIsT0FBTyxDQUFDLE1BQU1BLElBQUl4RixRQUFRLENBQUMsR0FBRSxFQUFHeUYsTUFBTSxDQUFDLENBQUM7QUFDNUM7QUFDQSwwSkFBMEo7QUFDbkosU0FBU0M7SUFDWixNQUFNQyxpQkFBaUI7SUFDdkIsTUFBTUMsUUFBUSxJQUFJQyxZQUFZRjtJQUM5QixJQUFJLE9BQU9HLFdBQVcsYUFBYTtRQUMvQixNQUFNQyxVQUFVO1FBQ2hCLE1BQU1DLGFBQWFELFFBQVF2QyxNQUFNO1FBQ2pDLElBQUl5QyxXQUFXO1FBQ2YsSUFBSyxJQUFJMUMsSUFBSSxHQUFHQSxJQUFJb0MsZ0JBQWdCcEMsSUFBSztZQUNyQzBDLFlBQVlGLFFBQVFyQyxNQUFNLENBQUNwRSxLQUFLNEcsS0FBSyxDQUFDNUcsS0FBS1EsTUFBTSxLQUFLa0c7UUFDMUQ7UUFDQSxPQUFPQztJQUNYO0lBQ0FILE9BQU9LLGVBQWUsQ0FBQ1A7SUFDdkIsT0FBT1EsTUFBTUMsSUFBSSxDQUFDVCxPQUFPTCxTQUFTZSxJQUFJLENBQUM7QUFDM0M7QUFDQSxlQUFlQyxPQUFPQyxZQUFZO0lBQzlCLE1BQU1DLFVBQVUsSUFBSUM7SUFDcEIsTUFBTUMsY0FBY0YsUUFBUUcsTUFBTSxDQUFDSjtJQUNuQyxNQUFNdEYsT0FBTyxNQUFNNEUsT0FBT2UsTUFBTSxDQUFDQyxNQUFNLENBQUMsV0FBV0g7SUFDbkQsTUFBTUksUUFBUSxJQUFJQyxXQUFXOUY7SUFDN0IsT0FBT2tGLE1BQU1DLElBQUksQ0FBQ1UsT0FDYkUsR0FBRyxDQUFDLENBQUNySCxJQUFNK0QsT0FBT0MsWUFBWSxDQUFDaEUsSUFDL0IwRyxJQUFJLENBQUM7QUFDZDtBQUNBLFNBQVNZLGdCQUFnQkMsR0FBRztJQUN4QixPQUFPQyxLQUFLRCxLQUFLeEgsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU8sS0FBS0EsT0FBTyxDQUFDLE9BQU87QUFDNUU7QUFDTyxlQUFlMEgsc0JBQXNCcEIsUUFBUTtJQUNoRCxNQUFNcUIsbUJBQW1CLE9BQU94QixXQUFXLGVBQ3ZDLE9BQU9BLE9BQU9lLE1BQU0sS0FBSyxlQUN6QixPQUFPSCxnQkFBZ0I7SUFDM0IsSUFBSSxDQUFDWSxrQkFBa0I7UUFDbkJDLFFBQVFDLElBQUksQ0FBQztRQUNiLE9BQU92QjtJQUNYO0lBQ0EsTUFBTXdCLFNBQVMsTUFBTWxCLE9BQU9OO0lBQzVCLE9BQU9pQixnQkFBZ0JPO0FBQzNCO0FBQ08sZUFBZUMsMEJBQTBCckYsT0FBTyxFQUFFc0YsVUFBVSxFQUFFQyxxQkFBcUIsS0FBSztJQUMzRixNQUFNQyxlQUFlbkM7SUFDckIsSUFBSW9DLHFCQUFxQkQ7SUFDekIsSUFBSUQsb0JBQW9CO1FBQ3BCRSxzQkFBc0I7SUFDMUI7SUFDQSxNQUFNMUYsYUFBYUMsU0FBUyxDQUFDLEVBQUVzRixXQUFXLGNBQWMsQ0FBQyxFQUFFRztJQUMzRCxNQUFNQyxnQkFBZ0IsTUFBTVYsc0JBQXNCUTtJQUNsRCxNQUFNRyxzQkFBc0JILGlCQUFpQkUsZ0JBQWdCLFVBQVU7SUFDdkUsT0FBTztRQUFDQTtRQUFlQztLQUFvQjtBQUMvQztBQUNBLGdEQUFnRCxHQUNoRCxNQUFNQyxvQkFBb0I7QUFDbkIsU0FBU0Msd0JBQXdCQyxRQUFRO0lBQzVDLE1BQU1DLGFBQWFELFNBQVNFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDcEosK0RBQXVCQTtJQUMvRCxJQUFJLENBQUNrSixZQUFZO1FBQ2IsT0FBTztJQUNYO0lBQ0EsSUFBSSxDQUFDQSxXQUFXRyxLQUFLLENBQUNOLG9CQUFvQjtRQUN0QyxPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsTUFBTU8sT0FBTyxJQUFJaEosS0FBSyxDQUFDLEVBQUU0SSxXQUFXLFlBQVksQ0FBQztRQUNqRCxPQUFPSTtJQUNYLEVBQ0EsT0FBTy9ILEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSixFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcz81YTY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW4pIHtcbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW47XG59XG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gICAgdGVzdGVkOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KTtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgICAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpO1xufTtcbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXksIGRhdGEpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQmFzZTY0VVJMKHZhbHVlKSB7XG4gICAgY29uc3Qga2V5ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICBsZXQgYmFzZTY0ID0gJyc7XG4gICAgbGV0IGNocjEsIGNocjIsIGNocjM7XG4gICAgbGV0IGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLScsICcrJykucmVwbGFjZSgnXycsICcvJyk7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgZW5jMSA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMiA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IGtleS5pbmRleE9mKHZhbHVlLmNoYXJBdChpKyspKTtcbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIxKTtcbiAgICAgICAgaWYgKGVuYzMgIT0gNjQgJiYgY2hyMiAhPSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmM0ICE9IDY0ICYmIGNocjMgIT0gMCkge1xuICAgICAgICAgICAgYmFzZTY0ID0gYmFzZTY0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xufVxuLyoqXG4gKiBBIGRlZmVycmVkIHJlcHJlc2VudHMgc29tZSBhc3luY2hyb25vdXMgd29yayB0aGF0IGlzIG5vdCB5ZXQgZmluaXNoZWQsIHdoaWNoXG4gKiBtYXkgb3IgbWF5IG5vdCBjdWxtaW5hdGUgaW4gYSB2YWx1ZS5cbiAqIFRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9taWtlLW5vcnRoL3R5cGVzL2Jsb2IvbWFzdGVyL3NyYy9hc3luYy50c1xuICovXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXM7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlajtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuRGVmZXJyZWQucHJvbWlzZUNvbnN0cnVjdG9yID0gUHJvbWlzZTtcbi8vIFRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NTUyMDAzL2hvdy10by1kZWNvZGUtand0LXRva2VuLWluLWphdmFzY3JpcHQtd2l0aG91dC11c2luZy1hLWxpYnJhcnlcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVKV1RQYXlsb2FkKHRva2VuKSB7XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgY29uc3QgYmFzZTY0VXJsUmVnZXggPSAvXihbYS16MC05Xy1dezR9KSooJHxbYS16MC05Xy1dezN9PT8kfFthLXowLTlfLV17Mn0oPT0pPyQpJC9pO1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogbm90IGEgSldUIHN0cnVjdHVyZScpO1xuICAgIH1cbiAgICBpZiAoIWJhc2U2NFVybFJlZ2V4LnRlc3QocGFydHNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSldUIGlzIG5vdCB2YWxpZDogcGF5bG9hZCBpcyBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlNjRVcmwgPSBwYXJ0c1sxXTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVCYXNlNjRVUkwoYmFzZTY0VXJsKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbnVsbCBhZnRlciBzb21lIHRpbWUuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChhY2NlcHQpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBhY2NlcHQobnVsbCksIHRpbWUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcHJvdmlkZWQgYXN5bmMgZnVuY3Rpb24gaW50byBhIHJldHJ5YWJsZSBmdW5jdGlvbi4gRWFjaCByZXN1bHRcbiAqIG9yIHRocm93biBlcnJvciBpcyBzZW50IHRvIHRoZSBpc1JldHJ5YWJsZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0dXJuIHRydWVcbiAqIGlmIHRoZSBmdW5jdGlvbiBzaG91bGQgcnVuIGFnYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnlhYmxlKGZuLCBpc1JldHJ5YWJsZSkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1zZW1pXG4gICAgICAgIDtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgSW5maW5pdHk7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cnlhYmxlKGF0dGVtcHQsIG51bGwsIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGRlYzJoZXgoZGVjKSB7XG4gICAgcmV0dXJuICgnMCcgKyBkZWMudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpO1xufVxuLy8gRnVuY3Rpb25zIGJlbG93IHRha2VuIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYzMzA5NDA5L2NyZWF0aW5nLWEtY29kZS12ZXJpZmllci1hbmQtY2hhbGxlbmdlLWZvci1wa2NlLWF1dGgtb24tc3BvdGlmeS1hcGktaW4tcmVhY3Rqc1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUEtDRVZlcmlmaWVyKCkge1xuICAgIGNvbnN0IHZlcmlmaWVyTGVuZ3RoID0gNTY7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkodmVyaWZpZXJMZW5ndGgpO1xuICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBjaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LS5ffic7XG4gICAgICAgIGNvbnN0IGNoYXJTZXRMZW4gPSBjaGFyU2V0Lmxlbmd0aDtcbiAgICAgICAgbGV0IHZlcmlmaWVyID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyaWZpZXJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVyaWZpZXIgKz0gY2hhclNldC5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhclNldExlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2ZXJpZmllcjtcbiAgICB9XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnJheSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXksIGRlYzJoZXgpLmpvaW4oJycpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2hhMjU2KHJhbmRvbVN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkRGF0YSA9IGVuY29kZXIuZW5jb2RlKHJhbmRvbVN0cmluZyk7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgZW5jb2RlZERhdGEpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaGFzaCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgICAgIC5tYXAoKGMpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYykpXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGJhc2U2NHVybGVuY29kZShzdHIpIHtcbiAgICByZXR1cm4gYnRvYShzdHIpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0rJC8sICcnKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UodmVyaWZpZXIpIHtcbiAgICBjb25zdCBoYXNDcnlwdG9TdXBwb3J0ID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgaWYgKCFoYXNDcnlwdG9TdXBwb3J0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2ViQ3J5cHRvIEFQSSBpcyBub3Qgc3VwcG9ydGVkLiBDb2RlIGNoYWxsZW5nZSBtZXRob2Qgd2lsbCBkZWZhdWx0IHRvIHVzZSBwbGFpbiBpbnN0ZWFkIG9mIHNoYTI1Ni4nKTtcbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBhd2FpdCBzaGEyNTYodmVyaWZpZXIpO1xuICAgIHJldHVybiBiYXNlNjR1cmxlbmNvZGUoaGFzaGVkKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHN0b3JhZ2UsIHN0b3JhZ2VLZXksIGlzUGFzc3dvcmRSZWNvdmVyeSA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29kZVZlcmlmaWVyID0gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKTtcbiAgICBsZXQgc3RvcmVkQ29kZVZlcmlmaWVyID0gY29kZVZlcmlmaWVyO1xuICAgIGlmIChpc1Bhc3N3b3JkUmVjb3ZlcnkpIHtcbiAgICAgICAgc3RvcmVkQ29kZVZlcmlmaWVyICs9ICcvUEFTU1dPUkRfUkVDT1ZFUlknO1xuICAgIH1cbiAgICBhd2FpdCBzZXRJdGVtQXN5bmMoc3RvcmFnZSwgYCR7c3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmAsIHN0b3JlZENvZGVWZXJpZmllcik7XG4gICAgY29uc3QgY29kZUNoYWxsZW5nZSA9IGF3YWl0IGdlbmVyYXRlUEtDRUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBjb2RlVmVyaWZpZXIgPT09IGNvZGVDaGFsbGVuZ2UgPyAncGxhaW4nIDogJ3MyNTYnO1xuICAgIHJldHVybiBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF07XG59XG4vKiogUGFyc2VzIHRoZSBBUEkgdmVyc2lvbiB3aGljaCBpcyAyWVlZLU1NLURELiAqL1xuY29uc3QgQVBJX1ZFUlNJT05fUkVHRVggPSAvXjJbMC05XXszfS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXwxWzAtOV18MlswLTldfDNbMC0xXSkkL2k7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXNwb25zZUFQSVZlcnNpb24ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBhcGlWZXJzaW9uID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQVBJX1ZFUlNJT05fSEVBREVSX05BTUUpO1xuICAgIGlmICghYXBpVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFhcGlWZXJzaW9uLm1hdGNoKEFQSV9WRVJTSU9OX1JFR0VYKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGAke2FwaVZlcnNpb259VDAwOjAwOjAwLjBaYCk7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJBUElfVkVSU0lPTl9IRUFERVJfTkFNRSIsImV4cGlyZXNBdCIsImV4cGlyZXNJbiIsInRpbWVOb3ciLCJNYXRoIiwicm91bmQiLCJEYXRlIiwibm93IiwidXVpZCIsInJlcGxhY2UiLCJjIiwiciIsInJhbmRvbSIsInYiLCJ0b1N0cmluZyIsImlzQnJvd3NlciIsImRvY3VtZW50IiwibG9jYWxTdG9yYWdlV3JpdGVUZXN0cyIsInRlc3RlZCIsIndyaXRhYmxlIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJnbG9iYWxUaGlzIiwibG9jYWxTdG9yYWdlIiwiZSIsInJhbmRvbUtleSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwicGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCIsImhyZWYiLCJyZXN1bHQiLCJ1cmwiLCJVUkwiLCJoYXNoIiwiaGFzaFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN1YnN0cmluZyIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInNlYXJjaFBhcmFtcyIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiX2ZldGNoIiwiZmV0Y2giLCJhcmdzIiwidGhlbiIsImRlZmF1bHQiLCJsb29rc0xpa2VGZXRjaFJlc3BvbnNlIiwibWF5YmVSZXNwb25zZSIsImpzb24iLCJzZXRJdGVtQXN5bmMiLCJzdG9yYWdlIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJdGVtQXN5bmMiLCJnZXRJdGVtIiwicGFyc2UiLCJfYSIsInJlbW92ZUl0ZW1Bc3luYyIsImRlY29kZUJhc2U2NFVSTCIsImJhc2U2NCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImVuYzEiLCJlbmMyIiwiZW5jMyIsImVuYzQiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsImNoYXJBdCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlZmVycmVkIiwiY29uc3RydWN0b3IiLCJwcm9taXNlIiwicHJvbWlzZUNvbnN0cnVjdG9yIiwicmVzIiwicmVqIiwicmVzb2x2ZSIsInJlamVjdCIsIlByb21pc2UiLCJkZWNvZGVKV1RQYXlsb2FkIiwidG9rZW4iLCJiYXNlNjRVcmxSZWdleCIsInBhcnRzIiwic3BsaXQiLCJFcnJvciIsInRlc3QiLCJiYXNlNjRVcmwiLCJzbGVlcCIsInRpbWUiLCJhY2NlcHQiLCJzZXRUaW1lb3V0IiwicmV0cnlhYmxlIiwiZm4iLCJpc1JldHJ5YWJsZSIsImF0dGVtcHQiLCJJbmZpbml0eSIsImRlYzJoZXgiLCJkZWMiLCJzdWJzdHIiLCJnZW5lcmF0ZVBLQ0VWZXJpZmllciIsInZlcmlmaWVyTGVuZ3RoIiwiYXJyYXkiLCJVaW50MzJBcnJheSIsImNyeXB0byIsImNoYXJTZXQiLCJjaGFyU2V0TGVuIiwidmVyaWZpZXIiLCJmbG9vciIsImdldFJhbmRvbVZhbHVlcyIsIkFycmF5IiwiZnJvbSIsImpvaW4iLCJzaGEyNTYiLCJyYW5kb21TdHJpbmciLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkRGF0YSIsImVuY29kZSIsInN1YnRsZSIsImRpZ2VzdCIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hcCIsImJhc2U2NHVybGVuY29kZSIsInN0ciIsImJ0b2EiLCJnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UiLCJoYXNDcnlwdG9TdXBwb3J0IiwiY29uc29sZSIsIndhcm4iLCJoYXNoZWQiLCJnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kIiwic3RvcmFnZUtleSIsImlzUGFzc3dvcmRSZWNvdmVyeSIsImNvZGVWZXJpZmllciIsInN0b3JlZENvZGVWZXJpZmllciIsImNvZGVDaGFsbGVuZ2UiLCJjb2RlQ2hhbGxlbmdlTWV0aG9kIiwiQVBJX1ZFUlNJT05fUkVHRVgiLCJwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbiIsInJlc3BvbnNlIiwiYXBpVmVyc2lvbiIsImhlYWRlcnMiLCJnZXQiLCJtYXRjaCIsImRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localStorageAdapter: () => (/* binding */ localStorageAdapter),\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * Provides safe access to the globalThis.localStorage property.\n */ const localStorageAdapter = {\n    getItem: (key)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return null;\n        }\n        return globalThis.localStorage.getItem(key);\n    },\n    setItem: (key, value)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.setItem(key, value);\n    },\n    removeItem: (key)=>{\n        if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {\n            return;\n        }\n        globalThis.localStorage.removeItem(key);\n    }\n};\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlEO0FBQ2pEOztDQUVDLEdBQ00sTUFBTUMsc0JBQXNCO0lBQy9CQyxTQUFTLENBQUNDO1FBQ04sSUFBSSxDQUFDSCw4REFBb0JBLElBQUk7WUFDekIsT0FBTztRQUNYO1FBQ0EsT0FBT0ksV0FBV0MsWUFBWSxDQUFDSCxPQUFPLENBQUNDO0lBQzNDO0lBQ0FHLFNBQVMsQ0FBQ0gsS0FBS0k7UUFDWCxJQUFJLENBQUNQLDhEQUFvQkEsSUFBSTtZQUN6QjtRQUNKO1FBQ0FJLFdBQVdDLFlBQVksQ0FBQ0MsT0FBTyxDQUFDSCxLQUFLSTtJQUN6QztJQUNBQyxZQUFZLENBQUNMO1FBQ1QsSUFBSSxDQUFDSCw4REFBb0JBLElBQUk7WUFDekI7UUFDSjtRQUNBSSxXQUFXQyxZQUFZLENBQUNHLFVBQVUsQ0FBQ0w7SUFDdkM7QUFDSixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sU0FBU00sMEJBQTBCQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxPQUFPO1FBQ0hSLFNBQVMsQ0FBQ0M7WUFDTixPQUFPTyxLQUFLLENBQUNQLElBQUksSUFBSTtRQUN6QjtRQUNBRyxTQUFTLENBQUNILEtBQUtJO1lBQ1hHLEtBQUssQ0FBQ1AsSUFBSSxHQUFHSTtRQUNqQjtRQUNBQyxZQUFZLENBQUNMO1lBQ1QsT0FBT08sS0FBSyxDQUFDUCxJQUFJO1FBQ3JCO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcz8yM2MyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cHBvcnRzTG9jYWxTdG9yYWdlIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlIHByb3BlcnR5LlxuICovXG5leHBvcnQgY29uc3QgbG9jYWxTdG9yYWdlQWRhcHRlciA9IHtcbiAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9LFxuICAgIHNldEl0ZW06IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgIGlmICghc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9LFxufTtcbi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2VBZGFwdGVyIiwiZ2V0SXRlbSIsImtleSIsImdsb2JhbFRoaXMiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwidmFsdWUiLCJyZW1vdmVJdGVtIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsInN0b3JlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUQ7QUFDakQ7O0NBRUMsR0FDTSxNQUFNQyxZQUFZO0lBQ3JCOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFFQyxDQUFBQSxjQUNOSCw4REFBb0JBLE1BQ3BCRyxXQUFXQyxZQUFZLElBQ3ZCRCxXQUFXQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxzQ0FBc0MsTUFBSztBQUNuRixFQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdDQUFnQ0M7SUFDekNDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtBQUNKO0FBQ08sTUFBTUMseUNBQXlDTDtBQUN0RDtBQUNPLE1BQU1NLHVDQUF1Q047QUFDcEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sZUFBZU8sY0FBY0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDeEQsSUFBSWYsVUFBVUMsS0FBSyxFQUFFO1FBQ2pCZSxRQUFRQyxHQUFHLENBQUMsb0RBQW9ESixNQUFNQztJQUMxRTtJQUNBLE1BQU1JLGtCQUFrQixJQUFJaEIsV0FBV2lCLGVBQWU7SUFDdEQsSUFBSUwsaUJBQWlCLEdBQUc7UUFDcEJNLFdBQVc7WUFDUEYsZ0JBQWdCRyxLQUFLO1lBQ3JCLElBQUlyQixVQUFVQyxLQUFLLEVBQUU7Z0JBQ2pCZSxRQUFRQyxHQUFHLENBQUMsd0RBQXdESjtZQUN4RTtRQUNKLEdBQUdDO0lBQ1A7SUFDQSxvRkFBb0Y7SUFDcEYsMEVBQTBFO0lBQzFFLHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsVUFBVTtJQUNWLE9BQU8sTUFBTVEsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUMs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ZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzPzAzODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGRlYnVnOiAhIShnbG9iYWxUaGlzICYmXG4gICAgICAgIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJyksXG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgI2lzQWNxdWlyZVRpbWVvdXR9IHByb3BlcnR5IGluc3RlYWQgb2YgY2hlY2tpbmcgd2l0aCBgaW5zdGFuY2VvZmAuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbmV4cG9ydCBjbGFzcyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYSBnbG9iYWwgZXhjbHVzaXZlIGxvY2sgdXNpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBBUEkuIEl0XG4gKiBpcyBhdmFpbGFibGUgb24gYWxsIGJyb3dzZXJzIHJlbGVhc2VkIGFmdGVyIDIwMjItMDMtMTUgd2l0aCBTYWZhcmkgYmVpbmcgdGhlXG4gKiBsYXN0IG9uZSB0byByZWxlYXNlIHN1cHBvcnQuIElmIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZSwgdGhpcyBmdW5jdGlvbiB3aWxsXG4gKiB0aHJvdy4gTWFrZSBzdXJlIHlvdSBjaGVjayBhdmFpbGFibGlsaXR5IGJlZm9yZSBjb25maWd1cmluZyB7QGxpbmtcbiAqIEdvVHJ1ZUNsaWVudH0uXG4gKlxuICogWW91IGNhbiB0dXJuIG9uIGRlYnVnZ2luZyBieSBzZXR0aW5nIHRoZSBgc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnYFxuICogbG9jYWwgc3RvcmFnZSBpdGVtIHRvIGB0cnVlYC5cbiAqXG4gKiBJbnRlcm5hbHM6XG4gKlxuICogU2luY2UgdGhlIExvY2tNYW5hZ2VyIEFQSSBkb2VzIG5vdCBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMgZm9yIHRoZSBhc3luY1xuICogZnVuY3Rpb24gcGFzc2VkIGluIHRoZSBgcmVxdWVzdGAgbWV0aG9kLCBhIHRyaWNrIGlzIHVzZWQgd2hlcmUgYWNxdWlyaW5nIHRoZVxuICogbG9jayByZWxlYXNlcyBhIHByZXZpb3VzbHkgc3RhcnRlZCBwcm9taXNlIHRvIHJ1biB0aGUgb3BlcmF0aW9uIGluIHRoZSBgZm5gXG4gKiBmdW5jdGlvbi4gVGhlIGxvY2sgd2FpdHMgZm9yIHRoYXQgcHJvbWlzZSB0byBmaW5pc2ggKHdpdGggb3Igd2l0aG91dCBlcnJvciksXG4gKiB3aGlsZSB0aGUgZnVuY3Rpb24gd2lsbCBmaW5hbGx5IHdhaXQgZm9yIHRoZSByZXN1bHQgYW55d2F5LlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGxvY2sgdG8gYmUgYWNxdWlyZWQuXG4gKiBAcGFyYW0gYWNxdWlyZVRpbWVvdXQgSWYgbmVnYXRpdmUsIG5vIHRpbWVvdXQuIElmIDAgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIGxvY2sgY2FuJ3QgYmUgYWNxdWlyZWQgd2l0aG91dCB3YWl0aW5nLiBJZiBwb3NpdGl2ZSwgdGhlIGxvY2sgYWNxdWlyZVxuICogICAgICAgICAgICAgICAgICAgICAgIHdpbGwgdGltZSBvdXQgYWZ0ZXIgc28gbWFueSBtaWxsaXNlY29uZHMuIEFuIGVycm9yIGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYSB0aW1lb3V0IGlmIGl0IGhhcyBgaXNBY3F1aXJlVGltZW91dGAgc2V0IHRvIHRydWUuXG4gKiBAcGFyYW0gZm4gVGhlIG9wZXJhdGlvbiB0byBydW4gb25jZSB0aGUgbG9jayBpcyBhY3F1aXJlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRvckxvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZSBsb2NrJywgbmFtZSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2sgYWNxdWlyZSB0aW1lZCBvdXQnLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgIH1cbiAgICAvLyBNRE4gYXJ0aWNsZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3RcbiAgICAvLyBXcmFwcGluZyBuYXZpZ2F0b3IubG9ja3MucmVxdWVzdCgpIHdpdGggYSBwbGFpbiBQcm9taXNlIGlzIGRvbmUgYXMgc29tZVxuICAgIC8vIGxpYnJhcmllcyBsaWtlIHpvbmUuanMgcGF0Y2ggdGhlIFByb21pc2Ugb2JqZWN0IHRvIHRyYWNrIHRoZSBleGVjdXRpb25cbiAgICAvLyBjb250ZXh0LiBIb3dldmVyLCBpdCBhcHBlYXJzIHRoYXQgbW9zdCBicm93c2VycyB1c2UgYW4gaW50ZXJuYWwgcHJvbWlzZVxuICAgIC8vIGltcGxlbWVudGF0aW9uIHdoZW4gdXNpbmcgdGhlIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgQVBJIGNhdXNpbmcgdGhlbVxuICAgIC8vIHRvIGxvc2UgY29udGV4dCBhbmQgZW1pdCBjb25mdXNpbmcgbG9nIG1lc3NhZ2VzIG9yIGJyZWFrIGNlcnRhaW4gZmVhdHVyZXMuXG4gICAgLy8gVGhpcyB3cmFwcGluZyBpcyBiZWxpZXZlZCB0byBoZWxwIHpvbmUuanMgdHJhY2sgdGhlIGV4ZWN1dGlvbiBjb250ZXh0XG4gICAgLy8gYmV0dGVyLlxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QobmFtZSwgYWNxdWlyZVRpbWVvdXQgPT09IDBcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIGlmQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgbW9kZTogJ2V4Y2x1c2l2ZScsXG4gICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIH0sIGFzeW5jIChsb2NrKSA9PiB7XG4gICAgICAgIGlmIChsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IGFjcXVpcmVkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiByZWxlYXNlZCcsIG5hbWUsIGxvY2submFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFjcXVpcmVUaW1lb3V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogbm90IGltbWVkaWF0ZWx5IGF2YWlsYWJsZScsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVpcmluZyBhbiBleGNsdXNpdmUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIGxvY2sgXCIke25hbWV9XCIgaW1tZWRpYXRlbHkgZmFpbGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnbG9iYWxUaGlzLm5hdmlnYXRvci5sb2Nrcy5xdWVyeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciBzdGF0ZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgJyAgJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IEVycm9yIHdoZW4gcXVlcnlpbmcgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnJvd3NlciBpcyBub3QgZm9sbG93aW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3BlYywgaXRcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHdlIGRpZG4ndCB1c2UgaWZBdmFpbGFibGUuIFNvIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIHByZXRlbmQgdGhlIGxvY2sgaXMgYWNxdWlyZWQgaW4gdGhlIG5hbWUgb2YgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIC8vIGFuZCB1c2VyIGV4cGVyaWVuY2UgYW5kIGp1c3QgcnVuIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IE5hdmlnYXRvciBMb2NrTWFuYWdlciByZXR1cm5lZCBhIG51bGwgbG9jayB3aGVuIHVzaW5nICNyZXF1ZXN0IHdpdGhvdXQgaWZBdmFpbGFibGUgc2V0IHRvIHRydWUsIGl0IGFwcGVhcnMgdGhpcyBicm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIExvY2tNYW5hZ2VyIHNwZWMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0xvY2tNYW5hZ2VyL3JlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKTtcbn1cbmNvbnN0IFBST0NFU1NfTE9DS1MgPSB7fTtcbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB0aGF0IHdvcmtzIG9ubHkgaW4gdGhlIGN1cnJlbnQgcHJvY2Vzcy5cbiAqIFVzZWZ1bCBmb3IgZW52aXJvbm1lbnRzIGxpa2UgUmVhY3QgTmF0aXZlIG9yIG90aGVyIG5vbi1icm93c2VyXG4gKiBzaW5nbGUtcHJvY2VzcyAoaS5lLiBubyBjb25jZXB0IG9mIFwidGFic1wiKSBlbnZpcm9ubWVudHMuXG4gKlxuICogVXNlIHtAbGluayAjbmF2aWdhdG9yTG9ja30gaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gKF9hID0gUFJPQ0VTU19MT0NLU1tuYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgY3VycmVudE9wZXJhdGlvbiA9IFByb21pc2UucmFjZShbXG4gICAgICAgIHByZXZpb3VzT3BlcmF0aW9uLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvciBvZiBwcmV2aW91cyBvcGVyYXRpb24gdGhhdCB3ZSdyZSB3YWl0aW5nIHRvIGZpbmlzaFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pLFxuICAgICAgICBhY3F1aXJlVGltZW91dCA+PSAwXG4gICAgICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoYEFjcXVyaW5nIHByb2Nlc3MgbG9jayB3aXRoIG5hbWUgXCIke25hbWV9XCIgdGltZWQgb3V0YCkpO1xuICAgICAgICAgICAgICAgIH0sIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgXS5maWx0ZXIoKHgpID0+IHgpKVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pXG4gICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gcHJldmlvdXMgb3BlcmF0aW9ucyBmaW5pc2hlZCBhbmQgd2UgZGlkbid0IGdldCBhIHJhY2Ugb24gdGhlIGFjcXVpcmVcbiAgICAgICAgLy8gdGltZW91dCwgc28gdGhlIGN1cnJlbnQgb3BlcmF0aW9uIGNhbiBmaW5hbGx5IHN0YXJ0XG4gICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0pO1xuICAgIFBST0NFU1NfTE9DS1NbbmFtZV0gPSBjdXJyZW50T3BlcmF0aW9uLmNhdGNoKGFzeW5jIChlKSA9PiB7XG4gICAgICAgIGlmIChlICYmIGUuaXNBY3F1aXJlVGltZW91dCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRpbWVkIG91dCwgaXQgZG9lc24ndCBtZWFuIHRoYXQgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAvLyBvcGVyYXRpb24gZmluaXNoZWQsIHNvIHdlIG5lZWQgY29udG51ZSB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2hcbiAgICAgICAgICAgIGF3YWl0IHByZXZpb3VzT3BlcmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgICAvLyBmaW5hbGx5IHdhaXQgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0byBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3aXRoIGFuXG4gICAgLy8gZXJyb3Igb3Igd2l0aCBhbiBhY3F1aXJlIHRpbWVvdXQgZXJyb3JcbiAgICByZXR1cm4gYXdhaXQgY3VycmVudE9wZXJhdGlvbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2tzLmpzLm1hcCJdLCJuYW1lcyI6WyJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsImludGVybmFscyIsImRlYnVnIiwiZ2xvYmFsVGhpcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiaXNBY3F1aXJlVGltZW91dCIsIk5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIiwibmF2aWdhdG9yTG9jayIsIm5hbWUiLCJhY3F1aXJlVGltZW91dCIsImZuIiwiY29uc29sZSIsImxvZyIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsIm5hdmlnYXRvciIsImxvY2tzIiwicmVxdWVzdCIsIm1vZGUiLCJpZkF2YWlsYWJsZSIsInNpZ25hbCIsImxvY2siLCJyZXN1bHQiLCJxdWVyeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwid2FybiIsIlBST0NFU1NfTE9DS1MiLCJwcm9jZXNzTG9jayIsIl9hIiwicHJldmlvdXNPcGVyYXRpb24iLCJjdXJyZW50T3BlcmF0aW9uIiwicmFjZSIsImNhdGNoIiwiXyIsInJlamVjdCIsImZpbHRlciIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQTtJQUNaLElBQUksT0FBT0MsZUFBZSxVQUN0QjtJQUNKLElBQUk7UUFDQUMsT0FBT0MsY0FBYyxDQUFDRCxPQUFPRSxTQUFTLEVBQUUsYUFBYTtZQUNqREMsS0FBSztnQkFDRCxPQUFPLElBQUk7WUFDZjtZQUNBQyxjQUFjO1FBQ2xCO1FBQ0EsMkNBQTJDO1FBQzNDQyxVQUFVTixVQUFVLEdBQUdNO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPTCxPQUFPRSxTQUFTLENBQUNHLFNBQVM7SUFDckMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0IsNkNBQTZDO1lBQzdDQSxLQUFLUixVQUFVLEdBQUdRO1FBQ3RCO0lBQ0o7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzPzYzZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX187XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgICAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbHMuanMubWFwIl0sIm5hbWVzIjpbInBvbHlmaWxsR2xvYmFsVGhpcyIsImdsb2JhbFRoaXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsImdldCIsImNvbmZpZ3VyYWJsZSIsIl9fbWFnaWNfXyIsImUiLCJzZWxmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVSxDQUNWLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanM/MWY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"2.68.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanM/OTc3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdmVyc2lvbiA9ICcyLjY4LjAnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass FunctionsClient {\n    constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */ invoke(functionName, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const { headers, method, body: functionArgs } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                }\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body\n                }).catch((fetchError)=>{\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n        });\n    }\n} //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ3dDO0FBQ2dFO0FBQ2pHLE1BQU1ZO0lBQ1RDLFlBQVlDLEdBQUcsRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxXQUFXLEVBQUVDLFNBQVNOLGtEQUFjQSxDQUFDTyxHQUFH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Q0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxJQUFJO2dCQUNqSSxJQUFJQztnQkFDSixJQUFJSCxpQkFBaUIsb0JBQW9CO29CQUNyQ0csT0FBTyxNQUFNVixTQUFTVyxJQUFJO2dCQUM5QixPQUNLLElBQUlKLGlCQUFpQiw0QkFBNEI7b0JBQ2xERyxPQUFPLE1BQU1WLFNBQVNZLElBQUk7Z0JBQzlCLE9BQ0ssSUFBSUwsaUJBQWlCLHFCQUFxQjtvQkFDM0NHLE9BQU9WO2dCQUNYLE9BQ0ssSUFBSU8saUJBQWlCLHVCQUF1QjtvQkFDN0NHLE9BQU8sTUFBTVYsU0FBU2EsUUFBUTtnQkFDbEMsT0FDSztvQkFDRCxrQkFBa0I7b0JBQ2xCSCxPQUFPLE1BQU1WLFNBQVNjLElBQUk7Z0JBQzlCO2dCQUNBLE9BQU87b0JBQUVKO29CQUFNSyxPQUFPO2dCQUFLO1lBQy9CLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixPQUFPO29CQUFFTCxNQUFNO29CQUFNSztnQkFBTTtZQUMvQjtRQUNKO0lBQ0o7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcz81YzM4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvblJlZ2lvbiwgfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIGN1c3RvbUZldGNoLCByZWdpb24gPSBGdW5jdGlvblJlZ2lvbi5BbnksIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIHRoZSBuZXcgand0IHRva2VuIHNlbnQgaW4gdGhlIGF1dGhvcmlzYXRpb24gaGVhZGVyXG4gICAgICovXG4gICAgc2V0QXV0aCh0b2tlbikge1xuICAgICAgICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGludm9raW5nIHRoZSBGdW5jdGlvbi5cbiAgICAgKi9cbiAgICBpbnZva2UoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWRlcnMsIG1ldGhvZCwgYm9keTogZnVuY3Rpb25BcmdzIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09ICdhbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIF9oZWFkZXJzWyd4LXJlZ2lvbiddID0gcmVnaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMpLCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUeXBlID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY3Rpb25zQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJyZXNvbHZlRmV0Y2giLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uUmVnaW9uIiwiRnVuY3Rpb25zQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiY3VzdG9tRmV0Y2giLCJyZWdpb24iLCJBbnkiLCJmZXRjaCIsInNldEF1dGgiLCJ0b2tlbiIsIkF1dGhvcml6YXRpb24iLCJpbnZva2UiLCJmdW5jdGlvbk5hbWUiLCJvcHRpb25zIiwiX2EiLCJtZXRob2QiLCJib2R5IiwiZnVuY3Rpb25BcmdzIiwiX2hlYWRlcnMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJCbG9iIiwiQXJyYXlCdWZmZXIiLCJGb3JtRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsImFzc2lnbiIsImNhdGNoIiwiZmV0Y2hFcnJvciIsImlzUmVsYXlFcnJvciIsImdldCIsIm9rIiwicmVzcG9uc2VUeXBlIiwic3BsaXQiLCJ0cmltIiwiZGF0YSIsImpzb24iLCJibG9iIiwiZm9ybURhdGEiLCJ0ZXh0IiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n}; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUM7SUFDSixJQUFJRCxhQUFhO1FBQ2JDLFNBQVNEO0lBQ2IsT0FDSyxJQUFJLE9BQU9FLFVBQVUsYUFBYTtRQUNuQ0QsU0FBUyxDQUFDLEdBQUdFLE9BQVMsZ0xBQU8sQ0FBd0JDLElBQUksQ0FBQyxDQUFDLEVBQUVDLFNBQVNILE1BQUssRUFBRSxHQUFLQSxVQUFTQztJQUMvRixPQUNLO1FBQ0RGLFNBQVNDO0lBQ2I7SUFDQSxPQUFPLENBQUMsR0FBR0MsT0FBU0YsVUFBVUU7QUFDbEMsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcz9iNjk1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiXSwibmFtZXMiOlsicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJfZmV0Y2giLCJmZXRjaCIsImFyZ3MiLCJ0aGVuIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\nclass FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\nclass FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\nclass FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\nclass FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPLE1BQU1BLHVCQUF1QkM7SUFDaENDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTyxnQkFBZ0IsRUFBRUMsT0FBTyxDQUFFO1FBQ25ELEtBQUssQ0FBQ0Y7UUFDTixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUNPLE1BQU1DLDRCQUE0Qk47SUFDckNFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsaURBQWlELHVCQUF1QkE7SUFDbEY7QUFDSjtBQUNPLE1BQU1FLDRCQUE0QlA7SUFDckNFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsMENBQTBDLHVCQUF1QkE7SUFDM0U7QUFDSjtBQUNPLE1BQU1HLDJCQUEyQlI7SUFDcENFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsZ0RBQWdELHNCQUFzQkE7SUFDaEY7QUFDSjtBQUNBLDRDQUE0QztBQUNyQyxJQUFJSSxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxNQUFNLEdBQUc7SUFDeEJBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxXQUFXLEdBQUc7SUFDN0JBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxhQUFhLEdBQUc7SUFDL0JBLGNBQWMsQ0FBQyxhQUFhLEdBQUc7SUFDL0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7QUFDaEMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQyxLQUN4QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcz82ODhlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lID0gJ0Z1bmN0aW9uc0Vycm9yJywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRmV0Y2hFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIERlZmluZSB0aGUgZW51bSBmb3IgdGhlICdyZWdpb24nIHByb3BlcnR5XG5leHBvcnQgdmFyIEZ1bmN0aW9uUmVnaW9uO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlZ2lvbikge1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQW55XCJdID0gXCJhbnlcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MVwiXSA9IFwiYXAtbm9ydGhlYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MlwiXSA9IFwiYXAtbm9ydGhlYXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGgxXCJdID0gXCJhcC1zb3V0aC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDFcIl0gPSBcImFwLXNvdXRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDJcIl0gPSBcImFwLXNvdXRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJDYUNlbnRyYWwxXCJdID0gXCJjYS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1Q2VudHJhbDFcIl0gPSBcImV1LWNlbnRyYWwtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MVwiXSA9IFwiZXUtd2VzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QyXCJdID0gXCJldS13ZXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDNcIl0gPSBcImV1LXdlc3QtM1wiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiU2FFYXN0MVwiXSA9IFwic2EtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc0Vhc3QxXCJdID0gXCJ1cy1lYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDFcIl0gPSBcInVzLXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNXZXN0MlwiXSA9IFwidXMtd2VzdC0yXCI7XG59KShGdW5jdGlvblJlZ2lvbiB8fCAoRnVuY3Rpb25SZWdpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIkZ1bmN0aW9uc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY29udGV4dCIsIkZ1bmN0aW9uc0ZldGNoRXJyb3IiLCJGdW5jdGlvbnNSZWxheUVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25SZWdpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/node-fetch/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@supabase/node-fetch/lib/index.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar Stream = _interopDefault(__webpack_require__(/*! stream */ \"stream\"));\nvar http = _interopDefault(__webpack_require__(/*! http */ \"http\"));\nvar Url = _interopDefault(__webpack_require__(/*! url */ \"url\"));\nvar whatwgUrl = _interopDefault(__webpack_require__(/*! whatwg-url */ \"(ssr)/./node_modules/whatwg-url/lib/public-api.js\"));\nvar https = _interopDefault(__webpack_require__(/*! https */ \"https\"));\nvar zlib = _interopDefault(__webpack_require__(/*! zlib */ \"zlib\"));\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\nconst BUFFER = Symbol(\"buffer\");\nconst TYPE = Symbol(\"type\");\nclass Blob {\n    constructor(){\n        this[TYPE] = \"\";\n        const blobParts = arguments[0];\n        const options = arguments[1];\n        const buffers = [];\n        let size = 0;\n        if (blobParts) {\n            const a = blobParts;\n            const length = Number(a.length);\n            for(let i = 0; i < length; i++){\n                const element = a[i];\n                let buffer;\n                if (element instanceof Buffer) {\n                    buffer = element;\n                } else if (ArrayBuffer.isView(element)) {\n                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n                } else if (element instanceof ArrayBuffer) {\n                    buffer = Buffer.from(element);\n                } else if (element instanceof Blob) {\n                    buffer = element[BUFFER];\n                } else {\n                    buffer = Buffer.from(typeof element === \"string\" ? element : String(element));\n                }\n                size += buffer.length;\n                buffers.push(buffer);\n            }\n        }\n        this[BUFFER] = Buffer.concat(buffers);\n        let type = options && options.type !== undefined && String(options.type).toLowerCase();\n        if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n            this[TYPE] = type;\n        }\n    }\n    get size() {\n        return this[BUFFER].length;\n    }\n    get type() {\n        return this[TYPE];\n    }\n    text() {\n        return Promise.resolve(this[BUFFER].toString());\n    }\n    arrayBuffer() {\n        const buf = this[BUFFER];\n        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        return Promise.resolve(ab);\n    }\n    stream() {\n        const readable = new Readable();\n        readable._read = function() {};\n        readable.push(this[BUFFER]);\n        readable.push(null);\n        return readable;\n    }\n    toString() {\n        return \"[object Blob]\";\n    }\n    slice() {\n        const size = this.size;\n        const start = arguments[0];\n        const end = arguments[1];\n        let relativeStart, relativeEnd;\n        if (start === undefined) {\n            relativeStart = 0;\n        } else if (start < 0) {\n            relativeStart = Math.max(size + start, 0);\n        } else {\n            relativeStart = Math.min(start, size);\n        }\n        if (end === undefined) {\n            relativeEnd = size;\n        } else if (end < 0) {\n            relativeEnd = Math.max(size + end, 0);\n        } else {\n            relativeEnd = Math.min(end, size);\n        }\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const buffer = this[BUFFER];\n        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n        const blob = new Blob([], {\n            type: arguments[2]\n        });\n        blob[BUFFER] = slicedBuffer;\n        return blob;\n    }\n}\nObject.defineProperties(Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n    value: \"Blob\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */ /**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */ function FetchError(message, type, systemError) {\n    Error.call(this, message);\n    this.message = message;\n    this.type = type;\n    // when err.type is `system`, err.code contains system error code\n    if (systemError) {\n        this.code = this.errno = systemError.code;\n    }\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = \"FetchError\";\nlet convert;\nconst INTERNALS = Symbol(\"Body internals\");\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ function Body(body) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;\n    let size = _ref$size === undefined ? 0 : _ref$size;\n    var _ref$timeout = _ref.timeout;\n    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n    if (body == null) {\n        // body is undefined or null\n        body = null;\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        body = Buffer.from(body.toString());\n    } else if (isBlob(body)) ;\n    else if (Buffer.isBuffer(body)) ;\n    else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) ;\n    else {\n        // none of the above\n        // coerce to string then buffer\n        body = Buffer.from(String(body));\n    }\n    this[INTERNALS] = {\n        body,\n        disturbed: false,\n        error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (body instanceof Stream) {\n        body.on(\"error\", function(err) {\n            const error = err.name === \"AbortError\" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, \"system\", err);\n            _this[INTERNALS].error = error;\n        });\n    }\n}\nBody.prototype = {\n    get body () {\n        return this[INTERNALS].body;\n    },\n    get bodyUsed () {\n        return this[INTERNALS].disturbed;\n    },\n    /**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */ arrayBuffer () {\n        return consumeBody.call(this).then(function(buf) {\n            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        });\n    },\n    /**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */ blob () {\n        let ct = this.headers && this.headers.get(\"content-type\") || \"\";\n        return consumeBody.call(this).then(function(buf) {\n            return Object.assign(// Prevent copying\n            new Blob([], {\n                type: ct.toLowerCase()\n            }), {\n                [BUFFER]: buf\n            });\n        });\n    },\n    /**\n  * Decode response as json\n  *\n  * @return  Promise\n  */ json () {\n        var _this2 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            try {\n                return JSON.parse(buffer.toString());\n            } catch (err) {\n                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, \"invalid-json\"));\n            }\n        });\n    },\n    /**\n  * Decode response as text\n  *\n  * @return  Promise\n  */ text () {\n        return consumeBody.call(this).then(function(buffer) {\n            return buffer.toString();\n        });\n    },\n    /**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */ buffer () {\n        return consumeBody.call(this);\n    },\n    /**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */ textConverted () {\n        var _this3 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            return convertBody(buffer, _this3.headers);\n        });\n    }\n};\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    }\n});\nBody.mixIn = function(proto) {\n    for (const name of Object.getOwnPropertyNames(Body.prototype)){\n        // istanbul ignore else: future proof\n        if (!(name in proto)) {\n            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n            Object.defineProperty(proto, name, desc);\n        }\n    }\n};\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */ function consumeBody() {\n    var _this4 = this;\n    if (this[INTERNALS].disturbed) {\n        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) {\n        return Body.Promise.reject(this[INTERNALS].error);\n    }\n    let body = this.body;\n    // body is null\n    if (body === null) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is blob\n    if (isBlob(body)) {\n        body = body.stream();\n    }\n    // body is buffer\n    if (Buffer.isBuffer(body)) {\n        return Body.Promise.resolve(body);\n    }\n    // istanbul ignore if: should never happen\n    if (!(body instanceof Stream)) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is stream\n    // get ready to actually consume the body\n    let accum = [];\n    let accumBytes = 0;\n    let abort = false;\n    return new Body.Promise(function(resolve, reject) {\n        let resTimeout;\n        // allow timeout on slow response body\n        if (_this4.timeout) {\n            resTimeout = setTimeout(function() {\n                abort = true;\n                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, \"body-timeout\"));\n            }, _this4.timeout);\n        }\n        // handle stream errors\n        body.on(\"error\", function(err) {\n            if (err.name === \"AbortError\") {\n                // if the request was aborted, reject with this Error\n                abort = true;\n                reject(err);\n            } else {\n                // other errors, such as incorrect content-encoding\n                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n        body.on(\"data\", function(chunk) {\n            if (abort || chunk === null) {\n                return;\n            }\n            if (_this4.size && accumBytes + chunk.length > _this4.size) {\n                abort = true;\n                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, \"max-size\"));\n                return;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        });\n        body.on(\"end\", function() {\n            if (abort) {\n                return;\n            }\n            clearTimeout(resTimeout);\n            try {\n                resolve(Buffer.concat(accum, accumBytes));\n            } catch (err) {\n                // handle streams that have accumulated too much data (issue #414)\n                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n    });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */ function convertBody(buffer, headers) {\n    {\n        throw new Error(\"The package `encoding` must be installed to use the textConverted() function\");\n    }\n    const ct = headers.get(\"content-type\");\n    let charset = \"utf-8\";\n    let res, str;\n    // header\n    if (ct) {\n        res = /charset=([^;]*)/i.exec(ct);\n    }\n    // no charset in content type, peek at response body for at most 1024 bytes\n    str = buffer.slice(0, 1024).toString();\n    // html5\n    if (!res && str) {\n        res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // html4\n    if (!res && str) {\n        res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n        if (!res) {\n            res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n            if (res) {\n                res.pop(); // drop last quote\n            }\n        }\n        if (res) {\n            res = /charset=(.*)/i.exec(res.pop());\n        }\n    }\n    // xml\n    if (!res && str) {\n        res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // found charset\n    if (res) {\n        charset = res.pop();\n        // prevent decode issues when sites use incorrect encoding\n        // ref: https://hsivonen.fi/encoding-menu/\n        if (charset === \"gb2312\" || charset === \"gbk\") {\n            charset = \"gb18030\";\n        }\n    }\n    // turn raw buffers into a single utf-8 buffer\n    return convert(buffer, \"UTF-8\", charset).toString();\n}\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */ function isURLSearchParams(obj) {\n    // Duck-typing as a necessary condition.\n    if (typeof obj !== \"object\" || typeof obj.append !== \"function\" || typeof obj.delete !== \"function\" || typeof obj.get !== \"function\" || typeof obj.getAll !== \"function\" || typeof obj.has !== \"function\" || typeof obj.set !== \"function\") {\n        return false;\n    }\n    // Brand-checking and more duck-typing as optional condition.\n    return obj.constructor.name === \"URLSearchParams\" || Object.prototype.toString.call(obj) === \"[object URLSearchParams]\" || typeof obj.sort === \"function\";\n}\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */ function isBlob(obj) {\n    return typeof obj === \"object\" && typeof obj.arrayBuffer === \"function\" && typeof obj.type === \"string\" && typeof obj.stream === \"function\" && typeof obj.constructor === \"function\" && typeof obj.constructor.name === \"string\" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */ function clone(instance) {\n    let p1, p2;\n    let body = instance.body;\n    // don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // tee instance body\n        p1 = new PassThrough();\n        p2 = new PassThrough();\n        body.pipe(p1);\n        body.pipe(p2);\n        // set instance body to teed body and return the other teed body\n        instance[INTERNALS].body = p1;\n        body = p2;\n    }\n    return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */ function extractContentType(body) {\n    if (body === null) {\n        // body is null\n        return null;\n    } else if (typeof body === \"string\") {\n        // body is string\n        return \"text/plain;charset=UTF-8\";\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isBlob(body)) {\n        // body is blob\n        return body.type || null;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return null;\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        return null;\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        return null;\n    } else if (typeof body.getBoundary === \"function\") {\n        // detect form data input from form-data module\n        return `multipart/form-data;boundary=${body.getBoundary()}`;\n    } else if (body instanceof Stream) {\n        // body is stream\n        // can't really do much about this\n        return null;\n    } else {\n        // Body constructor defaults other things to string\n        return \"text/plain;charset=UTF-8\";\n    }\n}\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */ function getTotalBytes(instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        return 0;\n    } else if (isBlob(body)) {\n        return body.size;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return body.length;\n    } else if (body && typeof body.getLengthSync === \"function\") {\n        // detect form data input from form-data module\n        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) {\n            // 2.x\n            return body.getLengthSync();\n        }\n        return null;\n    } else {\n        // body is stream\n        return null;\n    }\n}\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */ function writeToStream(dest, instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        dest.end();\n    } else if (isBlob(body)) {\n        body.stream().pipe(dest);\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        dest.write(body);\n        dest.end();\n    } else {\n        // body is stream\n        body.pipe(dest);\n    }\n}\n// expose Promise\nBody.Promise = global.Promise;\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */ const invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction validateName(name) {\n    name = `${name}`;\n    if (invalidTokenRegex.test(name) || name === \"\") {\n        throw new TypeError(`${name} is not a legal HTTP header name`);\n    }\n}\nfunction validateValue(value) {\n    value = `${value}`;\n    if (invalidHeaderCharRegex.test(value)) {\n        throw new TypeError(`${value} is not a legal HTTP header value`);\n    }\n}\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */ function find(map, name) {\n    name = name.toLowerCase();\n    for(const key in map){\n        if (key.toLowerCase() === name) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst MAP = Symbol(\"map\");\nclass Headers {\n    /**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */ constructor(){\n        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        this[MAP] = Object.create(null);\n        if (init instanceof Headers) {\n            const rawHeaders = init.raw();\n            const headerNames = Object.keys(rawHeaders);\n            for (const headerName of headerNames){\n                for (const value of rawHeaders[headerName]){\n                    this.append(headerName, value);\n                }\n            }\n            return;\n        }\n        // We don't worry about converting prop to ByteString here as append()\n        // will handle it.\n        if (init == null) ;\n        else if (typeof init === \"object\") {\n            const method = init[Symbol.iterator];\n            if (method != null) {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                const pairs = [];\n                for (const pair of init){\n                    if (typeof pair !== \"object\" || typeof pair[Symbol.iterator] !== \"function\") {\n                        throw new TypeError(\"Each header pair must be iterable\");\n                    }\n                    pairs.push(Array.from(pair));\n                }\n                for (const pair of pairs){\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    this.append(pair[0], pair[1]);\n                }\n            } else {\n                // record<ByteString, ByteString>\n                for (const key of Object.keys(init)){\n                    const value = init[key];\n                    this.append(key, value);\n                }\n            }\n        } else {\n            throw new TypeError(\"Provided initializer must be an object\");\n        }\n    }\n    /**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */ get(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key === undefined) {\n            return null;\n        }\n        return this[MAP][key].join(\", \");\n    }\n    /**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */ forEach(callback) {\n        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        let pairs = getHeaders(this);\n        let i = 0;\n        while(i < pairs.length){\n            var _pairs$i = pairs[i];\n            const name = _pairs$i[0], value = _pairs$i[1];\n            callback.call(thisArg, value, name, this);\n            pairs = getHeaders(this);\n            i++;\n        }\n    }\n    /**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ set(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        this[MAP][key !== undefined ? key : name] = [\n            value\n        ];\n    }\n    /**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ append(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            this[MAP][key].push(value);\n        } else {\n            this[MAP][name] = [\n                value\n            ];\n        }\n    }\n    /**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */ has(name) {\n        name = `${name}`;\n        validateName(name);\n        return find(this[MAP], name) !== undefined;\n    }\n    /**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */ delete(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            delete this[MAP][key];\n        }\n    }\n    /**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */ raw() {\n        return this[MAP];\n    }\n    /**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */ keys() {\n        return createHeadersIterator(this, \"key\");\n    }\n    /**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */ values() {\n        return createHeadersIterator(this, \"value\");\n    }\n    /**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */ [Symbol.iterator]() {\n        return createHeadersIterator(this, \"key+value\");\n    }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n    value: \"Headers\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Headers.prototype, {\n    get: {\n        enumerable: true\n    },\n    forEach: {\n        enumerable: true\n    },\n    set: {\n        enumerable: true\n    },\n    append: {\n        enumerable: true\n    },\n    has: {\n        enumerable: true\n    },\n    delete: {\n        enumerable: true\n    },\n    keys: {\n        enumerable: true\n    },\n    values: {\n        enumerable: true\n    },\n    entries: {\n        enumerable: true\n    }\n});\nfunction getHeaders(headers) {\n    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"key+value\";\n    const keys = Object.keys(headers[MAP]).sort();\n    return keys.map(kind === \"key\" ? function(k) {\n        return k.toLowerCase();\n    } : kind === \"value\" ? function(k) {\n        return headers[MAP][k].join(\", \");\n    } : function(k) {\n        return [\n            k.toLowerCase(),\n            headers[MAP][k].join(\", \")\n        ];\n    });\n}\nconst INTERNAL = Symbol(\"internal\");\nfunction createHeadersIterator(target, kind) {\n    const iterator = Object.create(HeadersIteratorPrototype);\n    iterator[INTERNAL] = {\n        target,\n        kind,\n        index: 0\n    };\n    return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n    next () {\n        // istanbul ignore if\n        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n            throw new TypeError(\"Value of `this` is not a HeadersIterator\");\n        }\n        var _INTERNAL = this[INTERNAL];\n        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;\n        const values = getHeaders(target, kind);\n        const len = values.length;\n        if (index >= len) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this[INTERNAL].index = index + 1;\n        return {\n            value: values[index],\n            done: false\n        };\n    }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n    value: \"HeadersIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */ function exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign({\n        __proto__: null\n    }, headers[MAP]);\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], \"Host\");\n    if (hostHeaderKey !== undefined) {\n        obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    }\n    return obj;\n}\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */ function createHeadersLenient(obj) {\n    const headers = new Headers();\n    for (const name of Object.keys(obj)){\n        if (invalidTokenRegex.test(name)) {\n            continue;\n        }\n        if (Array.isArray(obj[name])) {\n            for (const val of obj[name]){\n                if (invalidHeaderCharRegex.test(val)) {\n                    continue;\n                }\n                if (headers[MAP][name] === undefined) {\n                    headers[MAP][name] = [\n                        val\n                    ];\n                } else {\n                    headers[MAP][name].push(val);\n                }\n            }\n        } else if (!invalidHeaderCharRegex.test(obj[name])) {\n            headers[MAP][name] = [\n                obj[name]\n            ];\n        }\n    }\n    return headers;\n}\nconst INTERNALS$1 = Symbol(\"Response internals\");\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response {\n    constructor(){\n        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Body.call(this, body, opts);\n        const status = opts.status || 200;\n        const headers = new Headers(opts.headers);\n        if (body != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            url: opts.url,\n            status,\n            statusText: opts.statusText || STATUS_CODES[status],\n            headers,\n            counter: opts.counter\n        };\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n  * Convenience property representing if the request ended normally\n  */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    /**\n  * Clone this response\n  *\n  * @return  Response\n  */ clone() {\n        return new Response(clone(this), {\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected\n        });\n    }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperties(Response.prototype, {\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n    value: \"Response\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nconst INTERNALS$2 = Symbol(\"Request internals\");\nconst URL = Url.URL || whatwgUrl.URL;\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */ function parseURL(urlStr) {\n    /*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */ if (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n        urlStr = new URL(urlStr).toString();\n    }\n    // Fallback to old implementation for arbitrary URLs\n    return parse_url(urlStr);\n}\nconst streamDestructionSupported = \"destroy\" in Stream.Readable.prototype;\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */ function isRequest(input) {\n    return typeof input === \"object\" && typeof input[INTERNALS$2] === \"object\";\n}\nfunction isAbortSignal(signal) {\n    const proto = signal && typeof signal === \"object\" && Object.getPrototypeOf(signal);\n    return !!(proto && proto.constructor.name === \"AbortSignal\");\n}\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request {\n    constructor(input){\n        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let parsedURL;\n        // normalize input\n        if (!isRequest(input)) {\n            if (input && input.href) {\n                // in order to support Node.js' Url objects; though WHATWG's URL objects\n                // will fall into this branch also (since their `toString()` will return\n                // `href` property anyway)\n                parsedURL = parseURL(input.href);\n            } else {\n                // coerce input to a string before attempting to parse\n                parsedURL = parseURL(`${input}`);\n            }\n            input = {};\n        } else {\n            parsedURL = parseURL(input.url);\n        }\n        let method = init.method || input.method || \"GET\";\n        method = method.toUpperCase();\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        Body.call(this, inputBody, {\n            timeout: init.timeout || input.timeout || 0,\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) signal = init.signal;\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal\");\n        }\n        this[INTERNALS$2] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal\n        };\n        // node-fetch-only options\n        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n    }\n    get method() {\n        return this[INTERNALS$2].method;\n    }\n    get url() {\n        return format_url(this[INTERNALS$2].parsedURL);\n    }\n    get headers() {\n        return this[INTERNALS$2].headers;\n    }\n    get redirect() {\n        return this[INTERNALS$2].redirect;\n    }\n    get signal() {\n        return this[INTERNALS$2].signal;\n    }\n    /**\n  * Clone this request\n  *\n  * @return  Request\n  */ clone() {\n        return new Request(this);\n    }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n    value: \"Request\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */ function getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS$2].parsedURL;\n    const headers = new Headers(request[INTERNALS$2].headers);\n    // fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname) {\n        throw new TypeError(\"Only absolute URLs are supported\");\n    }\n    if (!/^https?:$/.test(parsedURL.protocol)) {\n        throw new TypeError(\"Only HTTP(S) protocols are supported\");\n    }\n    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n        throw new Error(\"Cancellation of streamed requests with AbortSignal is not supported in node < 8\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body != null) {\n        const totalBytes = getTotalBytes(request);\n        if (typeof totalBytes === \"number\") {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n    let agent = request.agent;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    if (!headers.has(\"Connection\") && !agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    return Object.assign({}, parsedURL, {\n        method: request.method,\n        headers: exportNodeCompatibleHeaders(headers),\n        agent\n    });\n}\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */ /**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */ function AbortError(message) {\n    Error.call(this, message);\n    this.type = \"aborted\";\n    this.message = message;\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = \"AbortError\";\nconst URL$1 = Url.URL || whatwgUrl.URL;\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n    const orig = new URL$1(original).hostname;\n    const dest = new URL$1(destination).hostname;\n    return orig === dest || orig[orig.length - dest.length - 1] === \".\" && orig.endsWith(dest);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = function isSameProtocol(destination, original) {\n    const orig = new URL$1(original).protocol;\n    const dest = new URL$1(destination).protocol;\n    return orig === dest;\n};\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */ function fetch(url, opts) {\n    // allow custom promise\n    if (!fetch.Promise) {\n        throw new Error(\"native promise missing, set fetch.Promise to your favorite alternative\");\n    }\n    Body.Promise = fetch.Promise;\n    // wrap http.request into fetch\n    return new fetch.Promise(function(resolve, reject) {\n        // build request object\n        const request = new Request(url, opts);\n        const options = getNodeRequestOptions(request);\n        const send = (options.protocol === \"https:\" ? https : http).request;\n        const signal = request.signal;\n        let response = null;\n        const abort = function abort() {\n            let error = new AbortError(\"The user aborted a request.\");\n            reject(error);\n            if (request.body && request.body instanceof Stream.Readable) {\n                destroyStream(request.body, error);\n            }\n            if (!response || !response.body) return;\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = function abortAndFinalize() {\n            abort();\n            finalize();\n        };\n        // send request\n        const req = send(options);\n        let reqTimeout;\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        function finalize() {\n            req.abort();\n            if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            clearTimeout(reqTimeout);\n        }\n        if (request.timeout) {\n            req.once(\"socket\", function(socket) {\n                reqTimeout = setTimeout(function() {\n                    reject(new FetchError(`network timeout at: ${request.url}`, \"request-timeout\"));\n                    finalize();\n                }, request.timeout);\n            });\n        }\n        req.on(\"error\", function(err) {\n            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, \"system\", err));\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(req, function(err) {\n            if (signal && signal.aborted) {\n                return;\n            }\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n        });\n        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            req.on(\"socket\", function(s) {\n                s.addListener(\"close\", function(hadError) {\n                    // if a data listener is still present we didn't end cleanly\n                    const hasDataListener = s.listenerCount(\"data\") > 0;\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n                        const err = new Error(\"Premature close\");\n                        err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", err);\n                    }\n                });\n            });\n        }\n        req.on(\"response\", function(res) {\n            clearTimeout(reqTimeout);\n            const headers = createHeadersLenient(res.headers);\n            // HTTP fetch step 5\n            if (fetch.isRedirect(res.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL$1(location, request.url).toString();\n                } catch (err) {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n                        if (locationURL !== null) {\n                            // handle corrupted header\n                            try {\n                                headers.set(\"Location\", locationURL);\n                            } catch (err) {\n                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n                                reject(err);\n                            }\n                        }\n                        break;\n                    case \"follow\":\n                        // HTTP-redirect fetch step 2\n                        if (locationURL === null) {\n                            break;\n                        }\n                        // HTTP-redirect fetch step 5\n                        if (request.counter >= request.follow) {\n                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 6 (counter increment)\n                        // Create a new Request object.\n                        const requestOpts = {\n                            headers: new Headers(request.headers),\n                            follow: request.follow,\n                            counter: request.counter + 1,\n                            agent: request.agent,\n                            compress: request.compress,\n                            method: request.method,\n                            body: request.body,\n                            signal: request.signal,\n                            timeout: request.timeout,\n                            size: request.size\n                        };\n                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                            for (const name of [\n                                \"authorization\",\n                                \"www-authenticate\",\n                                \"cookie\",\n                                \"cookie2\"\n                            ]){\n                                requestOpts.headers.delete(name);\n                            }\n                        }\n                        // HTTP-redirect fetch step 9\n                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n                            reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 11\n                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === \"POST\") {\n                            requestOpts.method = \"GET\";\n                            requestOpts.body = undefined;\n                            requestOpts.headers.delete(\"content-length\");\n                        }\n                        // HTTP-redirect fetch step 15\n                        resolve(fetch(new Request(locationURL, requestOpts)));\n                        finalize();\n                        return;\n                }\n            }\n            // prepare response\n            res.once(\"end\", function() {\n                if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            });\n            let body = res.pipe(new PassThrough$1());\n            const response_options = {\n                url: request.url,\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: headers,\n                size: request.size,\n                timeout: request.timeout,\n                counter: request.counter\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // for gzip\n            if (codings == \"gzip\" || codings == \"x-gzip\") {\n                body = body.pipe(zlib.createGunzip(zlibOptions));\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // for deflate\n            if (codings == \"deflate\" || codings == \"x-deflate\") {\n                // handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = res.pipe(new PassThrough$1());\n                raw.once(\"data\", function(chunk) {\n                    // see http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = body.pipe(zlib.createInflate());\n                    } else {\n                        body = body.pipe(zlib.createInflateRaw());\n                    }\n                    response = new Response(body, response_options);\n                    resolve(response);\n                });\n                raw.on(\"end\", function() {\n                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n                    if (!response) {\n                        response = new Response(body, response_options);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // for br\n            if (codings == \"br\" && typeof zlib.createBrotliDecompress === \"function\") {\n                body = body.pipe(zlib.createBrotliDecompress());\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // otherwise, use response as-is\n            response = new Response(body, response_options);\n            resolve(response);\n        });\n        writeToStream(req, request);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    let socket;\n    request.on(\"socket\", function(s) {\n        socket = s;\n    });\n    request.on(\"response\", function(response) {\n        const headers = response.headers;\n        if (headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"]) {\n            response.once(\"close\", function(hadError) {\n                // tests for socket presence, as in some situations the\n                // the 'socket' event is not triggered for the request\n                // (happens in deno), avoids `TypeError`\n                // if a data listener is still present we didn't end cleanly\n                const hasDataListener = socket && socket.listenerCount(\"data\") > 0;\n                if (hasDataListener && !hadError) {\n                    const err = new Error(\"Premature close\");\n                    err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                    errorCallback(err);\n                }\n            });\n        }\n    });\n}\nfunction destroyStream(stream, err) {\n    if (stream.destroy) {\n        stream.destroy(err);\n    } else {\n        // node < 8\n        stream.emit(\"error\", err);\n        stream.end();\n    }\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */ fetch.isRedirect = function(code) {\n    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n// expose Promise\nfetch.Promise = global.Promise;\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL25vZGUtZmV0Y2gvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLGdCQUFpQkMsRUFBRTtJQUFJLE9BQU8sTUFBUSxPQUFPQSxPQUFPLFlBQWEsYUFBYUEsS0FBTUEsRUFBRSxDQUFDLFVBQVUsR0FBR0E7QUFBSTtBQUVqSCxJQUFJQyxTQUFTRixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3JDLElBQUlDLE9BQU9KLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDbkMsSUFBSUUsTUFBTUwsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUNsQyxJQUFJRyxZQUFZTixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3hDLElBQUlJLFFBQVFQLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDcEMsSUFBSUssT0FBT1IsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUVuQyxrSEFBa0g7QUFFbEgsZ0RBQWdEO0FBQ2hELE1BQU1NLFdBQVdQLE9BQU9PLFFBQVE7QUFFaEMsTUFBTUMsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCLE1BQU1FO0lBQ0xDLGFBQWM7UUFDYixJQUFJLENBQUNGLEtBQUssR0FBRztRQUViLE1BQU1HLFlBQVlDLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLE1BQU1DLFVBQVVELFNBQVMsQ0FBQyxFQUFFO1FBRTVCLE1BQU1FLFVBQVUsRUFBRTtRQUNsQixJQUFJQyxPQUFPO1FBRVgsSUFBSUosV0FBVztZQUNkLE1BQU1LLElBQUlMO1lBQ1YsTUFBTU0sU0FBU0MsT0FBT0YsRUFBRUMsTUFBTTtZQUM5QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsSUFBSztnQkFDaEMsTUFBTUMsVUFBVUosQ0FBQyxDQUFDRyxFQUFFO2dCQUNwQixJQUFJRTtnQkFDSixJQUFJRCxtQkFBbUJFLFFBQVE7b0JBQzlC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Q2pGO0FBRUEsaUJBQWlCO0FBQ2pCNkssTUFBTTVNLE9BQU8sR0FBRzhHLE9BQU85RyxPQUFPO0FBRTlCc1AsT0FBT2hTLE9BQU8sR0FBR0EsVUFBVXNQO0FBQzNCeFAsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFlLEdBQUdBO0FBQ2xCQSxlQUFlLEdBQUdpSztBQUNsQmpLLGVBQWUsR0FBRzhOO0FBQ2xCOU4sZ0JBQWdCLEdBQUcwTTtBQUNuQjFNLGtCQUFrQixHQUFHb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL25vZGUtZmV0Y2gvbGliL2luZGV4LmpzP2VlMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFN0cmVhbSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdzdHJlYW0nKSk7XG52YXIgaHR0cCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdodHRwJykpO1xudmFyIFVybCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd1cmwnKSk7XG52YXIgd2hhdHdnVXJsID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3doYXR3Zy11cmwnKSk7XG52YXIgaHR0cHMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaHR0cHMnKSk7XG52YXIgemxpYiA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd6bGliJykpO1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG1wdmFyL2pzZG9tL2Jsb2IvYWE4NWIyYWJmMDc3NjZmZjdiZjVjMWY2ZGFhZmIzNzI2ZjJmMmRiNS9saWIvanNkb20vbGl2aW5nL2Jsb2IuanNcblxuLy8gZml4IGZvciBcIlJlYWRhYmxlXCIgaXNuJ3QgYSBuYW1lZCBleHBvcnQgaXNzdWVcbmNvbnN0IFJlYWRhYmxlID0gU3RyZWFtLlJlYWRhYmxlO1xuXG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuXG5jbGFzcyBCbG9iIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpc1tUWVBFXSA9ICcnO1xuXG5cdFx0Y29uc3QgYmxvYlBhcnRzID0gYXJndW1lbnRzWzBdO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG5cblx0XHRjb25zdCBidWZmZXJzID0gW107XG5cdFx0bGV0IHNpemUgPSAwO1xuXG5cdFx0aWYgKGJsb2JQYXJ0cykge1xuXHRcdFx0Y29uc3QgYSA9IGJsb2JQYXJ0cztcblx0XHRcdGNvbnN0IGxlbmd0aCA9IE51bWJlcihhLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBhW2ldO1xuXHRcdFx0XHRsZXQgYnVmZmVyO1xuXHRcdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IGVsZW1lbnQ7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20oZWxlbWVudC5idWZmZXIsIGVsZW1lbnQuYnl0ZU9mZnNldCwgZWxlbWVudC5ieXRlTGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbShlbGVtZW50KTtcblx0XHRcdFx0fSBlbHNlIGlmIChlbGVtZW50IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IGVsZW1lbnRbQlVGRkVSXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbSh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgPyBlbGVtZW50IDogU3RyaW5nKGVsZW1lbnQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzaXplICs9IGJ1ZmZlci5sZW5ndGg7XG5cdFx0XHRcdGJ1ZmZlcnMucHVzaChidWZmZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG5cblx0XHRsZXQgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKG9wdGlvbnMudHlwZSkudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodHlwZSAmJiAhL1teXFx1MDAyMC1cXHUwMDdFXS8udGVzdCh0eXBlKSkge1xuXHRcdFx0dGhpc1tUWVBFXSA9IHR5cGU7XG5cdFx0fVxuXHR9XG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzW0JVRkZFUl0ubGVuZ3RoO1xuXHR9XG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzW1RZUEVdO1xuXHR9XG5cdHRleHQoKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzW0JVRkZFUl0udG9TdHJpbmcoKSk7XG5cdH1cblx0YXJyYXlCdWZmZXIoKSB7XG5cdFx0Y29uc3QgYnVmID0gdGhpc1tCVUZGRVJdO1xuXHRcdGNvbnN0IGFiID0gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShhYik7XG5cdH1cblx0c3RyZWFtKCkge1xuXHRcdGNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlKCk7XG5cdFx0cmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRyZWFkYWJsZS5wdXNoKHRoaXNbQlVGRkVSXSk7XG5cdFx0cmVhZGFibGUucHVzaChudWxsKTtcblx0XHRyZXR1cm4gcmVhZGFibGU7XG5cdH1cblx0dG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuICdbb2JqZWN0IEJsb2JdJztcblx0fVxuXHRzbGljZSgpIHtcblx0XHRjb25zdCBzaXplID0gdGhpcy5zaXplO1xuXG5cdFx0Y29uc3Qgc3RhcnQgPSBhcmd1bWVudHNbMF07XG5cdFx0Y29uc3QgZW5kID0gYXJndW1lbnRzWzFdO1xuXHRcdGxldCByZWxhdGl2ZVN0YXJ0LCByZWxhdGl2ZUVuZDtcblx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVsYXRpdmVTdGFydCA9IDA7XG5cdFx0fSBlbHNlIGlmIChzdGFydCA8IDApIHtcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSBNYXRoLm1heChzaXplICsgc3RhcnQsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIHNpemUpO1xuXHRcdH1cblx0XHRpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gc2l6ZTtcblx0XHR9IGVsc2UgaWYgKGVuZCA8IDApIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gTWF0aC5tYXgoc2l6ZSArIGVuZCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbGF0aXZlRW5kID0gTWF0aC5taW4oZW5kLCBzaXplKTtcblx0XHR9XG5cdFx0Y29uc3Qgc3BhbiA9IE1hdGgubWF4KHJlbGF0aXZlRW5kIC0gcmVsYXRpdmVTdGFydCwgMCk7XG5cblx0XHRjb25zdCBidWZmZXIgPSB0aGlzW0JVRkZFUl07XG5cdFx0Y29uc3Qgc2xpY2VkQnVmZmVyID0gYnVmZmVyLnNsaWNlKHJlbGF0aXZlU3RhcnQsIHJlbGF0aXZlU3RhcnQgKyBzcGFuKTtcblx0XHRjb25zdCBibG9iID0gbmV3IEJsb2IoW10sIHsgdHlwZTogYXJndW1lbnRzWzJdIH0pO1xuXHRcdGJsb2JbQlVGRkVSXSA9IHNsaWNlZEJ1ZmZlcjtcblx0XHRyZXR1cm4gYmxvYjtcblx0fVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCbG9iLnByb3RvdHlwZSwge1xuXHRzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dHlwZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHNsaWNlOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9iLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnQmxvYicsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogZmV0Y2gtZXJyb3IuanNcbiAqXG4gKiBGZXRjaEVycm9yIGludGVyZmFjZSBmb3Igb3BlcmF0aW9uYWwgZXJyb3JzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgRmV0Y2hFcnJvciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIG1lc3NhZ2UgICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuICogQHBhcmFtICAgU3RyaW5nICAgICAgdHlwZSAgICAgICAgIEVycm9yIHR5cGUgZm9yIG1hY2hpbmVcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIHN5c3RlbUVycm9yICBGb3IgTm9kZS5qcyBzeXN0ZW0gZXJyb3JcbiAqIEByZXR1cm4gIEZldGNoRXJyb3JcbiAqL1xuZnVuY3Rpb24gRmV0Y2hFcnJvcihtZXNzYWdlLCB0eXBlLCBzeXN0ZW1FcnJvcikge1xuICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgLy8gd2hlbiBlcnIudHlwZSBpcyBgc3lzdGVtYCwgZXJyLmNvZGUgY29udGFpbnMgc3lzdGVtIGVycm9yIGNvZGVcbiAgaWYgKHN5c3RlbUVycm9yKSB7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5lcnJubyA9IHN5c3RlbUVycm9yLmNvZGU7XG4gIH1cblxuICAvLyBoaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xufVxuXG5GZXRjaEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkZldGNoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmV0Y2hFcnJvcjtcbkZldGNoRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRmV0Y2hFcnJvcic7XG5cbmxldCBjb252ZXJ0O1xuXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ0JvZHkgaW50ZXJuYWxzJyk7XG5cbi8vIGZpeCBhbiBpc3N1ZSB3aGVyZSBcIlBhc3NUaHJvdWdoXCIgaXNuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBQYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcblxuLyoqXG4gKiBCb2R5IG1peGluXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keVxuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZnVuY3Rpb24gQm9keShib2R5KSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0dmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXHQgICAgX3JlZiRzaXplID0gX3JlZi5zaXplO1xuXG5cdGxldCBzaXplID0gX3JlZiRzaXplID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzaXplO1xuXHR2YXIgX3JlZiR0aW1lb3V0ID0gX3JlZi50aW1lb3V0O1xuXHRsZXQgdGltZW91dCA9IF9yZWYkdGltZW91dCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdGltZW91dDtcblxuXHRpZiAoYm9keSA9PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdGJvZHkgPSBudWxsO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkgOyBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIDsgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcblx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyVmlld1xuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIDsgZWxzZSB7XG5cdFx0Ly8gbm9uZSBvZiB0aGUgYWJvdmVcblx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSk7XG5cdH1cblx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdGJvZHksXG5cdFx0ZGlzdHVyYmVkOiBmYWxzZSxcblx0XHRlcnJvcjogbnVsbFxuXHR9O1xuXHR0aGlzLnNpemUgPSBzaXplO1xuXHR0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuXG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0Ym9keS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicgPyBlcnIgOiBuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzLnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycik7XG5cdFx0XHRfdGhpc1tJTlRFUk5BTFNdLmVycm9yID0gZXJyb3I7XG5cdFx0fSk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUgPSB7XG5cdGdldCBib2R5KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uYm9keTtcblx0fSxcblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGFycmF5QnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxuICAqXG4gICogQHJldHVybiBQcm9taXNlXG4gICovXG5cdGJsb2IoKSB7XG5cdFx0bGV0IGN0ID0gdGhpcy5oZWFkZXJzICYmIHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oXG5cdFx0XHQvLyBQcmV2ZW50IGNvcHlpbmdcblx0XHRcdG5ldyBCbG9iKFtdLCB7XG5cdFx0XHRcdHR5cGU6IGN0LnRvTG93ZXJDYXNlKClcblx0XHRcdH0pLCB7XG5cdFx0XHRcdFtCVUZGRVJdOiBidWZcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBqc29uXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGpzb24oKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRyZXR1cm4gY29uc3VtZUJvZHkuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlamVjdChuZXcgRmV0Y2hFcnJvcihgaW52YWxpZCBqc29uIHJlc3BvbnNlIGJvZHkgYXQgJHtfdGhpczIudXJsfSByZWFzb246ICR7ZXJyLm1lc3NhZ2V9YCwgJ2ludmFsaWQtanNvbicpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0KCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBidWZmZXIgKG5vbi1zcGVjIGFwaSlcbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0YnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0LCB3aGlsZSBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZW5jb2RpbmcgYW5kXG4gICogdHJ5aW5nIHRvIGRlY29kZSB0byBVVEYtOCAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0Q29udmVydGVkKCkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRyZXR1cm4gY29udmVydEJvZHkoYnVmZmVyLCBfdGhpczMuaGVhZGVycyk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vIEluIGJyb3dzZXJzLCBhbGwgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvZHkucHJvdG90eXBlLCB7XG5cdGJvZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRib2R5VXNlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGFycmF5QnVmZmVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YmxvYjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGpzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR0ZXh0OiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbkJvZHkubWl4SW4gPSBmdW5jdGlvbiAocHJvdG8pIHtcblx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEJvZHkucHJvdG90eXBlKSkge1xuXHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBmdXR1cmUgcHJvb2Zcblx0XHRpZiAoIShuYW1lIGluIHByb3RvKSkge1xuXHRcdFx0Y29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQm9keS5wcm90b3R5cGUsIG5hbWUpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCBkZXNjKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQ29uc3VtZSBhbmQgY29udmVydCBhbiBlbnRpcmUgQm9keSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKlxuICogQHJldHVybiAgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb25zdW1lQm9keSgpIHtcblx0dmFyIF90aGlzNCA9IHRoaXM7XG5cblx0aWYgKHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKGBib2R5IHVzZWQgYWxyZWFkeSBmb3I6ICR7dGhpcy51cmx9YCkpO1xuXHR9XG5cblx0dGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZCA9IHRydWU7XG5cblx0aWYgKHRoaXNbSU5URVJOQUxTXS5lcnJvcikge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KHRoaXNbSU5URVJOQUxTXS5lcnJvcik7XG5cdH1cblxuXHRsZXQgYm9keSA9IHRoaXMuYm9keTtcblxuXHQvLyBib2R5IGlzIG51bGxcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmFsbG9jKDApKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgYmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0Ym9keSA9IGJvZHkuc3RyZWFtKCk7XG5cdH1cblxuXHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKGJvZHkpO1xuXHR9XG5cblx0Ly8gaXN0YW5idWwgaWdub3JlIGlmOiBzaG91bGQgbmV2ZXIgaGFwcGVuXG5cdGlmICghKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKEJ1ZmZlci5hbGxvYygwKSk7XG5cdH1cblxuXHQvLyBib2R5IGlzIHN0cmVhbVxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxuXHRsZXQgYWNjdW0gPSBbXTtcblx0bGV0IGFjY3VtQnl0ZXMgPSAwO1xuXHRsZXQgYWJvcnQgPSBmYWxzZTtcblxuXHRyZXR1cm4gbmV3IEJvZHkuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0bGV0IHJlc1RpbWVvdXQ7XG5cblx0XHQvLyBhbGxvdyB0aW1lb3V0IG9uIHNsb3cgcmVzcG9uc2UgYm9keVxuXHRcdGlmIChfdGhpczQudGltZW91dCkge1xuXHRcdFx0cmVzVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRhYm9ydCA9IHRydWU7XG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgUmVzcG9uc2UgdGltZW91dCB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfSAob3ZlciAke190aGlzNC50aW1lb3V0fW1zKWAsICdib2R5LXRpbWVvdXQnKSk7XG5cdFx0XHR9LCBfdGhpczQudGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIHN0cmVhbSBlcnJvcnNcblx0XHRib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG5cdFx0XHRcdC8vIGlmIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkLCByZWplY3Qgd2l0aCB0aGlzIEVycm9yXG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBvdGhlciBlcnJvcnMsIHN1Y2ggYXMgaW5jb3JyZWN0IGNvbnRlbnQtZW5jb2Rpbmdcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXM0LnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ym9keS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0aWYgKGFib3J0IHx8IGNodW5rID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF90aGlzNC5zaXplICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBfdGhpczQuc2l6ZSkge1xuXHRcdFx0XHRhYm9ydCA9IHRydWU7XG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7X3RoaXM0LnVybH0gb3ZlciBsaW1pdDogJHtfdGhpczQuc2l6ZX1gLCAnbWF4LXNpemUnKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9KTtcblxuXHRcdGJvZHkub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChhYm9ydCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNsZWFyVGltZW91dChyZXNUaW1lb3V0KTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZShCdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHN0cmVhbXMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRvbyBtdWNoIGRhdGEgKGlzc3VlICM0MTQpXG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIgZnJvbSByZXNwb25zZSBib2R5IGZvciAke190aGlzNC51cmx9OiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGJ1ZmZlciBlbmNvZGluZyBhbmQgY29udmVydCB0byB0YXJnZXQgZW5jb2RpbmdcbiAqIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDExMy9wYXJzaW5nLmh0bWwjZGV0ZXJtaW5pbmctdGhlLWNoYXJhY3Rlci1lbmNvZGluZ1xuICpcbiAqIEBwYXJhbSAgIEJ1ZmZlciAgYnVmZmVyICAgIEluY29taW5nIGJ1ZmZlclxuICogQHBhcmFtICAgU3RyaW5nICBlbmNvZGluZyAgVGFyZ2V0IGVuY29kaW5nXG4gKiBAcmV0dXJuICBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gY29udmVydEJvZHkoYnVmZmVyLCBoZWFkZXJzKSB7XG5cdHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYWNrYWdlIGBlbmNvZGluZ2AgbXVzdCBiZSBpbnN0YWxsZWQgdG8gdXNlIHRoZSB0ZXh0Q29udmVydGVkKCkgZnVuY3Rpb24nKTtcblx0fVxuXG5cdGNvbnN0IGN0ID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXHRsZXQgY2hhcnNldCA9ICd1dGYtOCc7XG5cdGxldCByZXMsIHN0cjtcblxuXHQvLyBoZWFkZXJcblx0aWYgKGN0KSB7XG5cdFx0cmVzID0gL2NoYXJzZXQ9KFteO10qKS9pLmV4ZWMoY3QpO1xuXHR9XG5cblx0Ly8gbm8gY2hhcnNldCBpbiBjb250ZW50IHR5cGUsIHBlZWsgYXQgcmVzcG9uc2UgYm9keSBmb3IgYXQgbW9zdCAxMDI0IGJ5dGVzXG5cdHN0ciA9IGJ1ZmZlci5zbGljZSgwLCAxMDI0KS50b1N0cmluZygpO1xuXG5cdC8vIGh0bWw1XG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88bWV0YS4rP2NoYXJzZXQ9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xuXHR9XG5cblx0Ly8gaHRtbDRcblx0aWYgKCFyZXMgJiYgc3RyKSB7XG5cdFx0cmVzID0gLzxtZXRhW1xcc10rP2h0dHAtZXF1aXY9KFsnXCJdKWNvbnRlbnQtdHlwZVxcMVtcXHNdKz9jb250ZW50PShbJ1wiXSkoLis/KVxcMi9pLmV4ZWMoc3RyKTtcblx0XHRpZiAoIXJlcykge1xuXHRcdFx0cmVzID0gLzxtZXRhW1xcc10rP2NvbnRlbnQ9KFsnXCJdKSguKz8pXFwxW1xcc10rP2h0dHAtZXF1aXY9KFsnXCJdKWNvbnRlbnQtdHlwZVxcMy9pLmV4ZWMoc3RyKTtcblx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0cmVzLnBvcCgpOyAvLyBkcm9wIGxhc3QgcXVvdGVcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocmVzKSB7XG5cdFx0XHRyZXMgPSAvY2hhcnNldD0oLiopL2kuZXhlYyhyZXMucG9wKCkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIHhtbFxuXHRpZiAoIXJlcyAmJiBzdHIpIHtcblx0XHRyZXMgPSAvPFxcP3htbC4rP2VuY29kaW5nPShbJ1wiXSkoLis/KVxcMS9pLmV4ZWMoc3RyKTtcblx0fVxuXG5cdC8vIGZvdW5kIGNoYXJzZXRcblx0aWYgKHJlcykge1xuXHRcdGNoYXJzZXQgPSByZXMucG9wKCk7XG5cblx0XHQvLyBwcmV2ZW50IGRlY29kZSBpc3N1ZXMgd2hlbiBzaXRlcyB1c2UgaW5jb3JyZWN0IGVuY29kaW5nXG5cdFx0Ly8gcmVmOiBodHRwczovL2hzaXZvbmVuLmZpL2VuY29kaW5nLW1lbnUvXG5cdFx0aWYgKGNoYXJzZXQgPT09ICdnYjIzMTInIHx8IGNoYXJzZXQgPT09ICdnYmsnKSB7XG5cdFx0XHRjaGFyc2V0ID0gJ2diMTgwMzAnO1xuXHRcdH1cblx0fVxuXG5cdC8vIHR1cm4gcmF3IGJ1ZmZlcnMgaW50byBhIHNpbmdsZSB1dGYtOCBidWZmZXJcblx0cmV0dXJuIGNvbnZlcnQoYnVmZmVyLCAnVVRGLTgnLCBjaGFyc2V0KS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIERldGVjdCBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoL2lzc3Vlcy8yOTYjaXNzdWVjb21tZW50LTMwNzU5ODE0M1xuICpcbiAqIEBwYXJhbSAgIE9iamVjdCAgb2JqICAgICBPYmplY3QgdG8gZGV0ZWN0IGJ5IHR5cGUgb3IgYnJhbmRcbiAqIEByZXR1cm4gIFN0cmluZ1xuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyhvYmopIHtcblx0Ly8gRHVjay10eXBpbmcgYXMgYSBuZWNlc3NhcnkgY29uZGl0aW9uLlxuXHRpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iai5hcHBlbmQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5kZWxldGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5nZXRBbGwgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5oYXMgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iai5zZXQgIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBCcmFuZC1jaGVja2luZyBhbmQgbW9yZSBkdWNrLXR5cGluZyBhcyBvcHRpb25hbCBjb25kaXRpb24uXG5cdHJldHVybiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ1VSTFNlYXJjaFBhcmFtcycgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFVSTFNlYXJjaFBhcmFtc10nIHx8IHR5cGVvZiBvYmouc29ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIFczQyBgQmxvYmAgb2JqZWN0ICh3aGljaCBgRmlsZWAgaW5oZXJpdHMgZnJvbSlcbiAqIEBwYXJhbSAgeyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNCbG9iKG9iaikge1xuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iai5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBvYmouc3RyZWFtID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnc3RyaW5nJyAmJiAvXihCbG9ifEZpbGUpJC8udGVzdChvYmouY29uc3RydWN0b3IubmFtZSkgJiYgL14oQmxvYnxGaWxlKSQvLnRlc3Qob2JqW1N5bWJvbC50b1N0cmluZ1RhZ10pO1xufVxuXG4vKipcbiAqIENsb25lIGJvZHkgZ2l2ZW4gUmVzL1JlcSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIE1peGVkICBpbnN0YW5jZSAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHJldHVybiAgTWl4ZWRcbiAqL1xuZnVuY3Rpb24gY2xvbmUoaW5zdGFuY2UpIHtcblx0bGV0IHAxLCBwMjtcblx0bGV0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cdC8vIGRvbid0IGFsbG93IGNsb25pbmcgYSB1c2VkIGJvZHlcblx0aWYgKGluc3RhbmNlLmJvZHlVc2VkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2xvbmUgYm9keSBhZnRlciBpdCBpcyB1c2VkJyk7XG5cdH1cblxuXHQvLyBjaGVjayB0aGF0IGJvZHkgaXMgYSBzdHJlYW0gYW5kIG5vdCBmb3JtLWRhdGEgb2JqZWN0XG5cdC8vIG5vdGU6IHdlIGNhbid0IGNsb25lIHRoZSBmb3JtLWRhdGEgb2JqZWN0IHdpdGhvdXQgaGF2aW5nIGl0IGFzIGEgZGVwZW5kZW5jeVxuXHRpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSAmJiB0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIHRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgUGFzc1Rocm91Z2goKTtcblx0XHRwMiA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXHRcdGJvZHkucGlwZShwMSk7XG5cdFx0Ym9keS5waXBlKHAyKTtcblx0XHQvLyBzZXQgaW5zdGFuY2UgYm9keSB0byB0ZWVkIGJvZHkgYW5kIHJldHVybiB0aGUgb3RoZXIgdGVlZCBib2R5XG5cdFx0aW5zdGFuY2VbSU5URVJOQUxTXS5ib2R5ID0gcDE7XG5cdFx0Ym9keSA9IHAyO1xuXHR9XG5cblx0cmV0dXJuIGJvZHk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG9wZXJhdGlvbiBcImV4dHJhY3QgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tIHxvYmplY3R8XCIgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpbnN0YW5jZS5ib2R5IGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgIGluc3RhbmNlICBBbnkgb3B0aW9ucy5ib2R5IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50VHlwZShib2R5KSB7XG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyBudWxsXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJpbmdcblx0XHRyZXR1cm4gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdFx0cmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCc7XG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBibG9iXG5cdFx0cmV0dXJuIGJvZHkudHlwZSB8fCBudWxsO1xuXHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGJvZHkuZ2V0Qm91bmRhcnkgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBkZXRlY3QgZm9ybSBkYXRhIGlucHV0IGZyb20gZm9ybS1kYXRhIG1vZHVsZVxuXHRcdHJldHVybiBgbXVsdGlwYXJ0L2Zvcm0tZGF0YTtib3VuZGFyeT0ke2JvZHkuZ2V0Qm91bmRhcnkoKX1gO1xuXHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHQvLyBib2R5IGlzIHN0cmVhbVxuXHRcdC8vIGNhbid0IHJlYWxseSBkbyBtdWNoIGFib3V0IHRoaXNcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIHtcblx0XHQvLyBCb2R5IGNvbnN0cnVjdG9yIGRlZmF1bHRzIG90aGVyIHRoaW5ncyB0byBzdHJpbmdcblx0XHRyZXR1cm4gJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCc7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgRmV0Y2ggU3RhbmRhcmQgdHJlYXRzIHRoaXMgYXMgaWYgXCJ0b3RhbCBieXRlc1wiIGlzIGEgcHJvcGVydHkgb24gdGhlIGJvZHkuXG4gKiBGb3IgdXMsIHdlIGhhdmUgdG8gZXhwbGljaXRseSBnZXQgaXQgd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIHJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS10b3RhbC1ieXRlc1xuICpcbiAqIEBwYXJhbSAgIEJvZHkgICAgaW5zdGFuY2UgICBJbnN0YW5jZSBvZiBCb2R5XG4gKiBAcmV0dXJuICBOdW1iZXI/ICAgICAgICAgICAgTnVtYmVyIG9mIGJ5dGVzLCBvciBudWxsIGlmIG5vdCBwb3NzaWJsZVxuICovXG5mdW5jdGlvbiBnZXRUb3RhbEJ5dGVzKGluc3RhbmNlKSB7XG5cdGNvbnN0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIG51bGxcblx0XHRyZXR1cm4gMDtcblx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRyZXR1cm4gYm9keS5zaXplO1xuXHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXG5cdFx0cmV0dXJuIGJvZHkubGVuZ3RoO1xuXHR9IGVsc2UgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGRldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdFx0aWYgKGJvZHkuX2xlbmd0aFJldHJpZXZlcnMgJiYgYm9keS5fbGVuZ3RoUmV0cmlldmVycy5sZW5ndGggPT0gMCB8fCAvLyAxLnhcblx0XHRib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSkge1xuXHRcdFx0Ly8gMi54XG5cdFx0XHRyZXR1cm4gYm9keS5nZXRMZW5ndGhTeW5jKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIEJvZHkgdG8gYSBOb2RlLmpzIFdyaXRhYmxlU3RyZWFtIChlLmcuIGh0dHAuUmVxdWVzdCkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAgIEJvZHkgICAgaW5zdGFuY2UgICBJbnN0YW5jZSBvZiBCb2R5XG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVG9TdHJlYW0oZGVzdCwgaW5zdGFuY2UpIHtcblx0Y29uc3QgYm9keSA9IGluc3RhbmNlLmJvZHk7XG5cblxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0Ym9keS5zdHJlYW0oKS5waXBlKGRlc3QpO1xuXHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXG5cdFx0ZGVzdC53cml0ZShib2R5KTtcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdFx0Ym9keS5waXBlKGRlc3QpO1xuXHR9XG59XG5cbi8vIGV4cG9zZSBQcm9taXNlXG5Cb2R5LlByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcblxuLyoqXG4gKiBoZWFkZXJzLmpzXG4gKlxuICogSGVhZGVycyBjbGFzcyBvZmZlcnMgY29udmVuaWVudCBoZWxwZXJzXG4gKi9cblxuY29uc3QgaW52YWxpZFRva2VuUmVnZXggPSAvW15cXF5fYGEtekEtWlxcLTAtOSEjJCUmJyorLnx+XS87XG5jb25zdCBpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUobmFtZSkge1xuXHRuYW1lID0gYCR7bmFtZX1gO1xuXHRpZiAoaW52YWxpZFRva2VuUmVnZXgudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgbmFtZWApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVmFsdWUodmFsdWUpIHtcblx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xuXHRpZiAoaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KHZhbHVlKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dmFsdWV9IGlzIG5vdCBhIGxlZ2FsIEhUVFAgaGVhZGVyIHZhbHVlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGaW5kIHRoZSBrZXkgaW4gdGhlIG1hcCBvYmplY3QgZ2l2ZW4gYSBoZWFkZXIgbmFtZS5cbiAqXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBub3QgZm91bmQuXG4gKlxuICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxuICogQHJldHVybiAgU3RyaW5nfFVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBmaW5kKG1hcCwgbmFtZSkge1xuXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcblx0XHRpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IE1BUCA9IFN5bWJvbCgnbWFwJyk7XG5jbGFzcyBIZWFkZXJzIHtcblx0LyoqXG4gICogSGVhZGVycyBjbGFzc1xuICAqXG4gICogQHBhcmFtICAgT2JqZWN0ICBoZWFkZXJzICBSZXNwb25zZSBoZWFkZXJzXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRsZXQgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuXG5cdFx0dGhpc1tNQVBdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRcdGlmIChpbml0IGluc3RhbmNlb2YgSGVhZGVycykge1xuXHRcdFx0Y29uc3QgcmF3SGVhZGVycyA9IGluaXQucmF3KCk7XG5cdFx0XHRjb25zdCBoZWFkZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJhd0hlYWRlcnMpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgaGVhZGVyTmFtZXMpIHtcblx0XHRcdFx0Zm9yIChjb25zdCB2YWx1ZSBvZiByYXdIZWFkZXJzW2hlYWRlck5hbWVdKSB7XG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQoaGVhZGVyTmFtZSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBXZSBkb24ndCB3b3JyeSBhYm91dCBjb252ZXJ0aW5nIHByb3AgdG8gQnl0ZVN0cmluZyBoZXJlIGFzIGFwcGVuZCgpXG5cdFx0Ly8gd2lsbCBoYW5kbGUgaXQuXG5cdFx0aWYgKGluaXQgPT0gbnVsbCkgOyBlbHNlIGlmICh0eXBlb2YgaW5pdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGNvbnN0IG1ldGhvZCA9IGluaXRbU3ltYm9sLml0ZXJhdG9yXTtcblx0XHRcdGlmIChtZXRob2QgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlciBwYWlycyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj5cblx0XHRcdFx0Ly8gTm90ZTogcGVyIHNwZWMgd2UgaGF2ZSB0byBmaXJzdCBleGhhdXN0IHRoZSBsaXN0cyB0aGVuIHByb2Nlc3MgdGhlbVxuXHRcdFx0XHRjb25zdCBwYWlycyA9IFtdO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHBhaXIgb2YgaW5pdCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhaXJbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhaXJzLnB1c2goQXJyYXkuZnJvbShwYWlyKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcblx0XHRcdFx0XHRpZiAocGFpci5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBhIG5hbWUvdmFsdWUgdHVwbGUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQocGFpclswXSwgcGFpclsxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPlxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbml0KSkge1xuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gaW5pdFtrZXldO1xuXHRcdFx0XHRcdHRoaXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGluaXRpYWxpemVyIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogUmV0dXJuIGNvbWJpbmVkIGhlYWRlciB2YWx1ZSBnaXZlbiBuYW1lXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gICogQHJldHVybiAgTWl4ZWRcbiAgKi9cblx0Z2V0KG5hbWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1tNQVBdW2tleV0uam9pbignLCAnKTtcblx0fVxuXG5cdC8qKlxuICAqIEl0ZXJhdGUgb3ZlciBhbGwgaGVhZGVyc1xuICAqXG4gICogQHBhcmFtICAgRnVuY3Rpb24gIGNhbGxiYWNrICBFeGVjdXRlZCBmb3IgZWFjaCBpdGVtIHdpdGggcGFyYW1ldGVycyAodmFsdWUsIG5hbWUsIHRoaXNBcmcpXG4gICogQHBhcmFtICAgQm9vbGVhbiAgIHRoaXNBcmcgICBgdGhpc2AgY29udGV4dCBmb3IgY2FsbGJhY2sgZnVuY3Rpb25cbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGZvckVhY2goY2FsbGJhY2spIHtcblx0XHRsZXQgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG5cdFx0bGV0IHBhaXJzID0gZ2V0SGVhZGVycyh0aGlzKTtcblx0XHRsZXQgaSA9IDA7XG5cdFx0d2hpbGUgKGkgPCBwYWlycy5sZW5ndGgpIHtcblx0XHRcdHZhciBfcGFpcnMkaSA9IHBhaXJzW2ldO1xuXHRcdFx0Y29uc3QgbmFtZSA9IF9wYWlycyRpWzBdLFxuXHRcdFx0ICAgICAgdmFsdWUgPSBfcGFpcnMkaVsxXTtcblxuXHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzQXJnLCB2YWx1ZSwgbmFtZSwgdGhpcyk7XG5cdFx0XHRwYWlycyA9IGdldEhlYWRlcnModGhpcyk7XG5cdFx0XHRpKys7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogT3ZlcndyaXRlIGhlYWRlciB2YWx1ZXMgZ2l2ZW4gbmFtZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICAgSGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0gICBTdHJpbmcgIHZhbHVlICBIZWFkZXIgdmFsdWVcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHR2YWxpZGF0ZVZhbHVlKHZhbHVlKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0dGhpc1tNQVBdW2tleSAhPT0gdW5kZWZpbmVkID8ga2V5IDogbmFtZV0gPSBbdmFsdWVdO1xuXHR9XG5cblx0LyoqXG4gICogQXBwZW5kIGEgdmFsdWUgb250byBleGlzdGluZyBoZWFkZXJcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgIEhlYWRlciBuYW1lXG4gICogQHBhcmFtICAgU3RyaW5nICB2YWx1ZSAgSGVhZGVyIHZhbHVlXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRhcHBlbmQobmFtZSwgdmFsdWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbHVlID0gYCR7dmFsdWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0dmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpc1tNQVBdW2tleV0ucHVzaCh2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXNbTUFQXVtuYW1lXSA9IFt2YWx1ZV07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogQ2hlY2sgZm9yIGhlYWRlciBuYW1lIGV4aXN0ZW5jZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICAgbmFtZSAgSGVhZGVyIG5hbWVcbiAgKiBAcmV0dXJuICBCb29sZWFuXG4gICovXG5cdGhhcyhuYW1lKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0cmV0dXJuIGZpbmQodGhpc1tNQVBdLCBuYW1lKSAhPT0gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG4gICogRGVsZXRlIGFsbCBoZWFkZXIgdmFsdWVzIGdpdmVuIG5hbWVcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgSGVhZGVyIG5hbWVcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGRlbGV0ZShuYW1lKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbTUFQXVtrZXldO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIFJldHVybiByYXcgaGVhZGVycyAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgT2JqZWN0XG4gICovXG5cdHJhdygpIHtcblx0XHRyZXR1cm4gdGhpc1tNQVBdO1xuXHR9XG5cblx0LyoqXG4gICogR2V0IGFuIGl0ZXJhdG9yIG9uIGtleXMuXG4gICpcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxuICAqL1xuXHRrZXlzKCkge1xuXHRcdHJldHVybiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGhpcywgJ2tleScpO1xuXHR9XG5cblx0LyoqXG4gICogR2V0IGFuIGl0ZXJhdG9yIG9uIHZhbHVlcy5cbiAgKlxuICAqIEByZXR1cm4gIEl0ZXJhdG9yXG4gICovXG5cdHZhbHVlcygpIHtcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZScpO1xuXHR9XG5cblx0LyoqXG4gICogR2V0IGFuIGl0ZXJhdG9yIG9uIGVudHJpZXMuXG4gICpcbiAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIG9mIHRoZSBIZWFkZXJzIG9iamVjdC5cbiAgKlxuICAqIEByZXR1cm4gIEl0ZXJhdG9yXG4gICovXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXHRcdHJldHVybiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGhpcywgJ2tleSt2YWx1ZScpO1xuXHR9XG59XG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRlcnMucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdIZWFkZXJzJyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIHtcblx0Z2V0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0Zm9yRWFjaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHNldDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGFwcGVuZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGhhczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGRlbGV0ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGtleXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR2YWx1ZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRlbnRyaWVzOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbmZ1bmN0aW9uIGdldEhlYWRlcnMoaGVhZGVycykge1xuXHRsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2tleSt2YWx1ZSc7XG5cblx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGhlYWRlcnNbTUFQXSkuc29ydCgpO1xuXHRyZXR1cm4ga2V5cy5tYXAoa2luZCA9PT0gJ2tleScgPyBmdW5jdGlvbiAoaykge1xuXHRcdHJldHVybiBrLnRvTG93ZXJDYXNlKCk7XG5cdH0gOiBraW5kID09PSAndmFsdWUnID8gZnVuY3Rpb24gKGspIHtcblx0XHRyZXR1cm4gaGVhZGVyc1tNQVBdW2tdLmpvaW4oJywgJyk7XG5cdH0gOiBmdW5jdGlvbiAoaykge1xuXHRcdHJldHVybiBbay50b0xvd2VyQ2FzZSgpLCBoZWFkZXJzW01BUF1ba10uam9pbignLCAnKV07XG5cdH0pO1xufVxuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbCgnaW50ZXJuYWwnKTtcblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRhcmdldCwga2luZCkge1xuXHRjb25zdCBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlKTtcblx0aXRlcmF0b3JbSU5URVJOQUxdID0ge1xuXHRcdHRhcmdldCxcblx0XHRraW5kLFxuXHRcdGluZGV4OiAwXG5cdH07XG5cdHJldHVybiBpdGVyYXRvcjtcbn1cblxuY29uc3QgSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKHtcblx0bmV4dCgpIHtcblx0XHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcblx0XHRpZiAoIXRoaXMgfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIG9mIGB0aGlzYCBpcyBub3QgYSBIZWFkZXJzSXRlcmF0b3InKTtcblx0XHR9XG5cblx0XHR2YXIgX0lOVEVSTkFMID0gdGhpc1tJTlRFUk5BTF07XG5cdFx0Y29uc3QgdGFyZ2V0ID0gX0lOVEVSTkFMLnRhcmdldCxcblx0XHQgICAgICBraW5kID0gX0lOVEVSTkFMLmtpbmQsXG5cdFx0ICAgICAgaW5kZXggPSBfSU5URVJOQUwuaW5kZXg7XG5cblx0XHRjb25zdCB2YWx1ZXMgPSBnZXRIZWFkZXJzKHRhcmdldCwga2luZCk7XG5cdFx0Y29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aDtcblx0XHRpZiAoaW5kZXggPj0gbGVuKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxdLmluZGV4ID0gaW5kZXggKyAxO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbHVlOiB2YWx1ZXNbaW5kZXhdLFxuXHRcdFx0ZG9uZTogZmFsc2Vcblx0XHR9O1xuXHR9XG59LCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnSGVhZGVyc0l0ZXJhdG9yJyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIEhlYWRlcnMgb2JqZWN0IGluIGEgZm9ybSB0aGF0IE5vZGUuanMgY2FuIGNvbnN1bWUuXG4gKlxuICogQHBhcmFtICAgSGVhZGVycyAgaGVhZGVyc1xuICogQHJldHVybiAgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4cG9ydE5vZGVDb21wYXRpYmxlSGVhZGVycyhoZWFkZXJzKSB7XG5cdGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24oeyBfX3Byb3RvX186IG51bGwgfSwgaGVhZGVyc1tNQVBdKTtcblxuXHQvLyBodHRwLnJlcXVlc3QoKSBvbmx5IHN1cHBvcnRzIHN0cmluZyBhcyBIb3N0IGhlYWRlci4gVGhpcyBoYWNrIG1ha2VzXG5cdC8vIHNwZWNpZnlpbmcgY3VzdG9tIEhvc3QgaGVhZGVyIHBvc3NpYmxlLlxuXHRjb25zdCBob3N0SGVhZGVyS2V5ID0gZmluZChoZWFkZXJzW01BUF0sICdIb3N0Jyk7XG5cdGlmIChob3N0SGVhZGVyS2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRvYmpbaG9zdEhlYWRlcktleV0gPSBvYmpbaG9zdEhlYWRlcktleV1bMF07XG5cdH1cblxuXHRyZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIEhlYWRlcnMgb2JqZWN0IGZyb20gYW4gb2JqZWN0IG9mIGhlYWRlcnMsIGlnbm9yaW5nIHRob3NlIHRoYXQgZG9cbiAqIG5vdCBjb25mb3JtIHRvIEhUVFAgZ3JhbW1hciBwcm9kdWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gICBPYmplY3QgIG9iaiAgT2JqZWN0IG9mIGhlYWRlcnNcbiAqIEByZXR1cm4gIEhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGVhZGVyc0xlbmllbnQob2JqKSB7XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuXHRmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuXHRcdGlmIChpbnZhbGlkVG9rZW5SZWdleC50ZXN0KG5hbWUpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqW25hbWVdKSkge1xuXHRcdFx0Zm9yIChjb25zdCB2YWwgb2Ygb2JqW25hbWVdKSB7XG5cdFx0XHRcdGlmIChpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LnRlc3QodmFsKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoZWFkZXJzW01BUF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhlYWRlcnNbTUFQXVtuYW1lXSA9IFt2YWxdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWRlcnNbTUFQXVtuYW1lXS5wdXNoKHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LnRlc3Qob2JqW25hbWVdKSkge1xuXHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdID0gW29ialtuYW1lXV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBoZWFkZXJzO1xufVxuXG5jb25zdCBJTlRFUk5BTFMkMSA9IFN5bWJvbCgnUmVzcG9uc2UgaW50ZXJuYWxzJyk7XG5cbi8vIGZpeCBhbiBpc3N1ZSB3aGVyZSBcIlNUQVRVU19DT0RFU1wiIGFyZW4ndCBhIG5hbWVkIGV4cG9ydCBmb3Igbm9kZSA8MTBcbmNvbnN0IFNUQVRVU19DT0RFUyA9IGh0dHAuU1RBVFVTX0NPREVTO1xuXG4vKipcbiAqIFJlc3BvbnNlIGNsYXNzXG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXNwb25zZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGxldCBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXHRcdGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdEJvZHkuY2FsbCh0aGlzLCBib2R5LCBvcHRzKTtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IG9wdHMuc3RhdHVzIHx8IDIwMDtcblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0cy5oZWFkZXJzKTtcblxuXHRcdGlmIChib2R5ICE9IG51bGwgJiYgIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoYm9keSk7XG5cdFx0XHRpZiAoY29udGVudFR5cGUpIHtcblx0XHRcdFx0aGVhZGVycy5hcHBlbmQoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMUyQxXSA9IHtcblx0XHRcdHVybDogb3B0cy51cmwsXG5cdFx0XHRzdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBvcHRzLnN0YXR1c1RleHQgfHwgU1RBVFVTX0NPREVTW3N0YXR1c10sXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0Y291bnRlcjogb3B0cy5jb3VudGVyXG5cdFx0fTtcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnVybCB8fCAnJztcblx0fVxuXG5cdGdldCBzdGF0dXMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cztcblx0fVxuXG5cdC8qKlxuICAqIENvbnZlbmllbmNlIHByb3BlcnR5IHJlcHJlc2VudGluZyBpZiB0aGUgcmVxdWVzdCBlbmRlZCBub3JtYWxseVxuICAqL1xuXHRnZXQgb2soKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1cyA+PSAyMDAgJiYgdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzIDwgMzAwO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLmNvdW50ZXIgPiAwO1xuXHR9XG5cblx0Z2V0IHN0YXR1c1RleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDFdLnN0YXR1c1RleHQ7XG5cdH1cblxuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uaGVhZGVycztcblx0fVxuXG5cdC8qKlxuICAqIENsb25lIHRoaXMgcmVzcG9uc2VcbiAgKlxuICAqIEByZXR1cm4gIFJlc3BvbnNlXG4gICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoY2xvbmUodGhpcyksIHtcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0b2s6IHRoaXMub2ssXG5cdFx0XHRyZWRpcmVjdGVkOiB0aGlzLnJlZGlyZWN0ZWRcblx0XHR9KTtcblx0fVxufVxuXG5Cb2R5Lm1peEluKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLnByb3RvdHlwZSwge1xuXHR1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzdGF0dXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRvazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHJlZGlyZWN0ZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzdGF0dXNUZXh0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0aGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGNsb25lOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNwb25zZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ1Jlc3BvbnNlJyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgSU5URVJOQUxTJDIgPSBTeW1ib2woJ1JlcXVlc3QgaW50ZXJuYWxzJyk7XG5jb25zdCBVUkwgPSBVcmwuVVJMIHx8IHdoYXR3Z1VybC5VUkw7XG5cbi8vIGZpeCBhbiBpc3N1ZSB3aGVyZSBcImZvcm1hdFwiLCBcInBhcnNlXCIgYXJlbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxuY29uc3QgcGFyc2VfdXJsID0gVXJsLnBhcnNlO1xuY29uc3QgZm9ybWF0X3VybCA9IFVybC5mb3JtYXQ7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYG5ldyBVUkxgIHRvIGhhbmRsZSBhcmJpdHJhcnkgVVJMc1xuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsU3RyXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5mdW5jdGlvbiBwYXJzZVVSTCh1cmxTdHIpIHtcblx0LypcbiBcdENoZWNrIHdoZXRoZXIgdGhlIFVSTCBpcyBhYnNvbHV0ZSBvciBub3RcbiBcdFx0U2NoZW1lOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuIFx0QWJzb2x1dGUgVVJMOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTQuM1xuICovXG5cdGlmICgvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly5leGVjKHVybFN0cikpIHtcblx0XHR1cmxTdHIgPSBuZXcgVVJMKHVybFN0cikudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8vIEZhbGxiYWNrIHRvIG9sZCBpbXBsZW1lbnRhdGlvbiBmb3IgYXJiaXRyYXJ5IFVSTHNcblx0cmV0dXJuIHBhcnNlX3VybCh1cmxTdHIpO1xufVxuXG5jb25zdCBzdHJlYW1EZXN0cnVjdGlvblN1cHBvcnRlZCA9ICdkZXN0cm95JyBpbiBTdHJlYW0uUmVhZGFibGUucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgUmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGlucHV0XG4gKiBAcmV0dXJuICBCb29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzUmVxdWVzdChpbnB1dCkge1xuXHRyZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5wdXRbSU5URVJOQUxTJDJdID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNBYm9ydFNpZ25hbChzaWduYWwpIHtcblx0Y29uc3QgcHJvdG8gPSBzaWduYWwgJiYgdHlwZW9mIHNpZ25hbCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNpZ25hbCk7XG5cdHJldHVybiAhIShwcm90byAmJiBwcm90by5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQWJvcnRTaWduYWwnKTtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0IGNsYXNzXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dCAgVXJsIG9yIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEBwYXJhbSAgIE9iamVjdCAgaW5pdCAgIEN1c3RvbSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmNsYXNzIFJlcXVlc3Qge1xuXHRjb25zdHJ1Y3RvcihpbnB1dCkge1xuXHRcdGxldCBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdGxldCBwYXJzZWRVUkw7XG5cblx0XHQvLyBub3JtYWxpemUgaW5wdXRcblx0XHRpZiAoIWlzUmVxdWVzdChpbnB1dCkpIHtcblx0XHRcdGlmIChpbnB1dCAmJiBpbnB1dC5ocmVmKSB7XG5cdFx0XHRcdC8vIGluIG9yZGVyIHRvIHN1cHBvcnQgTm9kZS5qcycgVXJsIG9iamVjdHM7IHRob3VnaCBXSEFUV0cncyBVUkwgb2JqZWN0c1xuXHRcdFx0XHQvLyB3aWxsIGZhbGwgaW50byB0aGlzIGJyYW5jaCBhbHNvIChzaW5jZSB0aGVpciBgdG9TdHJpbmcoKWAgd2lsbCByZXR1cm5cblx0XHRcdFx0Ly8gYGhyZWZgIHByb3BlcnR5IGFueXdheSlcblx0XHRcdFx0cGFyc2VkVVJMID0gcGFyc2VVUkwoaW5wdXQuaHJlZik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBjb2VyY2UgaW5wdXQgdG8gYSBzdHJpbmcgYmVmb3JlIGF0dGVtcHRpbmcgdG8gcGFyc2Vcblx0XHRcdFx0cGFyc2VkVVJMID0gcGFyc2VVUkwoYCR7aW5wdXR9YCk7XG5cdFx0XHR9XG5cdFx0XHRpbnB1dCA9IHt9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBwYXJzZVVSTChpbnB1dC51cmwpO1xuXHRcdH1cblxuXHRcdGxldCBtZXRob2QgPSBpbml0Lm1ldGhvZCB8fCBpbnB1dC5tZXRob2QgfHwgJ0dFVCc7XG5cdFx0bWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cblx0XHRpZiAoKGluaXQuYm9keSAhPSBudWxsIHx8IGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCkgJiYgKG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnSEVBRCcpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHknKTtcblx0XHR9XG5cblx0XHRsZXQgaW5wdXRCb2R5ID0gaW5pdC5ib2R5ICE9IG51bGwgPyBpbml0LmJvZHkgOiBpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwgPyBjbG9uZShpbnB1dCkgOiBudWxsO1xuXG5cdFx0Qm9keS5jYWxsKHRoaXMsIGlucHV0Qm9keSwge1xuXHRcdFx0dGltZW91dDogaW5pdC50aW1lb3V0IHx8IGlucHV0LnRpbWVvdXQgfHwgMCxcblx0XHRcdHNpemU6IGluaXQuc2l6ZSB8fCBpbnB1dC5zaXplIHx8IDBcblx0XHR9KTtcblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMgfHwgaW5wdXQuaGVhZGVycyB8fCB7fSk7XG5cblx0XHRpZiAoaW5wdXRCb2R5ICE9IG51bGwgJiYgIWhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSkge1xuXHRcdFx0Y29uc3QgY29udGVudFR5cGUgPSBleHRyYWN0Q29udGVudFR5cGUoaW5wdXRCb2R5KTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCBzaWduYWwgPSBpc1JlcXVlc3QoaW5wdXQpID8gaW5wdXQuc2lnbmFsIDogbnVsbDtcblx0XHRpZiAoJ3NpZ25hbCcgaW4gaW5pdCkgc2lnbmFsID0gaW5pdC5zaWduYWw7XG5cblx0XHRpZiAoc2lnbmFsICE9IG51bGwgJiYgIWlzQWJvcnRTaWduYWwoc2lnbmFsKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwnKTtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMUyQyXSA9IHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0IHx8IGlucHV0LnJlZGlyZWN0IHx8ICdmb2xsb3cnLFxuXHRcdFx0aGVhZGVycyxcblx0XHRcdHBhcnNlZFVSTCxcblx0XHRcdHNpZ25hbFxuXHRcdH07XG5cblx0XHQvLyBub2RlLWZldGNoLW9ubHkgb3B0aW9uc1xuXHRcdHRoaXMuZm9sbG93ID0gaW5pdC5mb2xsb3cgIT09IHVuZGVmaW5lZCA/IGluaXQuZm9sbG93IDogaW5wdXQuZm9sbG93ICE9PSB1bmRlZmluZWQgPyBpbnB1dC5mb2xsb3cgOiAyMDtcblx0XHR0aGlzLmNvbXByZXNzID0gaW5pdC5jb21wcmVzcyAhPT0gdW5kZWZpbmVkID8gaW5pdC5jb21wcmVzcyA6IGlucHV0LmNvbXByZXNzICE9PSB1bmRlZmluZWQgPyBpbnB1dC5jb21wcmVzcyA6IHRydWU7XG5cdFx0dGhpcy5jb3VudGVyID0gaW5pdC5jb3VudGVyIHx8IGlucHV0LmNvdW50ZXIgfHwgMDtcblx0XHR0aGlzLmFnZW50ID0gaW5pdC5hZ2VudCB8fCBpbnB1dC5hZ2VudDtcblx0fVxuXG5cdGdldCBtZXRob2QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLm1ldGhvZDtcblx0fVxuXG5cdGdldCB1cmwoKSB7XG5cdFx0cmV0dXJuIGZvcm1hdF91cmwodGhpc1tJTlRFUk5BTFMkMl0ucGFyc2VkVVJMKTtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5oZWFkZXJzO1xuXHR9XG5cblx0Z2V0IHJlZGlyZWN0KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5yZWRpcmVjdDtcblx0fVxuXG5cdGdldCBzaWduYWwoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLnNpZ25hbDtcblx0fVxuXG5cdC8qKlxuICAqIENsb25lIHRoaXMgcmVxdWVzdFxuICAqXG4gICogQHJldHVybiAgUmVxdWVzdFxuICAqL1xuXHRjbG9uZSgpIHtcblx0XHRyZXR1cm4gbmV3IFJlcXVlc3QodGhpcyk7XG5cdH1cbn1cblxuQm9keS5taXhJbihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1ZXN0LnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnUmVxdWVzdCcsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG5cdG1ldGhvZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGhlYWRlcnM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRyZWRpcmVjdDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGNsb25lOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c2lnbmFsOiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhIFJlcXVlc3QgdG8gTm9kZS5qcyBodHRwIHJlcXVlc3Qgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gICBSZXF1ZXN0ICBBIFJlcXVlc3QgaW5zdGFuY2VcbiAqIEByZXR1cm4gIE9iamVjdCAgIFRoZSBvcHRpb25zIG9iamVjdCB0byBiZSBwYXNzZWQgdG8gaHR0cC5yZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KSB7XG5cdGNvbnN0IHBhcnNlZFVSTCA9IHJlcXVlc3RbSU5URVJOQUxTJDJdLnBhcnNlZFVSTDtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlcXVlc3RbSU5URVJOQUxTJDJdLmhlYWRlcnMpO1xuXG5cdC8vIGZldGNoIHN0ZXAgMS4zXG5cdGlmICghaGVhZGVycy5oYXMoJ0FjY2VwdCcpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdCcsICcqLyonKTtcblx0fVxuXG5cdC8vIEJhc2ljIGZldGNoXG5cdGlmICghcGFyc2VkVVJMLnByb3RvY29sIHx8ICFwYXJzZWRVUkwuaG9zdG5hbWUpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IGFic29sdXRlIFVSTHMgYXJlIHN1cHBvcnRlZCcpO1xuXHR9XG5cblx0aWYgKCEvXmh0dHBzPzokLy50ZXN0KHBhcnNlZFVSTC5wcm90b2NvbCkpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPbmx5IEhUVFAoUykgcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQnKTtcblx0fVxuXG5cdGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0uUmVhZGFibGUgJiYgIXN0cmVhbURlc3RydWN0aW9uU3VwcG9ydGVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5jZWxsYXRpb24gb2Ygc3RyZWFtZWQgcmVxdWVzdHMgd2l0aCBBYm9ydFNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkIGluIG5vZGUgPCA4Jyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PSBudWxsICYmIC9eKFBPU1R8UFVUKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuXHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9ICcwJztcblx0fVxuXHRpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcblx0XHRjb25zdCB0b3RhbEJ5dGVzID0gZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KTtcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSBTdHJpbmcodG90YWxCeXRlcyk7XG5cdFx0fVxuXHR9XG5cdGlmIChjb250ZW50TGVuZ3RoVmFsdWUpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1MZW5ndGgnLCBjb250ZW50TGVuZ3RoVmFsdWUpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xMVxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcblx0XHRoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdub2RlLWZldGNoLzEuMCAoK2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaCknKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTVcblx0aWYgKHJlcXVlc3QuY29tcHJlc3MgJiYgIWhlYWRlcnMuaGFzKCdBY2NlcHQtRW5jb2RpbmcnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQtRW5jb2RpbmcnLCAnZ3ppcCxkZWZsYXRlJyk7XG5cdH1cblxuXHRsZXQgYWdlbnQgPSByZXF1ZXN0LmFnZW50O1xuXHRpZiAodHlwZW9mIGFnZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0YWdlbnQgPSBhZ2VudChwYXJzZWRVUkwpO1xuXHR9XG5cblx0aWYgKCFoZWFkZXJzLmhhcygnQ29ubmVjdGlvbicpICYmICFhZ2VudCkge1xuXHRcdGhlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ2Nsb3NlJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCA0LjJcblx0Ly8gY2h1bmtlZCBlbmNvZGluZyBpcyBoYW5kbGVkIGJ5IE5vZGUuanNcblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkVVJMLCB7XG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRoZWFkZXJzOiBleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMoaGVhZGVycyksXG5cdFx0YWdlbnRcblx0fSk7XG59XG5cbi8qKlxuICogYWJvcnQtZXJyb3IuanNcbiAqXG4gKiBBYm9ydEVycm9yIGludGVyZmFjZSBmb3IgY2FuY2VsbGVkIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgQWJvcnRFcnJvciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIG1lc3NhZ2UgICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuICogQHJldHVybiAgQWJvcnRFcnJvclxuICovXG5mdW5jdGlvbiBBYm9ydEVycm9yKG1lc3NhZ2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICB0aGlzLnR5cGUgPSAnYWJvcnRlZCc7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgLy8gaGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbn1cblxuQWJvcnRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5BYm9ydEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFib3J0RXJyb3I7XG5BYm9ydEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fib3J0RXJyb3InO1xuXG5jb25zdCBVUkwkMSA9IFVybC5VUkwgfHwgd2hhdHdnVXJsLlVSTDtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiUGFzc1Rocm91Z2hcIiwgXCJyZXNvbHZlXCIgYXJlbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxuY29uc3QgUGFzc1Rocm91Z2gkMSA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcblxuY29uc3QgaXNEb21haW5PclN1YmRvbWFpbiA9IGZ1bmN0aW9uIGlzRG9tYWluT3JTdWJkb21haW4oZGVzdGluYXRpb24sIG9yaWdpbmFsKSB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMJDEob3JpZ2luYWwpLmhvc3RuYW1lO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTCQxKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnW29yaWcubGVuZ3RoIC0gZGVzdC5sZW5ndGggLSAxXSA9PT0gJy4nICYmIG9yaWcuZW5kc1dpdGgoZGVzdCk7XG59O1xuXG4vKipcbiAqIGlzU2FtZVByb3RvY29sIHJlcG9ydHMgd2hldGhlciB0aGUgdHdvIHByb3ZpZGVkIFVSTHMgdXNlIHRoZSBzYW1lIHByb3RvY29sLlxuICpcbiAqIEJvdGggZG9tYWlucyBtdXN0IGFscmVhZHkgYmUgaW4gY2Fub25pY2FsIGZvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IG9yaWdpbmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IGRlc3RpbmF0aW9uXG4gKi9cbmNvbnN0IGlzU2FtZVByb3RvY29sID0gZnVuY3Rpb24gaXNTYW1lUHJvdG9jb2woZGVzdGluYXRpb24sIG9yaWdpbmFsKSB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMJDEob3JpZ2luYWwpLnByb3RvY29sO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTCQxKGRlc3RpbmF0aW9uKS5wcm90b2NvbDtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdDtcbn07XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgICB1cmwgICBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICAgb3B0cyAgRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdHMpIHtcblxuXHQvLyBhbGxvdyBjdXN0b20gcHJvbWlzZVxuXHRpZiAoIWZldGNoLlByb21pc2UpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ25hdGl2ZSBwcm9taXNlIG1pc3NpbmcsIHNldCBmZXRjaC5Qcm9taXNlIHRvIHlvdXIgZmF2b3JpdGUgYWx0ZXJuYXRpdmUnKTtcblx0fVxuXG5cdEJvZHkuUHJvbWlzZSA9IGZldGNoLlByb21pc2U7XG5cblx0Ly8gd3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxuXHRyZXR1cm4gbmV3IGZldGNoLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdC8vIGJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0cyk7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblxuXHRcdGNvbnN0IHNlbmQgPSAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Q7XG5cdFx0Y29uc3Qgc2lnbmFsID0gcmVxdWVzdC5zaWduYWw7XG5cblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdGxldCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgdXNlciBhYm9ydGVkIGEgcmVxdWVzdC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlcXVlc3QuYm9keSwgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkgcmV0dXJuO1xuXHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gZnVuY3Rpb24gYWJvcnRBbmRGaW5hbGl6ZSgpIHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHQvLyBzZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXEgPSBzZW5kKG9wdGlvbnMpO1xuXHRcdGxldCByZXFUaW1lb3V0O1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluYWxpemUoKSB7XG5cdFx0XHRyZXEuYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcblx0XHRcdHJlcS5vbmNlKCdzb2NrZXQnLCBmdW5jdGlvbiAoc29ja2V0KSB7XG5cdFx0XHRcdHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG5ldHdvcmsgdGltZW91dCBhdDogJHtyZXF1ZXN0LnVybH1gLCAncmVxdWVzdC10aW1lb3V0JykpO1xuXHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdH0sIHJlcXVlc3QudGltZW91dCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGZhaWxlZCwgcmVhc29uOiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpKTtcblxuXHRcdFx0aWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0ZGVzdHJveVN0cmVhbShyZXNwb25zZS5ib2R5LCBlcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0ZGVzdHJveVN0cmVhbShyZXNwb25zZS5ib2R5LCBlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cmluZygxKSkgPCAxNCkge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXEub24oJ3NvY2tldCcsIGZ1bmN0aW9uIChzKSB7XG5cdFx0XHRcdHMuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKGhhZEVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYSBkYXRhIGxpc3RlbmVyIGlzIHN0aWxsIHByZXNlbnQgd2UgZGlkbid0IGVuZCBjbGVhbmx5XG5cdFx0XHRcdFx0Y29uc3QgaGFzRGF0YUxpc3RlbmVyID0gcy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwO1xuXG5cdFx0XHRcdFx0Ly8gaWYgZW5kIGhhcHBlbmVkIGJlZm9yZSBjbG9zZSBidXQgdGhlIHNvY2tldCBkaWRuJ3QgZW1pdCBhbiBlcnJvciwgZG8gaXQgbm93XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlICYmIGhhc0RhdGFMaXN0ZW5lciAmJiAhaGFkRXJyb3IgJiYgIShzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdFx0ZXJyLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzTGVuaWVudChyZXMuaGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoZmV0Y2guaXNSZWRpcmVjdChyZXMuc3RhdHVzQ29kZSkpIHtcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxuXHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcblx0XHRcdFx0bGV0IGxvY2F0aW9uVVJMID0gbnVsbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwkMShsb2NhdGlvbiwgcmVxdWVzdC51cmwpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdC8vIGVycm9yIGhlcmUgY2FuIG9ubHkgYmUgaW52YWxpZCBVUkwgaW4gTG9jYXRpb246IGhlYWRlclxuXHRcdFx0XHRcdC8vIGRvIG5vdCB0aHJvdyB3aGVuIG9wdGlvbnMucmVkaXJlY3QgPT0gbWFudWFsXG5cdFx0XHRcdFx0Ly8gbGV0IHRoZSB1c2VyIGV4dHJhY3QgdGhlIGVycm9ybmVvdXMgcmVkaXJlY3QgVVJMXG5cdFx0XHRcdFx0aWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhbiBpbnZhbGlkIHJlZGlyZWN0IFVSTDogJHtsb2NhdGlvbn1gLCAnaW52YWxpZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuNVxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcblx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCAnbm8tcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgJ21hbnVhbCc6XG5cdFx0XHRcdFx0XHQvLyBub2RlLWZldGNoLXNwZWNpZmljIHN0ZXA6IG1ha2UgbWFudWFsIHJlZGlyZWN0IGEgYml0IGVhc2llciB0byB1c2UgYnkgc2V0dGluZyB0aGUgTG9jYXRpb24gaGVhZGVyIHZhbHVlIHRvIHRoZSByZXNvbHZlZCBVUkwuXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Ly8gaGFuZGxlIGNvcnJ1cHRlZCBoZWFkZXJcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRoZWFkZXJzLnNldCgnTG9jYXRpb24nLCBsb2NhdGlvblVSTCk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub2RlanMgc2VydmVyIHByZXZlbnQgaW52YWxpZCByZXNwb25zZSBoZWFkZXJzLCB3ZSBjYW4ndCB0ZXN0IHRoaXMgdGhyb3VnaCBub3JtYWwgcmVxdWVzdFxuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOlxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0cyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHRib2R5OiByZXF1ZXN0LmJvZHksXG5cdFx0XHRcdFx0XHRcdHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG5cdFx0XHRcdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcblx0XHRcdFx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAoIWlzRG9tYWluT3JTdWJkb21haW4ocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSB8fCAhaXNTYW1lUHJvdG9jb2wocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgWydhdXRob3JpemF0aW9uJywgJ3d3dy1hdXRoZW50aWNhdGUnLCAnY29va2llJywgJ2Nvb2tpZTInXSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLmhlYWRlcnMuZGVsZXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA5XG5cdFx0XHRcdFx0XHRpZiAocmVzLnN0YXR1c0NvZGUgIT09IDMwMyAmJiByZXF1ZXN0LmJvZHkgJiYgZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoJ0Nhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtJywgJ3Vuc3VwcG9ydGVkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxMVxuXHRcdFx0XHRcdFx0aWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDMgfHwgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShmZXRjaChuZXcgUmVxdWVzdChsb2NhdGlvblVSTCwgcmVxdWVzdE9wdHMpKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdHJlcy5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fSk7XG5cdFx0XHRsZXQgYm9keSA9IHJlcy5waXBlKG5ldyBQYXNzVGhyb3VnaCQxKCkpO1xuXG5cdFx0XHRjb25zdCByZXNwb25zZV9vcHRpb25zID0ge1xuXHRcdFx0XHR1cmw6IHJlcXVlc3QudXJsLFxuXHRcdFx0XHRzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcblx0XHRcdFx0aGVhZGVyczogaGVhZGVycyxcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHR0aW1lb3V0OiByZXF1ZXN0LnRpbWVvdXQsXG5cdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlclxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjNcblx0XHRcdGNvbnN0IGNvZGluZ3MgPSBoZWFkZXJzLmdldCgnQ29udGVudC1FbmNvZGluZycpO1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuNDogaGFuZGxlIGNvbnRlbnQgY29kaW5nc1xuXG5cdFx0XHQvLyBpbiBmb2xsb3dpbmcgc2NlbmFyaW9zIHdlIGlnbm9yZSBjb21wcmVzc2lvbiBzdXBwb3J0XG5cdFx0XHQvLyAxLiBjb21wcmVzc2lvbiBzdXBwb3J0IGlzIGRpc2FibGVkXG5cdFx0XHQvLyAyLiBIRUFEIHJlcXVlc3Rcblx0XHRcdC8vIDMuIG5vIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG5cdFx0XHQvLyA0LiBubyBjb250ZW50IHJlc3BvbnNlICgyMDQpXG5cdFx0XHQvLyA1LiBjb250ZW50IG5vdCBtb2RpZmllZCByZXNwb25zZSAoMzA0KVxuXHRcdFx0aWYgKCFyZXF1ZXN0LmNvbXByZXNzIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHwgY29kaW5ncyA9PT0gbnVsbCB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHJlcy5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBOb2RlIHY2K1xuXHRcdFx0Ly8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcblx0XHRcdC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cblx0XHRcdC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuXHRcdFx0XHRmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcblx0XHRcdH07XG5cblx0XHRcdC8vIGZvciBnemlwXG5cdFx0XHRpZiAoY29kaW5ncyA9PSAnZ3ppcCcgfHwgY29kaW5ncyA9PSAneC1nemlwJykge1xuXHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSk7XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgZGVmbGF0ZVxuXHRcdFx0aWYgKGNvZGluZ3MgPT0gJ2RlZmxhdGUnIHx8IGNvZGluZ3MgPT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gcmVzLnBpcGUobmV3IFBhc3NUaHJvdWdoJDEoKSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRcdFx0Ly8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVJbmZsYXRlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyYXcub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBzb21lIG9sZCBJSVMgc2VydmVycyByZXR1cm4gemVyby1sZW5ndGggT0sgZGVmbGF0ZSByZXNwb25zZXMsIHNvICdkYXRhJyBpcyBuZXZlciBlbWl0dGVkLlxuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYnJcblx0XHRcdGlmIChjb2RpbmdzID09ICdicicgJiYgdHlwZW9mIHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSwgdXNlIHJlc3BvbnNlIGFzLWlzXG5cdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXEsIHJlcXVlc3QpO1xuXHR9KTtcbn1cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0bGV0IHNvY2tldDtcblxuXHRyZXF1ZXN0Lm9uKCdzb2NrZXQnLCBmdW5jdGlvbiAocykge1xuXHRcdHNvY2tldCA9IHM7XG5cdH0pO1xuXG5cdHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0Y29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG5cblx0XHRpZiAoaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSA9PT0gJ2NodW5rZWQnICYmICFoZWFkZXJzWydjb250ZW50LWxlbmd0aCddKSB7XG5cdFx0XHRyZXNwb25zZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIChoYWRFcnJvcikge1xuXHRcdFx0XHQvLyB0ZXN0cyBmb3Igc29ja2V0IHByZXNlbmNlLCBhcyBpbiBzb21lIHNpdHVhdGlvbnMgdGhlXG5cdFx0XHRcdC8vIHRoZSAnc29ja2V0JyBldmVudCBpcyBub3QgdHJpZ2dlcmVkIGZvciB0aGUgcmVxdWVzdFxuXHRcdFx0XHQvLyAoaGFwcGVucyBpbiBkZW5vKSwgYXZvaWRzIGBUeXBlRXJyb3JgXG5cdFx0XHRcdC8vIGlmIGEgZGF0YSBsaXN0ZW5lciBpcyBzdGlsbCBwcmVzZW50IHdlIGRpZG4ndCBlbmQgY2xlYW5seVxuXHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzb2NrZXQgJiYgc29ja2V0Lmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDA7XG5cblx0XHRcdFx0aWYgKGhhc0RhdGFMaXN0ZW5lciAmJiAhaGFkRXJyb3IpIHtcblx0XHRcdFx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdGVyci5jb2RlID0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJztcblx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lTdHJlYW0oc3RyZWFtLCBlcnIpIHtcblx0aWYgKHN0cmVhbS5kZXN0cm95KSB7XG5cdFx0c3RyZWFtLmRlc3Ryb3koZXJyKTtcblx0fSBlbHNlIHtcblx0XHQvLyBub2RlIDwgOFxuXHRcdHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0c3RyZWFtLmVuZCgpO1xuXHR9XG59XG5cbi8qKlxuICogUmVkaXJlY3QgY29kZSBtYXRjaGluZ1xuICpcbiAqIEBwYXJhbSAgIE51bWJlciAgIGNvZGUgIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuICBCb29sZWFuXG4gKi9cbmZldGNoLmlzUmVkaXJlY3QgPSBmdW5jdGlvbiAoY29kZSkge1xuXHRyZXR1cm4gY29kZSA9PT0gMzAxIHx8IGNvZGUgPT09IDMwMiB8fCBjb2RlID09PSAzMDMgfHwgY29kZSA9PT0gMzA3IHx8IGNvZGUgPT09IDMwODtcbn07XG5cbi8vIGV4cG9zZSBQcm9taXNlXG5mZXRjaC5Qcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZldGNoO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cztcbmV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuZXhwb3J0cy5GZXRjaEVycm9yID0gRmV0Y2hFcnJvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwiU3RyZWFtIiwicmVxdWlyZSIsImh0dHAiLCJVcmwiLCJ3aGF0d2dVcmwiLCJodHRwcyIsInpsaWIiLCJSZWFkYWJsZSIsIkJVRkZFUiIsIlN5bWJvbCIsIlRZUEUiLCJCbG9iIiwiY29uc3RydWN0b3IiLCJibG9iUGFydHMiLCJhcmd1bWVudHMiLCJvcHRpb25zIiwiYnVmZmVycyIsInNpemUiLCJhIiwibGVuZ3RoIiwiTnVtYmVyIiwiaSIsImVsZW1lbnQiLCJidWZmZXIiLCJCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb20iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIlN0cmluZyIsInB1c2giLCJjb25jYXQiLCJ0eXBlIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwidGV4dCIsIlByb21pc2UiLCJyZXNvbHZlIiwidG9TdHJpbmciLCJhcnJheUJ1ZmZlciIsImJ1ZiIsImFiIiwic2xpY2UiLCJzdHJlYW0iLCJyZWFkYWJsZSIsIl9yZWFkIiwic3RhcnQiLCJlbmQiLCJyZWxhdGl2ZVN0YXJ0IiwicmVsYXRpdmVFbmQiLCJNYXRoIiwibWF4IiwibWluIiwic3BhbiIsInNsaWNlZEJ1ZmZlciIsImJsb2IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSIsInRvU3RyaW5nVGFnIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJGZXRjaEVycm9yIiwibWVzc2FnZSIsInN5c3RlbUVycm9yIiwiRXJyb3IiLCJjYWxsIiwiY29kZSIsImVycm5vIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjcmVhdGUiLCJuYW1lIiwiY29udmVydCIsIklOVEVSTkFMUyIsIlBhc3NUaHJvdWdoIiwiQm9keSIsImJvZHkiLCJfdGhpcyIsIl9yZWYiLCJfcmVmJHNpemUiLCJfcmVmJHRpbWVvdXQiLCJ0aW1lb3V0IiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc0Jsb2IiLCJpc0J1ZmZlciIsImRpc3R1cmJlZCIsImVycm9yIiwib24iLCJlcnIiLCJ1cmwiLCJib2R5VXNlZCIsImNvbnN1bWVCb2R5IiwidGhlbiIsImN0IiwiaGVhZGVycyIsImdldCIsImFzc2lnbiIsImpzb24iLCJfdGhpczIiLCJKU09OIiwicGFyc2UiLCJyZWplY3QiLCJ0ZXh0Q29udmVydGVkIiwiX3RoaXMzIiwiY29udmVydEJvZHkiLCJtaXhJbiIsInByb3RvIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfdGhpczQiLCJUeXBlRXJyb3IiLCJhbGxvYyIsImFjY3VtIiwiYWNjdW1CeXRlcyIsImFib3J0IiwicmVzVGltZW91dCIsInNldFRpbWVvdXQiLCJjaHVuayIsImNsZWFyVGltZW91dCIsImNoYXJzZXQiLCJyZXMiLCJzdHIiLCJleGVjIiwicG9wIiwib2JqIiwiYXBwZW5kIiwiZGVsZXRlIiwiZ2V0QWxsIiwiaGFzIiwic2V0Iiwic29ydCIsImNsb25lIiwiaW5zdGFuY2UiLCJwMSIsInAyIiwiZ2V0Qm91bmRhcnkiLCJwaXBlIiwiZXh0cmFjdENvbnRlbnRUeXBlIiwiZ2V0VG90YWxCeXRlcyIsImdldExlbmd0aFN5bmMiLCJfbGVuZ3RoUmV0cmlldmVycyIsImhhc0tub3duTGVuZ3RoIiwid3JpdGVUb1N0cmVhbSIsImRlc3QiLCJ3cml0ZSIsImdsb2JhbCIsImludmFsaWRUb2tlblJlZ2V4IiwiaW52YWxpZEhlYWRlckNoYXJSZWdleCIsInZhbGlkYXRlTmFtZSIsInZhbGlkYXRlVmFsdWUiLCJmaW5kIiwibWFwIiwia2V5IiwiTUFQIiwiSGVhZGVycyIsImluaXQiLCJyYXdIZWFkZXJzIiwicmF3IiwiaGVhZGVyTmFtZXMiLCJrZXlzIiwiaGVhZGVyTmFtZSIsIm1ldGhvZCIsIml0ZXJhdG9yIiwicGFpcnMiLCJwYWlyIiwiQXJyYXkiLCJqb2luIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwidGhpc0FyZyIsImdldEhlYWRlcnMiLCJfcGFpcnMkaSIsImNyZWF0ZUhlYWRlcnNJdGVyYXRvciIsInZhbHVlcyIsImVudHJpZXMiLCJraW5kIiwiayIsIklOVEVSTkFMIiwidGFyZ2V0IiwiSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlIiwiaW5kZXgiLCJzZXRQcm90b3R5cGVPZiIsIm5leHQiLCJnZXRQcm90b3R5cGVPZiIsIl9JTlRFUk5BTCIsImxlbiIsImRvbmUiLCJleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMiLCJfX3Byb3RvX18iLCJob3N0SGVhZGVyS2V5IiwiY3JlYXRlSGVhZGVyc0xlbmllbnQiLCJpc0FycmF5IiwidmFsIiwiSU5URVJOQUxTJDEiLCJTVEFUVVNfQ09ERVMiLCJSZXNwb25zZSIsIm9wdHMiLCJzdGF0dXMiLCJjb250ZW50VHlwZSIsInN0YXR1c1RleHQiLCJjb3VudGVyIiwib2siLCJyZWRpcmVjdGVkIiwiSU5URVJOQUxTJDIiLCJVUkwiLCJwYXJzZV91cmwiLCJmb3JtYXRfdXJsIiwiZm9ybWF0IiwicGFyc2VVUkwiLCJ1cmxTdHIiLCJzdHJlYW1EZXN0cnVjdGlvblN1cHBvcnRlZCIsImlzUmVxdWVzdCIsImlucHV0IiwiaXNBYm9ydFNpZ25hbCIsInNpZ25hbCIsIlJlcXVlc3QiLCJwYXJzZWRVUkwiLCJocmVmIiwidG9VcHBlckNhc2UiLCJpbnB1dEJvZHkiLCJyZWRpcmVjdCIsImZvbGxvdyIsImNvbXByZXNzIiwiYWdlbnQiLCJnZXROb2RlUmVxdWVzdE9wdGlvbnMiLCJyZXF1ZXN0IiwicHJvdG9jb2wiLCJob3N0bmFtZSIsImNvbnRlbnRMZW5ndGhWYWx1ZSIsInRvdGFsQnl0ZXMiLCJBYm9ydEVycm9yIiwiVVJMJDEiLCJQYXNzVGhyb3VnaCQxIiwiaXNEb21haW5PclN1YmRvbWFpbiIsImRlc3RpbmF0aW9uIiwib3JpZ2luYWwiLCJvcmlnIiwiZW5kc1dpdGgiLCJpc1NhbWVQcm90b2NvbCIsImZldGNoIiwic2VuZCIsInJlc3BvbnNlIiwiZGVzdHJveVN0cmVhbSIsImVtaXQiLCJhYm9ydGVkIiwiYWJvcnRBbmRGaW5hbGl6ZSIsImZpbmFsaXplIiwicmVxIiwicmVxVGltZW91dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25jZSIsInNvY2tldCIsImZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nIiwicGFyc2VJbnQiLCJwcm9jZXNzIiwidmVyc2lvbiIsInN1YnN0cmluZyIsInMiLCJhZGRMaXN0ZW5lciIsImhhZEVycm9yIiwiaGFzRGF0YUxpc3RlbmVyIiwibGlzdGVuZXJDb3VudCIsImlzUmVkaXJlY3QiLCJzdGF0dXNDb2RlIiwibG9jYXRpb24iLCJsb2NhdGlvblVSTCIsInJlcXVlc3RPcHRzIiwicmVzcG9uc2Vfb3B0aW9ucyIsInN0YXR1c01lc3NhZ2UiLCJjb2RpbmdzIiwiemxpYk9wdGlvbnMiLCJmbHVzaCIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwiZXJyb3JDYWxsYmFjayIsImRlc3Ryb3kiLCJtb2R1bGUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n// @ts-ignore\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\"));\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nclass PostgrestBuilder {\n    constructor(builder){\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = builder.headers;\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = builder.shouldThrowOnError;\n        this.signal = builder.signal;\n        this.isMaybeSingle = builder.isMaybeSingle;\n        if (builder.fetch) {\n            this.fetch = builder.fetch;\n        } else if (typeof fetch === \"undefined\") {\n            this.fetch = node_fetch_1.default;\n        } else {\n            this.fetch = fetch;\n        }\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Set an HTTP header for the request.\n     */ setHeader(name, value) {\n        this.headers = Object.assign({}, this.headers);\n        this.headers[name] = value;\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (this.schema === undefined) {\n        // skip\n        } else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) {\n            this.headers[\"Accept-Profile\"] = this.schema;\n        } else {\n            this.headers[\"Content-Profile\"] = this.schema;\n        }\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") {\n            this.headers[\"Content-Type\"] = \"application/json\";\n        }\n        // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n        // https://github.com/supabase/postgrest-js/pull/247\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res)=>{\n            var _a, _b, _c;\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res.status;\n            let statusText = res.statusText;\n            if (res.ok) {\n                if (this.method !== \"HEAD\") {\n                    const body = await res.text();\n                    if (body === \"\") {\n                    // Prefer: return=minimal\n                    } else if (this.headers[\"Accept\"] === \"text/csv\") {\n                        data = body;\n                    } else if (this.headers[\"Accept\"] && this.headers[\"Accept\"].includes(\"application/vnd.pgrst.plan+text\")) {\n                        data = body;\n                    } else {\n                        data = JSON.parse(body);\n                    }\n                }\n                const countHeader = (_a = this.headers[\"Prefer\"]) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_b = res.headers.get(\"content-range\")) === null || _b === void 0 ? void 0 : _b.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n                if (this.isMaybeSingle && this.method === \"GET\" && Array.isArray(data)) {\n                    if (data.length > 1) {\n                        error = {\n                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n                            code: \"PGRST116\",\n                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                            hint: null,\n                            message: \"JSON object requested, multiple (or no) rows returned\"\n                        };\n                        data = null;\n                        count = null;\n                        status = 406;\n                        statusText = \"Not Acceptable\";\n                    } else if (data.length === 1) {\n                        data = data[0];\n                    } else {\n                        data = null;\n                    }\n                }\n            } else {\n                const body = await res.text();\n                try {\n                    error = JSON.parse(body);\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (Array.isArray(error) && res.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_d) {\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (res.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else {\n                        error = {\n                            message: body\n                        };\n                    }\n                }\n                if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && this.shouldThrowOnError) {\n                    throw new PostgrestError_1.default(error);\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n            return postgrestResponse;\n        });\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError)=>{\n                var _a, _b, _c;\n                return {\n                    error: {\n                        message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                        details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : \"\"}`,\n                        hint: \"\",\n                        code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : \"\"}`\n                    },\n                    data: null,\n                    count: null,\n                    status: 0,\n                    statusText: \"\"\n                };\n            });\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n     * Override the type of the returned `data` field in the response.\n     *\n     * @typeParam NewResult - The new type to cast the response data to\n     * @typeParam Options - Optional type configuration (defaults to { merge: true })\n     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n     * @example\n     * ```typescript\n     * // Merge with existing types (default behavior)\n     * const query = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ custom_field: string }>()\n     *\n     * // Replace existing types completely\n     * const replaceQuery = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n     * ```\n     * @returns A PostgrestBuilder instance with the new type\n     */ overrideTypes() {\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestBuilder; //# sourceMappingURL=PostgrestBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxhQUFhO0FBQ2IsTUFBTUMsZUFBZVAsZ0JBQWdCUSxtQkFBT0EsQ0FBQyxvRkFBc0I7QUFDbkUsTUFBTUMsbUJBQW1CVCxnQkFBZ0JRLG1CQUFPQSxDQUFDLGdHQUFrQjtBQUNuRSxNQUFNRTtJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNDLE1BQU0sR0FBR0YsUUFBUUUsTUFBTTtRQUM1QixJQUFJLENBQUNDLEdBQUcsR0FBR0gsUUFBUUcsR0FBRztRQUN0QixJQUFJLENBQUNDLE9BQU8sR0FBR0osUUFBUUksT0FBTztRQUM5QixJQUFJLENBQUNDLE1BQU0sR0FBR0wsUUFBUUssTUFBTTtRQUM1QixJQUFJLENBQUNDLElBQUksR0FBR04sUUFBUU0sSUFBSTtRQUN4QixJQUFJLENBQUNMLGtCQUFrQixHQUFHRCxRQUFRQyxrQkFBa0I7UUFDcEQsSUFBSSxDQUFDTSxNQUFNLEdBQUdQLFFBQVFPLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxhQUFhLEdBQUdSLFFBQVFRLGFBQWE7UUFDMUMsSUFBSVIsUUFBUVMsS0FBSyxFQUFFO1lBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdULFFBQVFTLEtBQUs7UUFDOUIsT0FDSyxJQUFJLE9BQU9BLFVBQVUsYUFBYTtZQUNuQyxJQUFJLENBQUNBLEtBQUssR0FBR2QsYUFBYWUsT0FBTztRQUNyQyxPQUNL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LFFBQVE7b0JBQ1JDLFlBQVk7Z0JBQ2hCO1lBQ0o7UUFDSjtRQUNBLE9BQU9YLElBQUlOLElBQUksQ0FBQ0MsYUFBYUM7SUFDakM7SUFDQTs7Ozs7S0FLQyxHQUNEcUMsVUFBVTtRQUNOLHdCQUF3QixHQUN4QixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDREMsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUNBOUQsa0JBQWUsR0FBR0ssa0JBQ2xCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEJ1aWxkZXIuanM/MjI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHN1cGFiYXNlL25vZGUtZmV0Y2hcIikpO1xuY29uc3QgUG9zdGdyZXN0RXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RFcnJvclwiKSk7XG5jbGFzcyBQb3N0Z3Jlc3RCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0aG9kID0gYnVpbGRlci5tZXRob2Q7XG4gICAgICAgIHRoaXMudXJsID0gYnVpbGRlci51cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGJ1aWxkZXIuaGVhZGVycztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBidWlsZGVyLnNjaGVtYTtcbiAgICAgICAgdGhpcy5ib2R5ID0gYnVpbGRlci5ib2R5O1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGJ1aWxkZXIuc2hvdWxkVGhyb3dPbkVycm9yO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGU7XG4gICAgICAgIGlmIChidWlsZGVyLmZldGNoKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gYnVpbGRlci5mZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gbm9kZV9mZXRjaF8xLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUncyBhbiBlcnJvciB3aXRoIHRoZSBxdWVyeSwgdGhyb3dPbkVycm9yIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlIGJ5XG4gICAgICogdGhyb3dpbmcgdGhlIGVycm9yIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGFzIHBhcnQgb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS1qcy9pc3N1ZXMvOTJ9XG4gICAgICovXG4gICAgdGhyb3dPbkVycm9yKCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYW4gSFRUUCBoZWFkZXIgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgICAgICB0aGlzLmhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNzd2l0Y2hpbmctc2NoZW1hc1xuICAgICAgICBpZiAodGhpcy5zY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2tpcFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFsnR0VUJywgJ0hFQUQnXS5pbmNsdWRlcyh0aGlzLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVByb2ZpbGUnXSA9IHRoaXMuc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBOT1RFOiBJbnZva2Ugdy9vIGB0aGlzYCB0byBhdm9pZCBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3IuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvcHVsbC8yNDdcbiAgICAgICAgY29uc3QgX2ZldGNoID0gdGhpcy5mZXRjaDtcbiAgICAgICAgbGV0IHJlcyA9IF9mZXRjaCh0aGlzLnVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodGhpcy5ib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy5zaWduYWwsXG4gICAgICAgIH0pLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBzdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgbGV0IHN0YXR1c1RleHQgPSByZXMuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXI6IHJldHVybj1taW5pbWFsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzWydBY2NlcHQnXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXS5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLnBncnN0LnBsYW4rdGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gKF9hID0gdGhpcy5oZWFkZXJzWydQcmVmZXInXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hdGNoKC9jb3VudD0oZXhhY3R8cGxhbm5lZHxlc3RpbWF0ZWQpLyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFJhbmdlID0gKF9iID0gcmVzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudEhlYWRlciAmJiBjb250ZW50UmFuZ2UgJiYgY29udGVudFJhbmdlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBwYXJzZUludChjb250ZW50UmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAgICAgICAgIC8vIElzc3VlIHBlcnNpc3RzIGUuZy4gZm9yIGAuaW5zZXJ0KFsuLi5dKS5zZWxlY3QoKS5tYXliZVNpbmdsZSgpYFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWF5YmVTaW5nbGUgJiYgdGhpcy5tZXRob2QgPT09ICdHRVQnICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Bvc3RnUkVTVC9wb3N0Z3Jlc3QvYmxvYi9hODY3ZDc5YzQyNDE5YWYxNmMxOGMzZmIwMTllYmE4ZGY5OTI2MjZmL3NyYy9Qb3N0Z1JFU1QvRXJyb3IuaHMjTDU1M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICdQR1JTVDExNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3VsdHMgY29udGFpbiAke2RhdGEubGVuZ3RofSByb3dzLCBhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24gcmVxdWlyZXMgMSByb3dgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0pTT04gb2JqZWN0IHJlcXVlc3RlZCwgbXVsdGlwbGUgKG9yIG5vKSByb3dzIHJldHVybmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDQwNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnTm90IEFjY2VwdGFibGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpICYmIHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzI5NVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0ICYmIGJvZHkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vIENvbnRlbnQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuaXNNYXliZVNpbmdsZSAmJiAoKF9jID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbmNsdWRlcygnMCByb3dzJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ09LJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcl8xLmRlZmF1bHQoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzdFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RncmVzdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgcmVzID0gcmVzLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHsoX2EgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ0ZldGNoRXJyb3InfTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYCR7KF9iID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLnN0YWNrKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJ31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGludDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBgJHsoX2MgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IuY29kZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyd9YCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogJycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgLlxuICAgICAqXG4gICAgICogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHJlc3VsdCB0eXBlIHRvIG92ZXJyaWRlIHdpdGhcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Ugb3ZlcnJpZGVUeXBlczx5b3VyVHlwZSwgeyBtZXJnZTogZmFsc2UgfT4oKSBtZXRob2QgYXQgdGhlIGVuZCBvZiB5b3VyIGNhbGwgY2hhaW4gaW5zdGVhZFxuICAgICAqL1xuICAgIHJldHVybnMoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGUgdHlwZSBvZiB0aGUgcmV0dXJuZWQgYGRhdGFgIGZpZWxkIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyB0eXBlIHRvIGNhc3QgdGhlIHJlc3BvbnNlIGRhdGEgdG9cbiAgICAgKiBAdHlwZVBhcmFtIE9wdGlvbnMgLSBPcHRpb25hbCB0eXBlIGNvbmZpZ3VyYXRpb24gKGRlZmF1bHRzIHRvIHsgbWVyZ2U6IHRydWUgfSlcbiAgICAgKiBAdHlwZVBhcmFtIE9wdGlvbnMubWVyZ2UgLSBXaGVuIHRydWUsIG1lcmdlcyB0aGUgbmV3IHR5cGUgd2l0aCBleGlzdGluZyByZXR1cm4gdHlwZS4gV2hlbiBmYWxzZSwgcmVwbGFjZXMgdGhlIGV4aXN0aW5nIHR5cGVzIGVudGlyZWx5IChkZWZhdWx0cyB0byB0cnVlKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIE1lcmdlIHdpdGggZXhpc3RpbmcgdHlwZXMgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICogY29uc3QgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAqICAgLmZyb20oJ3VzZXJzJylcbiAgICAgKiAgIC5zZWxlY3QoKVxuICAgICAqICAgLm92ZXJyaWRlVHlwZXM8eyBjdXN0b21fZmllbGQ6IHN0cmluZyB9PigpXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGV4aXN0aW5nIHR5cGVzIGNvbXBsZXRlbHlcbiAgICAgKiBjb25zdCByZXBsYWNlUXVlcnkgPSBzdXBhYmFzZVxuICAgICAqICAgLmZyb20oJ3VzZXJzJylcbiAgICAgKiAgIC5zZWxlY3QoKVxuICAgICAqICAgLm92ZXJyaWRlVHlwZXM8eyBpZDogbnVtYmVyOyBuYW1lOiBzdHJpbmcgfSwgeyBtZXJnZTogZmFsc2UgfT4oKVxuICAgICAqIGBgYFxuICAgICAqIEByZXR1cm5zIEEgUG9zdGdyZXN0QnVpbGRlciBpbnN0YW5jZSB3aXRoIHRoZSBuZXcgdHlwZVxuICAgICAqL1xuICAgIG92ZXJyaWRlVHlwZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzdEJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub2RlX2ZldGNoXzEiLCJyZXF1aXJlIiwiUG9zdGdyZXN0RXJyb3JfMSIsIlBvc3RncmVzdEJ1aWxkZXIiLCJjb25zdHJ1Y3RvciIsImJ1aWxkZXIiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJtZXRob2QiLCJ1cmwiLCJoZWFkZXJzIiwic2NoZW1hIiwiYm9keSIsInNpZ25hbCIsImlzTWF5YmVTaW5nbGUiLCJmZXRjaCIsImRlZmF1bHQiLCJ0aHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJuYW1lIiwiYXNzaWduIiwidGhlbiIsIm9uZnVsZmlsbGVkIiwib25yZWplY3RlZCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwiX2ZldGNoIiwicmVzIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiX2EiLCJfYiIsIl9jIiwiZXJyb3IiLCJkYXRhIiwiY291bnQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwib2siLCJ0ZXh0IiwicGFyc2UiLCJjb3VudEhlYWRlciIsIm1hdGNoIiwiY29udGVudFJhbmdlIiwiZ2V0Iiwic3BsaXQiLCJsZW5ndGgiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsImNvZGUiLCJkZXRhaWxzIiwiaGludCIsIm1lc3NhZ2UiLCJfZCIsInBvc3RncmVzdFJlc3BvbnNlIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwic3RhY2siLCJyZXR1cm5zIiwib3ZlcnJpZGVUeXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js\");\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */ class PostgrestClient {\n    // TODO: Add back shouldThrowOnError once we figure out the typings\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url - URL of the PostgREST endpoint\n     * @param options - Named parameters\n     * @param options.headers - Custom headers\n     * @param options.schema - Postgres schema to switch to\n     * @param options.fetch - Custom fetch\n     */ constructor(url, { headers = {}, schema, fetch } = {}){\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);\n        this.schemaName = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */ from(relation) {\n        const url = new URL(`${this.url}/${relation}`);\n        return new PostgrestQueryBuilder_1.default(url, {\n            headers: Object.assign({}, this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args)// params with undefined value needs to be filtered out, otherwise it'll\n            // show up as `?param=undefined`\n            .filter(([_, value])=>value !== undefined)// array values need special syntax\n            .map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = Object.assign({}, this.headers);\n        if (count) {\n            headers[\"Prefer\"] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n}\nexports[\"default\"] = PostgrestClient; //# sourceMappingURL=PostgrestClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLDBCQUEwQlAsZ0JBQWdCUSxtQkFBT0EsQ0FBQyw4R0FBeUI7QUFDakYsTUFBTUMsMkJBQTJCVCxnQkFBZ0JRLG1CQUFPQSxDQUFDLGdIQUEwQjtBQUNuRixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxzRkFBYTtBQUN6Qzs7Ozs7Ozs7O0NBU0MsR0FDRCxNQUFNRztJQUNGLG1FQUFtRTtJQUNuRTs7Ozs7Ozs7S0FRQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUNwRCxJQUFJLENBQUNILEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBR1gsT0FBT2MsTUFBTSxDQUFDZCxPQUFPYyxNQUFNLENBQUMsQ0FBQyxHQUFHUCxZQUFZUSxlQUFlLEdBQUdKO1FBQzdFLElBQUksQ0FBQ0ssVUFBVSxHQUFHSjtRQUNsQixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFDQTs7OztLQUlDLEdBQ0RJLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1SLE1BQU0sSUFBSVMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDVCxHQUFHLENBQUMsQ0FBQyxFQUFFUSxTQUFTLENBQUM7UUFDN0MsT0FBTyxJQUFJZCx3QkFBd0JnQixPQUFPLENBQUNWLEtBQUs7WUFDNUNDLFNBQVNYLE9BQU9jLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDSCxPQUFPO1lBQ3ZDQyxRQUFRLElBQUksQ0FBQ0ksVUFBVTtZQUN2QkgsT0FBTyxJQUFJLENBQUNBLEtBQUs7UUFDckI7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNERCxPQUFPQSxNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUlKLGdCQUFnQixJQUFJLENBQUNFLEdBQUcsRUFBRTtZQUNqQ0MsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJDO1lBQ0FDLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1FBQ3JCO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNCQyxHQUNEUSxJQUFJQyxFQUFFLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBRUMsT0FBTyxLQUFLLEVBQUVDLE1BQU0sS0FBSyxFQUFFQyxLQUFLLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUMzRCxJQUFJQztRQUNKLE1BQU1qQixNQUFNLElBQUlTLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQ1QsR0FBRyxDQUFDLEtBQUssRUFBRVksR0FBRyxDQUFDO1FBQzNDLElBQUlNO1FBQ0osSUFBSUosUUFBUUMsS0FBSztZQUNiRSxTQUFTSCxPQUFPLFNBQVM7WUFDekJ4QixPQUFPNkIsT0FBTyxDQUFDTixLQUNYLHdFQUF3RTtZQUN4RSxnQ0FBZ0M7YUFDL0JPLE1BQU0sQ0FBQyxDQUFDLENBQUNDLEdBQUc1QixNQUFNLEdBQUtBLFVBQVU2QixVQUNsQyxtQ0FBbUM7YUFDbENDLEdBQUcsQ0FBQyxDQUFDLENBQUNDLE1BQU0vQixNQUFNLEdBQUs7b0JBQUMrQjtvQkFBTUMsTUFBTUMsT0FBTyxDQUFDakMsU0FBUyxDQUFDLENBQUMsRUFBRUEsTUFBTWtDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRWxDLE1BQU0sQ0FBQztpQkFBQyxFQUN6Rm1DLE9BQU8sQ0FBQyxDQUFDLENBQUNKLE1BQU0vQixNQUFNO2dCQUN2Qk8sSUFBSTZCLFlBQVksQ0FBQ0MsTUFBTSxDQUFDTixNQUFNL0I7WUFDbEM7UUFDSixPQUNLO1lBQ0R3QixTQUFTO1lBQ1RDLE9BQU9MO1FBQ1g7UUFDQSxNQUFNWixVQUFVWCxPQUFPYyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ0gsT0FBTztRQUM5QyxJQUFJZSxPQUFPO1lBQ1BmLE9BQU8sQ0FBQyxTQUFTLEdBQUcsQ0FBQyxNQUFNLEVBQUVlLE1BQU0sQ0FBQztRQUN4QztRQUNBLE9BQU8sSUFBSXBCLHlCQUF5QmMsT0FBTyxDQUFDO1lBQ3hDTztZQUNBakI7WUFDQUM7WUFDQUMsUUFBUSxJQUFJLENBQUNJLFVBQVU7WUFDdkJZO1lBQ0FmLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCNEIsWUFBWTtRQUNoQjtJQUNKO0FBQ0o7QUFDQXZDLGtCQUFlLEdBQUdNLGlCQUNsQiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RDbGllbnQuanM/ZTY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogUG9zdGdSRVNUIGNsaWVudC5cbiAqXG4gKiBAdHlwZVBhcmFtIERhdGFiYXNlIC0gVHlwZXMgZm9yIHRoZSBzY2hlbWEgZnJvbSB0aGUgW3R5cGVcbiAqIGdlbmVyYXRvcl0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9yZWZlcmVuY2UvamF2YXNjcmlwdC9uZXh0L3R5cGVzY3JpcHQtc3VwcG9ydClcbiAqXG4gKiBAdHlwZVBhcmFtIFNjaGVtYU5hbWUgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvLiBNdXN0IGJlIGEgc3RyaW5nXG4gKiBsaXRlcmFsLCB0aGUgc2FtZSBvbmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gSWYgdGhlIHNjaGVtYSBpcyBub3RcbiAqIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuICovXG5jbGFzcyBQb3N0Z3Jlc3RDbGllbnQge1xuICAgIC8vIFRPRE86IEFkZCBiYWNrIHNob3VsZFRocm93T25FcnJvciBvbmNlIHdlIGZpZ3VyZSBvdXQgdGhlIHR5cGluZ3NcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUG9zdGdSRVNUIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIEN1c3RvbSBmZXRjaFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2gsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25zdGFudHNfMS5ERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFOYW1lID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCh1cmwsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuICAgICAqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcbiAgICAgKiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuICAgICAqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICAgIHJwYyhmbiwgYXJncyA9IHt9LCB7IGhlYWQgPSBmYWxzZSwgZ2V0ID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAoaGVhZCB8fCBnZXQpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGhlYWQgPyAnSEVBRCcgOiAnR0VUJztcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zIHdpdGggdW5kZWZpbmVkIHZhbHVlIG5lZWRzIHRvIGJlIGZpbHRlcmVkIG91dCwgb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgICAgICAgICAgLy8gc2hvdyB1cCBhcyBgP3BhcmFtPXVuZGVmaW5lZGBcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIC8vIGFycmF5IHZhbHVlcyBuZWVkIHNwZWNpYWwgc3ludGF4XG4gICAgICAgICAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gW25hbWUsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYHske3ZhbHVlLmpvaW4oJywnKX19YCA6IGAke3ZhbHVlfWBdKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBib2R5ID0gYXJncztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBoZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYU5hbWUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0Q2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMSIsInJlcXVpcmUiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEiLCJjb25zdGFudHNfMSIsIlBvc3RncmVzdENsaWVudCIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsInNjaGVtYSIsImZldGNoIiwiYXNzaWduIiwiREVGQVVMVF9IRUFERVJTIiwic2NoZW1hTmFtZSIsImZyb20iLCJyZWxhdGlvbiIsIlVSTCIsImRlZmF1bHQiLCJycGMiLCJmbiIsImFyZ3MiLCJoZWFkIiwiZ2V0IiwiY291bnQiLCJtZXRob2QiLCJib2R5IiwiZW50cmllcyIsImZpbHRlciIsIl8iLCJ1bmRlZmluZWQiLCJtYXAiLCJuYW1lIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsImZvckVhY2giLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJhbGxvd0VtcHR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */ class PostgrestError extends Error {\n    constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n}\nexports[\"default\"] = PostgrestError; //# sourceMappingURL=PostgrestError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RDs7OztDQUlDLEdBQ0QsTUFBTUMsdUJBQXVCQztJQUN6QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsUUFBUUMsT0FBTztRQUNyQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHSCxRQUFRRyxPQUFPO1FBQzlCLElBQUksQ0FBQ0MsSUFBSSxHQUFHSixRQUFRSSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHTCxRQUFRSyxJQUFJO0lBQzVCO0FBQ0o7QUFDQVYsa0JBQWUsR0FBR0UsZ0JBQ2xCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEVycm9yLmpzPzEzZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dC5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJztcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuICAgICAgICB0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEVycm9yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvc3RncmVzdEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJtZXNzYWdlIiwibmFtZSIsImRldGFpbHMiLCJoaW50IiwiY29kZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === \"string\" && new RegExp(\"[,()]\").test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */ contains(column, value) {\n        if (typeof value === \"string\") {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        } else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        } else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */ containedBy(column, value) {\n        if (typeof value === \"string\") {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        } else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        } else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */ overlaps(column, value) {\n        if (typeof value === \"string\") {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        } else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") {\n            typePart = \"pl\";\n        } else if (type === \"phrase\") {\n            typePart = \"ph\";\n        } else if (type === \"websearch\") {\n            typePart = \"w\";\n        }\n        const configPart = config === undefined ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestFilterBuilder; //# sourceMappingURL=PostgrestFilterBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyw4QkFBOEJQLGdCQUFnQlEsbUJBQU9BLENBQUMsc0hBQTZCO0FBQ3pGLE1BQU1DLCtCQUErQkYsNEJBQTRCRyxPQUFPO0lBQ3BFOzs7Ozs7O0tBT0MsR0FDREMsR0FBR0MsTUFBTSxFQUFFTixLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUNPLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxNQUFNLENBQUNILFFBQVEsQ0FBQyxHQUFHLEVBQUVOLE1BQU0sQ0FBQztRQUNsRCxPQUFPLElBQUk7SUFDZjtJQUNBOzs7OztLQUtDLEdBQ0RVLElBQUlKLE1BQU0sRUFBRU4sS0FBSyxFQUFFO1FBQ2YsSUFBSSxDQUFDTyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsSUFBSSxFQUFFTixNQUFNLENBQUM7UUFDbkQsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7S0FLQyxHQUNEVyxHQUFHTCxNQUFNLEVBQUVOLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQ08sR0FBRyxDQUFDQyxZQUFZLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDLEdBQUcsRUFBRU4sTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDRFksSUFBSU4sTUFBTSxFQUFFTixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNPLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxNQUFNLENBQUNI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Q0FBQ0gsUUFBUSxDQUFDLEdBQUcsRUFBRU4sTUFBTSxDQUFDO1FBQ3REO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRHlELElBQUluRCxNQUFNLEVBQUVvRCxRQUFRLEVBQUUxRCxLQUFLLEVBQUU7UUFDekIsSUFBSSxDQUFDTyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsSUFBSSxFQUFFb0QsU0FBUyxDQUFDLEVBQUUxRCxNQUFNLENBQUM7UUFDL0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7S0FjQyxHQUNEMkQsR0FBR0MsT0FBTyxFQUFFLEVBQUVDLFlBQVksRUFBRUMsa0JBQWtCRCxZQUFZLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNoRSxNQUFNRSxNQUFNRCxrQkFBa0IsQ0FBQyxFQUFFQSxnQkFBZ0IsR0FBRyxDQUFDLEdBQUc7UUFDeEQsSUFBSSxDQUFDdkQsR0FBRyxDQUFDQyxZQUFZLENBQUNDLE1BQU0sQ0FBQ3NELEtBQUssQ0FBQyxDQUFDLEVBQUVILFFBQVEsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0RJLE9BQU8xRCxNQUFNLEVBQUVvRCxRQUFRLEVBQUUxRCxLQUFLLEVBQUU7UUFDNUIsSUFBSSxDQUFDTyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsRUFBRW9ELFNBQVMsQ0FBQyxFQUFFMUQsTUFBTSxDQUFDO1FBQzNELE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQUQsa0JBQWUsR0FBR0ksd0JBQ2xCLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIuanM/MGYxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBuZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZ3QoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBndGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgbHQoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBsdGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgaWxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBpbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGlsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgICAqXG4gICAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgaXMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBpbihjb2x1bW4sIHZhbHVlcykge1xuICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAgICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcG9zdGdyZXN0IHJlc2VydmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7c31cImA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3N9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5zKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbignLCcpfX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGpzb25cbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5lZEJ5KGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqc29uXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VHdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUd0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VMdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUx0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICAgKiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG4gICAgICogcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VBZGphY2VudChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgYWRqLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKCcsJyl9fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICAgKi9cbiAgICB0ZXh0U2VhcmNoKGNvbHVtbiwgcXVlcnksIHsgY29uZmlnLCB0eXBlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdHlwZVBhcnQgPSAnJztcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgICAgICAgIHR5cGVQYXJ0ID0gJ3BsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncGhyYXNlJykge1xuICAgICAgICAgICAgdHlwZVBhcnQgPSAncGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICAgICAgICB0eXBlUGFydCA9ICd3JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWA7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgICAqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgICAqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBtYXRjaChxdWVyeSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICAgKiBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICAgIG5vdChjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgaXQncyBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiByZWZlcmVuY2VkIHRhYmxlc1xuICAgICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG4gICAgICovXG4gICAgb3IoZmlsdGVycywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogJ29yJztcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIGAoJHtmaWx0ZXJzfSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG4gICAgICogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKi9cbiAgICBmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcl8xIiwicmVxdWlyZSIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCJkZWZhdWx0IiwiZXEiLCJjb2x1bW4iLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJuZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibGlrZSIsInBhdHRlcm4iLCJsaWtlQWxsT2YiLCJwYXR0ZXJucyIsImpvaW4iLCJsaWtlQW55T2YiLCJpbGlrZSIsImlsaWtlQWxsT2YiLCJpbGlrZUFueU9mIiwiaXMiLCJpbiIsInZhbHVlcyIsImNsZWFuZWRWYWx1ZXMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJtYXAiLCJzIiwiUmVnRXhwIiwidGVzdCIsImNvbnRhaW5zIiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb250YWluZWRCeSIsInJhbmdlR3QiLCJyYW5nZSIsInJhbmdlR3RlIiwicmFuZ2VMdCIsInJhbmdlTHRlIiwicmFuZ2VBZGphY2VudCIsIm92ZXJsYXBzIiwidGV4dFNlYXJjaCIsInF1ZXJ5IiwiY29uZmlnIiwidHlwZSIsInR5cGVQYXJ0IiwiY29uZmlnUGFydCIsInVuZGVmaW5lZCIsIm1hdGNoIiwiZW50cmllcyIsImZvckVhY2giLCJub3QiLCJvcGVyYXRvciIsIm9yIiwiZmlsdGVycyIsImZvcmVpZ25UYWJsZSIsInJlZmVyZW5jZWRUYWJsZSIsImtleSIsImZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nclass PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ select(columns, { head = false, count } = {}) {\n        const method = head ? \"HEAD\" : \"GET\";\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) {\n                return \"\";\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        if (count) {\n            this.headers[\"Prefer\"] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */ insert(values, { count, defaultToNull = true } = {}) {\n        const method = \"POST\";\n        const prefersHeaders = [];\n        if (this.headers[\"Prefer\"]) {\n            prefersHeaders.push(this.headers[\"Prefer\"]);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push(\"missing=default\");\n        }\n        this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        const method = \"POST\";\n        const prefersHeaders = [\n            `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`\n        ];\n        if (onConflict !== undefined) this.url.searchParams.set(\"on_conflict\", onConflict);\n        if (this.headers[\"Prefer\"]) {\n            prefersHeaders.push(this.headers[\"Prefer\"]);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (!defaultToNull) {\n            prefersHeaders.push(\"missing=default\");\n        }\n        this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ update(values, { count } = {}) {\n        const method = \"PATCH\";\n        const prefersHeaders = [];\n        if (this.headers[\"Prefer\"]) {\n            prefersHeaders.push(this.headers[\"Prefer\"]);\n        }\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ delete({ count } = {}) {\n        const method = \"DELETE\";\n        const prefersHeaders = [];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers[\"Prefer\"]) {\n            prefersHeaders.unshift(this.headers[\"Prefer\"]);\n        }\n        this.headers[\"Prefer\"] = prefersHeaders.join(\",\");\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            allowEmpty: false\n        });\n    }\n}\nexports[\"default\"] = PostgrestQueryBuilder; //# sourceMappingURL=PostgrestQueryBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLDJCQUEyQlAsZ0JBQWdCUSxtQkFBT0EsQ0FBQyxnSEFBMEI7QUFDbkYsTUFBTUM7SUFDRkMsWUFBWUMsR0FBRyxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFHLENBQUU7UUFDL0MsSUFBSSxDQUFDSCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBb0JDLEdBQ0RDLE9BQU9DLE9BQU8sRUFBRSxFQUFFQyxPQUFPLEtBQUssRUFBRUMsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDM0MsTUFBTUMsU0FBU0YsT0FBTyxTQUFTO1FBQy9CLHdDQUF3QztRQUN4QyxJQUFJRyxTQUFTO1FBQ2IsTUFBTUMsaUJBQWlCLENBQUNMLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVUsR0FBRSxFQUN4RU0sS0FBSyxDQUFDLElBQ05DLEdBQUcsQ0FBQyxDQUFDQztZQUNOLElBQUksS0FBS0MsSUFBSSxDQUFDRCxNQUFNLENBQUNKLFFBQVE7Z0JBQ3pCLE9BQU87WUFDWDtZQUNBLElBQUlJLE1BQU0sS0FBSztnQkFDWEosU0FBUyxDQUFDQTtZQUNkO1lBQ0EsT0FB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cHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcz8yNWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQ29sdW1ucyBjYW4gYmUgcmVuYW1lZCB3aGVuIHJldHVybmVkIHdpdGggYGN1c3RvbU5hbWU6Y29sdW1uTmFtZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBzZWxlY3QoY29sdW1ucywgeyBoZWFkID0gZmFsc2UsIGNvdW50LCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnO1xuICAgICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gIXF1b3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IGBjb3VudD0ke2NvdW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuICAgICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG4gICAgICogaW5zZXJ0cy5cbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWVzLCB7IGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAgICogdG8gYG9uQ29uZmxpY3RgLCBgLnVwc2VydCgpYCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAgICogYGlnbm9yZUR1cGxpY2F0ZXNgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgICAqIHNpbmdsZSByb3cgb3IgYW4gYXJyYXkgdG8gdXBzZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAgICogYG9uQ29uZmxpY3RgIGNvbHVtbnMgYXJlIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAgICogYGZhbHNlYCwgZHVwbGljYXRlIHJvd3MgYXJlIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgICAqIGluc2VydGluZyBuZXcgcm93cywgbm90IHdoZW4gbWVyZ2luZyB3aXRoIGV4aXN0aW5nIHJvd3MgdW5kZXJcbiAgICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgICAqL1xuICAgIHVwc2VydCh2YWx1ZXMsIHsgb25Db25mbGljdCwgaWdub3JlRHVwbGljYXRlcyA9IGZhbHNlLCBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW2ByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJ30tZHVwbGljYXRlc2BdO1xuICAgICAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHByZWZlcnNIZWFkZXJzLnB1c2godGhpcy5oZWFkZXJzWydQcmVmZXInXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaCgnbWlzc2luZz1kZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzWydQcmVmZXInXSA9IHByZWZlcnNIZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuICAgICAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbHVtbnMnLCB1bmlxdWVDb2x1bW5zLmpvaW4oJywnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgYWxsb3dFbXB0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlcywgeyBjb3VudCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XG4gICAgICAgIGNvbnN0IHByZWZlcnNIZWFkZXJzID0gW107XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgcHJlZmVyc0hlYWRlcnMucHVzaChgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gcHJlZmVyc0hlYWRlcnMuam9pbignLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBhbGxvd0VtcHR5OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgZGVsZXRlKHsgY291bnQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcHJlZmVyc0hlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy5wdXNoKGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSB7XG4gICAgICAgICAgICBwcmVmZXJzSGVhZGVycy51bnNoaWZ0KHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gPSBwcmVmZXJzSGVhZGVycy5qb2luKCcsJyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMSIsInJlcXVpcmUiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJzY2hlbWEiLCJmZXRjaCIsInNlbGVjdCIsImNvbHVtbnMiLCJoZWFkIiwiY291bnQiLCJtZXRob2QiLCJxdW90ZWQiLCJjbGVhbmVkQ29sdW1ucyIsInNwbGl0IiwibWFwIiwiYyIsInRlc3QiLCJqb2luIiwic2VhcmNoUGFyYW1zIiwic2V0IiwiZGVmYXVsdCIsImFsbG93RW1wdHkiLCJpbnNlcnQiLCJ2YWx1ZXMiLCJkZWZhdWx0VG9OdWxsIiwicHJlZmVyc0hlYWRlcnMiLCJwdXNoIiwiQXJyYXkiLCJpc0FycmF5IiwicmVkdWNlIiwiYWNjIiwieCIsImNvbmNhdCIsImtleXMiLCJsZW5ndGgiLCJ1bmlxdWVDb2x1bW5zIiwiU2V0IiwiY29sdW1uIiwiYm9keSIsInVwc2VydCIsIm9uQ29uZmxpY3QiLCJpZ25vcmVEdXBsaWNhdGVzIiwidW5kZWZpbmVkIiwidXBkYXRlIiwiZGVsZXRlIiwidW5zaGlmdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */ select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) {\n                return \"\";\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        if (this.headers[\"Prefer\"]) {\n            this.headers[\"Prefer\"] += \",\";\n        }\n        this.headers[\"Prefer\"] += \"return=representation\";\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order referenced tables, but it only affects the ordering of the\n     * parent table if you use `!inner` in the query.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.referencedTable - Set this to order a referenced table by\n     * its columns\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === undefined ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */ single() {\n        this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */ maybeSingle() {\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.method === \"GET\") {\n            this.headers[\"Accept\"] = \"application/json\";\n        } else {\n            this.headers[\"Accept\"] = \"application/vnd.pgrst.object+json\";\n        }\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */ csv() {\n        this.headers[\"Accept\"] = \"text/csv\";\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */ geojson() {\n        this.headers[\"Accept\"] = \"application/geo+json\";\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * You need to enable the\n     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n     * setting before using this method.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _a;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = (_a = this.headers[\"Accept\"]) !== null && _a !== void 0 ? _a : \"application/json\";\n        this.headers[\"Accept\"] = `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`;\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */ rollback() {\n        var _a;\n        if (((_a = this.headers[\"Prefer\"]) !== null && _a !== void 0 ? _a : \"\").trim().length > 0) {\n            this.headers[\"Prefer\"] += \",tx=rollback\";\n        } else {\n            this.headers[\"Prefer\"] = \"tx=rollback\";\n        }\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */ returns() {\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestTransformBuilder; //# sourceMappingURL=PostgrestTransformBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxxQkFBcUJQLGdCQUFnQlEsbUJBQU9BLENBQUMsb0dBQW9CO0FBQ3ZFLE1BQU1DLGtDQUFrQ0YsbUJBQW1CRyxPQUFPO0lBQzlEOzs7Ozs7OztLQVFDLEdBQ0RDLE9BQU9DLE9BQU8sRUFBRTtRQUNaLHdDQUF3QztRQUN4QyxJQUFJQyxTQUFTO1FBQ2IsTUFBTUMsaUJBQWlCLENBQUNGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVUsR0FBRSxFQUN4RUcsS0FBSyxDQUFDLElBQ05DLEdBQUcsQ0FBQyxDQUFDQztZQUNOLElBQUksS0FBS0MsSUFBSSxDQUFDRCxNQUFNLENBQUNKLFFBQVE7Z0JBQ3pCLE9BQU87WUFDWDtZQUNBLElBQUlJLE1BQU0sS0FBSztnQkFDWEosU0FBUyxDQUFDQTtZQUNkO1lBQ0EsT0FBT0k7UUFDWCxHQUNLRSxJQUFJLENBQUM7UUFDVixJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsVUFBVVI7UUFDcEMsSUFBSSxJQUFJLENBQUNTLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDeEIsSUFBSSxDQUFDQSxPQUFPLENBQUMsU0FBUyxJQUFJO1FBQzlCO1FBQ0EsSUFBSSxDQUFDQSxPQUFPLENBQUMsU0FBUyxJQUFJO1FBQzFCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0RDLE1BQU1D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RUMsTUFBTSxLQUFLLEVBQUVDLFNBQVMsTUFBTSxFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDakgsSUFBSUM7UUFDSixNQUFNQyxVQUFVO1lBQ1pQLFVBQVUsWUFBWTtZQUN0QkMsVUFBVSxZQUFZO1lBQ3RCQyxXQUFXLGFBQWE7WUFDeEJDLFVBQVUsWUFBWTtZQUN0QkMsTUFBTSxRQUFRO1NBQ2pCLENBQ0lJLE1BQU0sQ0FBQ0MsU0FDUHhDLElBQUksQ0FBQztRQUNWLG9GQUFvRjtRQUNwRixNQUFNeUMsZUFBZSxDQUFDSixLQUFLLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQyxTQUFTLE1BQU0sUUFBUWlDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3BGLElBQUksQ0FBQ2pDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsQ0FBQywyQkFBMkIsRUFBRWdDLE9BQU8sT0FBTyxFQUFFSyxhQUFhLFdBQVcsRUFBRUgsUUFBUSxDQUFDLENBQUM7UUFDM0csSUFBSUYsV0FBVyxRQUNYLE9BQU8sSUFBSTthQUVYLE9BQU8sSUFBSTtJQUNuQjtJQUNBOzs7O0tBSUMsR0FDRE0sV0FBVztRQUNQLElBQUlMO1FBQ0osSUFBSSxDQUFDLENBQUNBLEtBQUssSUFBSSxDQUFDakMsT0FBTyxDQUFDLFNBQVMsTUFBTSxRQUFRaUMsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBQyxFQUFHTSxJQUFJLEdBQUdDLE1BQU0sR0FBRyxHQUFHO1lBQ3ZGLElBQUksQ0FBQ3hDLE9BQU8sQ0FBQyxTQUFTLElBQUk7UUFDOUIsT0FDSztZQUNELElBQUksQ0FBQ0EsT0FBTyxDQUFDLFNBQVMsR0FBRztRQUM3QjtRQUNBLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDRHlDLFVBQVU7UUFDTixPQUFPLElBQUk7SUFDZjtBQUNKO0FBQ0EzRCxrQkFBZSxHQUFHSSwyQkFDbEIscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcz81ZjMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAgICogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG4gICAgICogYGRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqL1xuICAgIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICAgICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiAnKicpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1snUHJlZmVyJ10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJywnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJ3JldHVybj1yZXByZXNlbnRhdGlvbic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcmRlciB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb2x1bW5gLlxuICAgICAqXG4gICAgICogWW91IGNhbiBjYWxsIHRoaXMgbWV0aG9kIG11bHRpcGxlIHRpbWVzIHRvIG9yZGVyIGJ5IG11bHRpcGxlIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9yZGVyIHJlZmVyZW5jZWQgdGFibGVzLCBidXQgaXQgb25seSBhZmZlY3RzIHRoZSBvcmRlcmluZyBvZiB0aGVcbiAgICAgKiBwYXJlbnQgdGFibGUgaWYgeW91IHVzZSBgIWlubmVyYCBpbiB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBvcmRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzY2VuZGluZyAtIElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLm51bGxzRmlyc3QgLSBJZiBgdHJ1ZWAsIGBudWxsYHMgYXBwZWFyIGZpcnN0LiBJZiBgZmFsc2VgLFxuICAgICAqIGBudWxsYHMgYXBwZWFyIGxhc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gb3JkZXIgYSByZWZlcmVuY2VkIHRhYmxlIGJ5XG4gICAgICogaXRzIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgICAqIGluc3RlYWRcbiAgICAgKi9cbiAgICBvcmRlcihjb2x1bW4sIHsgYXNjZW5kaW5nID0gdHJ1ZSwgbnVsbHNGaXJzdCwgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yZGVyYCA6ICdvcmRlcic7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nT3JkZXIgPSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBgJHtleGlzdGluZ09yZGVyID8gYCR7ZXhpc3RpbmdPcmRlcn0sYCA6ICcnfSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/ICdhc2MnIDogJ2Rlc2MnfSR7bnVsbHNGaXJzdCA9PT0gdW5kZWZpbmVkID8gJycgOiBudWxsc0ZpcnN0ID8gJy5udWxsc2ZpcnN0JyA6ICcubnVsbHNsYXN0J31gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvdW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRvIHJldHVyblxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuICAgICAqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuICAgICAqIGluc3RlYWRcbiAgICAgKi9cbiAgICBsaW1pdChjb3VudCwgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7Y291bnR9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IHN0YXJ0aW5nIGF0IGFuIG9mZnNldCBgZnJvbWAgYW5kIGVuZGluZyBhdCB0aGUgb2Zmc2V0IGB0b2AuXG4gICAgICogT25seSByZWNvcmRzIHdpdGhpbiB0aGlzIHJhbmdlIGFyZSByZXR1cm5lZC5cbiAgICAgKiBUaGlzIHJlc3BlY3RzIHRoZSBxdWVyeSBvcmRlciBhbmQgaWYgdGhlcmUgaXMgbm8gb3JkZXIgY2xhdXNlIHRoZSByYW5nZSBjb3VsZCBiZWhhdmUgdW5leHBlY3RlZGx5LlxuICAgICAqIFRoZSBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzIGFyZSAwLWJhc2VkIGFuZCBpbmNsdXNpdmU6IGByYW5nZSgxLCAzKWAgd2lsbCBpbmNsdWRlIHRoZSBzZWNvbmQsIHRoaXJkXG4gICAgICogYW5kIGZvdXJ0aCByb3dzIG9mIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4IGZyb20gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSB0byAtIFRoZSBsYXN0IGluZGV4IHRvIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8sIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlPZmZzZXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdvZmZzZXQnIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5vZmZzZXRgO1xuICAgICAgICBjb25zdCBrZXlMaW1pdCA9IHR5cGVvZiByZWZlcmVuY2VkVGFibGUgPT09ICd1bmRlZmluZWQnID8gJ2xpbWl0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ubGltaXRgO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleU9mZnNldCwgYCR7ZnJvbX1gKTtcbiAgICAgICAgLy8gUmFuZ2UgaXMgaW5jbHVzaXZlLCBzbyBhZGQgMVxuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleUxpbWl0LCBgJHt0byAtIGZyb20gKyAxfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBBYm9ydFNpZ25hbCBmb3IgdGhlIGZldGNoIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmFsIC0gVGhlIEFib3J0U2lnbmFsIHRvIHVzZSBmb3IgdGhlIGZldGNoIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgICAgICAgdGhpcy5zaWduYWwgPSBzaWduYWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBRdWVyeSByZXN1bHQgbXVzdCBiZSBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlIHRoaXNcbiAgICAgKiByZXR1cm5zIGFuIGVycm9yLlxuICAgICAqL1xuICAgIHNpbmdsZSgpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgemVybyBvciBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlXG4gICAgICogdGhpcyByZXR1cm5zIGFuIGVycm9yLlxuICAgICAqL1xuICAgIG1heWJlU2luZ2xlKCkge1xuICAgICAgICAvLyBUZW1wb3JhcnkgcGFydGlhbCBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9wb3N0Z3Jlc3QtanMvaXNzdWVzLzM2MVxuICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuICAgICAqL1xuICAgIGNzdigpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydBY2NlcHQnXSA9ICd0ZXh0L2Nzdic7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYGRhdGFgIGFzIGFuIG9iamVjdCBpbiBbR2VvSlNPTl0oaHR0cHM6Ly9nZW9qc29uLm9yZykgZm9ybWF0LlxuICAgICAqL1xuICAgIGdlb2pzb24oKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1snQWNjZXB0J10gPSAnYXBwbGljYXRpb24vZ2VvK2pzb24nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyB0aGUgRVhQTEFJTiBwbGFuIGZvciB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBZb3UgbmVlZCB0byBlbmFibGUgdGhlXG4gICAgICogW2RiX3BsYW5fZW5hYmxlZF0oaHR0cHM6Ly9zdXBhYmFzZS5jb20vZG9jcy9ndWlkZXMvZGF0YWJhc2UvZGVidWdnaW5nLXBlcmZvcm1hbmNlI2VuYWJsaW5nLWV4cGxhaW4pXG4gICAgICogc2V0dGluZyBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFuYWx5emUgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFuZCB0aGVcbiAgICAgKiBhY3R1YWwgcnVuIHRpbWUgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMudmVyYm9zZSAtIElmIGB0cnVlYCwgdGhlIHF1ZXJ5IGlkZW50aWZpZXIgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIGFuZCBgZGF0YWAgd2lsbCBpbmNsdWRlIHRoZSBvdXRwdXQgY29sdW1ucyBvZiB0aGUgcXVlcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldHRpbmdzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBwYXJhbWV0ZXJzIHRoYXQgYWZmZWN0IHF1ZXJ5IHBsYW5uaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5idWZmZXJzIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIGJ1ZmZlciB1c2FnZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMud2FsIC0gSWYgYHRydWVgLCBpbmNsdWRlIGluZm9ybWF0aW9uIG9uIFdBTCByZWNvcmQgZ2VuZXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9ybWF0IC0gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LCBjYW4gYmUgYFwidGV4dFwiYCAoZGVmYXVsdClcbiAgICAgKiBvciBgXCJqc29uXCJgXG4gICAgICovXG4gICAgZXhwbGFpbih7IGFuYWx5emUgPSBmYWxzZSwgdmVyYm9zZSA9IGZhbHNlLCBzZXR0aW5ncyA9IGZhbHNlLCBidWZmZXJzID0gZmFsc2UsIHdhbCA9IGZhbHNlLCBmb3JtYXQgPSAndGV4dCcsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBbXG4gICAgICAgICAgICBhbmFseXplID8gJ2FuYWx5emUnIDogbnVsbCxcbiAgICAgICAgICAgIHZlcmJvc2UgPyAndmVyYm9zZScgOiBudWxsLFxuICAgICAgICAgICAgc2V0dGluZ3MgPyAnc2V0dGluZ3MnIDogbnVsbCxcbiAgICAgICAgICAgIGJ1ZmZlcnMgPyAnYnVmZmVycycgOiBudWxsLFxuICAgICAgICAgICAgd2FsID8gJ3dhbCcgOiBudWxsLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBBbiBBY2NlcHQgaGVhZGVyIGNhbiBjYXJyeSBtdWx0aXBsZSBtZWRpYSB0eXBlcyBidXQgcG9zdGdyZXN0LWpzIGFsd2F5cyBzZW5kcyBvbmVcbiAgICAgICAgY29uc3QgZm9yTWVkaWF0eXBlID0gKF9hID0gdGhpcy5oZWFkZXJzWydBY2NlcHQnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ0FjY2VwdCddID0gYGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5wbGFuKyR7Zm9ybWF0fTsgZm9yPVwiJHtmb3JNZWRpYXR5cGV9XCI7IG9wdGlvbnM9JHtvcHRpb25zfTtgO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnanNvbicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvbGxiYWNrIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIGBkYXRhYCB3aWxsIHN0aWxsIGJlIHJldHVybmVkLCBidXQgdGhlIHF1ZXJ5IGlzIG5vdCBjb21taXR0ZWQuXG4gICAgICovXG4gICAgcm9sbGJhY2soKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmhlYWRlcnNbJ1ByZWZlciddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snUHJlZmVyJ10gKz0gJyx0eD1yb2xsYmFjayc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ1ByZWZlciddID0gJ3R4PXJvbGxiYWNrJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcbiAgICAgKi9cbiAgICByZXR1cm5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9zdGdyZXN0QnVpbGRlcl8xIiwicmVxdWlyZSIsIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCJkZWZhdWx0Iiwic2VsZWN0IiwiY29sdW1ucyIsInF1b3RlZCIsImNsZWFuZWRDb2x1bW5zIiwic3BsaXQiLCJtYXAiLCJjIiwidGVzdCIsImpvaW4iLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJoZWFkZXJzIiwib3JkZXIiLCJjb2x1bW4iLCJhc2NlbmRpbmciLCJudWxsc0ZpcnN0IiwiZm9yZWlnblRhYmxlIiwicmVmZXJlbmNlZFRhYmxlIiwia2V5IiwiZXhpc3RpbmdPcmRlciIsImdldCIsInVuZGVmaW5lZCIsImxpbWl0IiwiY291bnQiLCJyYW5nZSIsImZyb20iLCJ0byIsImtleU9mZnNldCIsImtleUxpbWl0IiwiYWJvcnRTaWduYWwiLCJzaWduYWwiLCJzaW5nbGUiLCJtYXliZVNpbmdsZSIsIm1ldGhvZCIsImlzTWF5YmVTaW5nbGUiLCJjc3YiLCJnZW9qc29uIiwiZXhwbGFpbiIsImFuYWx5emUiLCJ2ZXJib3NlIiwic2V0dGluZ3MiLCJidWZmZXJzIiwid2FsIiwiZm9ybWF0IiwiX2EiLCJvcHRpb25zIiwiZmlsdGVyIiwiQm9vbGVhbiIsImZvck1lZGlhdHlwZSIsInJvbGxiYWNrIiwidHJpbSIsImxlbmd0aCIsInJldHVybnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_HEADERS = void 0;\nconst version_1 = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js\");\nexports.DEFAULT_HEADERS = {\n    \"X-Client-Info\": `postgrest-js/${version_1.version}`\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHLEtBQUs7QUFDL0IsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsa0ZBQVc7QUFDckNKLHVCQUF1QixHQUFHO0lBQUUsaUJBQWlCLENBQUMsYUFBYSxFQUFFRyxVQUFVRSxPQUFPLENBQUMsQ0FBQztBQUFDLEdBQ2pGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2NvbnN0YW50cy5qcz81NTA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0hFQURFUlMgPSB2b2lkIDA7XG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy5ERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHBvc3RncmVzdC1qcy8ke3ZlcnNpb25fMS52ZXJzaW9ufWAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJERUZBVUxUX0hFQURFUlMiLCJ2ZXJzaW9uXzEiLCJyZXF1aXJlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;\n// Always update wrapper.mjs when updating this file.\nconst PostgrestClient_1 = __importDefault(__webpack_require__(/*! ./PostgrestClient */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\"));\nexports.PostgrestClient = PostgrestClient_1.default;\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nexports.PostgrestBuilder = PostgrestBuilder_1.default;\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nexports.PostgrestError = PostgrestError_1.default;\nexports[\"default\"] = {\n    PostgrestClient: PostgrestClient_1.default,\n    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,\n    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,\n    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,\n    PostgrestBuilder: PostgrestBuilder_1.default,\n    PostgrestError: PostgrestError_1.default\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSx3QkFBd0IsR0FBR0EsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSw2QkFBNkIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN4TCxxREFBcUQ7QUFDckQsTUFBTVEsb0JBQW9CYixnQkFBZ0JjLG1CQUFPQSxDQUFDLGtHQUFtQjtBQUNyRVQsdUJBQXVCLEdBQUdRLGtCQUFrQkUsT0FBTztBQUNuRCxNQUFNQywwQkFBMEJoQixnQkFBZ0JjLG1CQUFPQSxDQUFDLDhHQUF5QjtBQUNqRlQsNkJBQTZCLEdBQUdXLHdCQUF3QkQsT0FBTztBQUMvRCxNQUFNRSwyQkFBMkJqQixnQkFBZ0JjLG1CQUFPQSxDQUFDLGdIQUEwQjtBQUNuRlQsOEJBQThCLEdBQUdZLHlCQUF5QkYsT0FBTztBQUNqRSxNQUFNRyw4QkFBOEJsQixnQkFBZ0JjLG1CQUFPQSxDQUFDLHNIQUE2QjtBQUN6RlQsaUNBQWlDLEdBQUdhLDRCQUE0QkgsT0FBTztBQUN2RSxNQUFNSSxxQkFBcUJuQixnQkFBZ0JjLG1CQUFPQSxDQUFDLG9HQUFvQjtBQUN2RVQsd0JBQXdCLEdBQUdjLG1CQUFtQkosT0FBTztBQUNyRCxNQUFNSyxtQkFBbUJwQixnQkFBZ0JjLG1CQUFPQSxDQUFDLGdHQUFrQjtBQUNuRVQsc0JBQXNCLEdBQUdlLGlCQUFpQkwsT0FBTztBQUNqRFYsa0JBQWUsR0FBRztJQUNkTyxpQkFBaUJDLGtCQUFrQkUsT0FBTztJQUMxQ0osdUJBQXVCSyx3QkFBd0JELE9BQU87SUFDdERMLHdCQUF3Qk8seUJBQXlCRixPQUFPO0lBQ3hETiwyQkFBMkJTLDRCQUE0QkgsT0FBTztJQUM5RFAsa0JBQWtCVyxtQkFBbUJKLE9BQU87SUFDNUNSLGdCQUFnQmEsaUJBQWlCTCxPQUFPO0FBQzVDLEdBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvaW5kZXguanM/ZDMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9zdGdyZXN0RXJyb3IgPSBleHBvcnRzLlBvc3RncmVzdEJ1aWxkZXIgPSBleHBvcnRzLlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSBleHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBleHBvcnRzLlBvc3RncmVzdFF1ZXJ5QnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0Q2xpZW50ID0gdm9pZCAwO1xuLy8gQWx3YXlzIHVwZGF0ZSB3cmFwcGVyLm1qcyB3aGVuIHVwZGF0aW5nIHRoaXMgZmlsZS5cbmNvbnN0IFBvc3RncmVzdENsaWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdENsaWVudFwiKSk7XG5leHBvcnRzLlBvc3RncmVzdENsaWVudCA9IFBvc3RncmVzdENsaWVudF8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyID0gUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdEJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RCdWlsZGVyXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0RXJyb3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RFcnJvclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdEVycm9yID0gUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIFBvc3RncmVzdENsaWVudDogUG9zdGdyZXN0Q2xpZW50XzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXI6IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xLmRlZmF1bHQsXG4gICAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjogUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQsXG4gICAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcjogUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcl8xLmRlZmF1bHQsXG4gICAgUG9zdGdyZXN0QnVpbGRlcjogUG9zdGdyZXN0QnVpbGRlcl8xLmRlZmF1bHQsXG4gICAgUG9zdGdyZXN0RXJyb3I6IFBvc3RncmVzdEVycm9yXzEuZGVmYXVsdCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9zdGdyZXN0RXJyb3IiLCJQb3N0Z3Jlc3RCdWlsZGVyIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJQb3N0Z3Jlc3RDbGllbnQiLCJQb3N0Z3Jlc3RDbGllbnRfMSIsInJlcXVpcmUiLCJkZWZhdWx0IiwiUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEiLCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEiLCJQb3N0Z3Jlc3RCdWlsZGVyXzEiLCJQb3N0Z3Jlc3RFcnJvcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\nexports.version = \"0.0.0-automated\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QkEsZUFBZSxHQUFHLG1CQUNsQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy92ZXJzaW9uLmpzP2ZiZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4wLjAtYXV0b21hdGVkJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ class RealtimeChannel {\n    constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\"\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint) + \"/api/broadcast\";\n        this.private = this.params.config.private || false;\n    }\n    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {\n        var _a, _b;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        } else {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence,\n                postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [],\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async ({ postgres_changes })=>{\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : \"\";\n            const options = {\n                method: \"POST\",\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.rejoinTimer.reset();\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        return new Promise((resolve)=>{\n            const leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        });\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n                    } else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n            var _a;\n            return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n        });\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n} //# sourceMappingURL=RealtimeChannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWlFO0FBQ25DO0FBQ0U7QUFDa0I7QUFDQztBQUNFO0FBQzlDLElBQUlPLHVDQUF1QztBQUNqRCxVQUFVQSxzQ0FBc0M7SUFDN0NBLHNDQUFzQyxDQUFDLE1BQU0sR0FBRztJQUNoREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0lBQ25EQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7SUFDbkRBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztBQUN2RCxHQUFHQSwwQ0FBMkNBLENBQUFBLHlDQUF5QyxDQUFDO0FBQ2pGLElBQUlDLHNCQUFzQjtBQUNoQyxVQUFVQSxxQkFBcUI7SUFDNUJBLHFCQUFxQixDQUFDLFlBQVksR0FBRztJQUNyQ0EscUJBQXFCLENBQUMsV0FBVyxHQUFHO0lBQ3BDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRztJQUM1Q0EscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ3RDLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDL0MsSUFBSUMsMEJBQTBCO0FBQ3BDLFVBQVVBLHlCQUF5QjtJQUNoQ0EseUJBQXlCLENBQUMsYUFBYSxHQUFHO0lBQzFDQSx5QkFBeUIsQ0FBQyxZQUFZLEdBQUc7SUFDekNBLHlCQUF5QixDQUFDLFNBQVMsR0FBRztJQUN0Q0EseUJBQXlCLENBQUMsZ0JBQWdCLEdBQUc7QUFDakQsR0FBR0EsNkJBQThCQSxDQUFBQSw0QkFBNEIsQ0FBQztBQUN2RCxNQUFNQywwQkFBMEJULDBEQUFjQSxDQUFDO0FBQ3REOzs7O0NBSUMsR0FDYyxNQUFNVTtJQUNqQkMsWUFDQSxrQ0FBa0MsR0FDbENDLEtBQUssRUFBRUMsU0FBUztRQUFFQyxRQUFRLENBQUM7SUFBRSxDQUFDLEVBQUVDLE1BQU0sQ0FBRTtRQUNwQyxJQUFJLENBQUNILEtBQUssR0FB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Q0FBQy9GLE1BQU0sQ0FBQ21ELFdBQVcsTUFBTSxJQUFJLENBQUMyRyxTQUFTO0lBQ3REO0lBQ0EsY0FBYyxHQUNkN0YsUUFBUWpELFVBQVUsSUFBSSxDQUFDQSxPQUFPLEVBQUU7UUFDNUIsSUFBSSxJQUFJLENBQUNrQixVQUFVLElBQUk7WUFDbkI7UUFDSjtRQUNBLElBQUksQ0FBQ2xDLE1BQU0sQ0FBQ3VLLGVBQWUsQ0FBQyxJQUFJLENBQUMxSyxLQUFLO1FBQ3RDLElBQUksQ0FBQ0ssS0FBSyxHQUFHakIsMERBQWNBLENBQUM4SyxPQUFPO1FBQ25DLElBQUksQ0FBQzlJLFFBQVEsQ0FBQ3VKLE1BQU0sQ0FBQ3hKO0lBQ3pCO0lBQ0EsY0FBYyxHQUNkNkksbUJBQW1CcEgsT0FBTyxFQUFFO1FBQ3hCLE1BQU1nSSxVQUFVO1lBQ1pkLEtBQUssQ0FBQztZQUNOQyxLQUFLLENBQUM7UUFDVjtRQUNBLElBQUluSCxRQUFRa0QsSUFBSSxLQUFLLFlBQVlsRCxRQUFRa0QsSUFBSSxLQUFLLFVBQVU7WUFDeEQ4RSxRQUFRZCxHQUFHLEdBQUd0SyxnRUFBOEIsQ0FBQ29ELFFBQVFrSSxPQUFPLEVBQUVsSSxRQUFRbUksTUFBTTtRQUNoRjtRQUNBLElBQUluSSxRQUFRa0QsSUFBSSxLQUFLLFlBQVlsRCxRQUFRa0QsSUFBSSxLQUFLLFVBQVU7WUFDeEQ4RSxRQUFRYixHQUFHLEdBQUd2SyxnRUFBOEIsQ0FBQ29ELFFBQVFrSSxPQUFPLEVBQUVsSSxRQUFRb0ksVUFBVTtRQUNwRjtRQUNBLE9BQU9KO0lBQ1g7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDaGFubmVsLmpzP2VjNGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ0hBTk5FTF9FVkVOVFMsIENIQU5ORUxfU1RBVEVTIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlIGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiU1VCU0NSSUJFRFwiXSA9IFwiU1VCU0NSSUJFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJUSU1FRF9PVVRcIl0gPSBcIlRJTUVEX09VVFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDSEFOTkVMX0VSUk9SXCJdID0gXCJDSEFOTkVMX0VSUk9SXCI7XG59KShSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHx8IChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTO1xuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgdG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9LCBzb2NrZXQpIHtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJyk7XG4gICAgICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnIH0sXG4gICAgICAgICAgICBwcml2YXRlOiBmYWxzZSxcbiAgICAgICAgfSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMuc29ja2V0LnRpbWVvdXQ7XG4gICAgICAgIHRoaXMuam9pblB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5qb2luLCB0aGlzLnBhcmFtcywgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLl9yZWpvaW5VbnRpbENvbm5lY3RlZCgpLCB0aGlzLnNvY2tldC5yZWNvbm5lY3RBZnRlck1zKTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgY2xvc2UgJHt0aGlzLnRvcGljfSAke3RoaXMuX2pvaW5SZWYoKX1gKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25FcnJvcigocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNMZWF2aW5nKCkgfHwgdGhpcy5faXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBlcnJvciAke3RoaXMudG9waWN9YCwgcmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNKb2luaW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgdGltZW91dCAke3RoaXMudG9waWN9YCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uKENIQU5ORUxfRVZFTlRTLnJlcGx5LCB7fSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcih0aGlzLl9yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJlc2VuY2UgPSBuZXcgUmVhbHRpbWVQcmVzZW5jZSh0aGlzKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCA9XG4gICAgICAgICAgICBodHRwRW5kcG9pbnRVUkwodGhpcy5zb2NrZXQuZW5kUG9pbnQpICsgJy9hcGkvYnJvYWRjYXN0JztcbiAgICAgICAgdGhpcy5wcml2YXRlID0gdGhpcy5wYXJhbXMuY29uZmlnLnByaXZhdGUgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaywgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgdHJpZWQgdG8gc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLiAnc3Vic2NyaWJlJyBjYW4gb25seSBiZSBjYWxsZWQgYSBzaW5nbGUgdGltZSBwZXIgY2hhbm5lbCBpbnN0YW5jZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSwgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcigoZSkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgZSkpO1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZSgoKSA9PiBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DTE9TRUQpKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuUGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGJyb2FkY2FzdCxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZSxcbiAgICAgICAgICAgICAgICBwb3N0Z3Jlc19jaGFuZ2VzOiAoX2IgPSAoX2EgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKHIpID0+IHIuZmlsdGVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZTogaXNQcml2YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW5QYXlsb2FkLmFjY2Vzc190b2tlbiA9IHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKE9iamVjdC5hc3NpZ24oeyBjb25maWcgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RncmVzX2NoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3NMZW4gPSAoX2EgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSBudWxsIHx8IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFBvc3RncmVzQmluZGluZ3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3N0Z3Jlc0JpbmRpbmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsdGVyOiB7IGV2ZW50LCBzY2hlbWEsIHRhYmxlLCBmaWx0ZXIgfSwgfSA9IGNsaWVudFBvc3RncmVzQmluZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclBvc3RncmVzRmlsdGVyID0gcG9zdGdyZXNfY2hhbmdlcyAmJiBwb3N0Z3Jlc19jaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlclBvc3RncmVzRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hID09PSBzY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSA9PT0gdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudFBvc3RncmVzQmluZGluZyksIHsgaWQ6IHNlcnZlclBvc3RncmVzRmlsdGVyLmlkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBuZXcgRXJyb3IoJ21pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgYmluZGluZ3MgZm9yIHBvc3RncmVzIGNoYW5nZXMnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcyA9IG5ld1Bvc3RncmVzQmluZGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5USU1FRF9PVVQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZTtcbiAgICB9XG4gICAgYXN5bmMgdHJhY2socGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHVudHJhY2sob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGludG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgdG8gYmUgdXNlZCBkdXJpbmcgdGhlIHNlbmQgcHJvY2Vzc1xuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoYXJncywgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXZlbnQsIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQgfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgICAgICAgICAgID8gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWV9YFxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbixcbiAgICAgICAgICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3BpYzogdGhpcy5zdWJUb3BpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBlbmRwb2ludF9wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGU6IHRoaXMucHJpdmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FuY2VsKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vayA/ICdvaycgOiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWVkIG91dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCBwdXNoID0gdGhpcy5fcHVzaChhcmdzLnR5cGUsIGFyZ3MsIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLnR5cGUgPT09ICdicm9hZGNhc3QnICYmICEoKF9jID0gKF9iID0gKF9hID0gdGhpcy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5icm9hZGNhc3QpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ29rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiByZXNvbHZlKCdvaycpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4gcmVzb2x2ZSgnZXJyb3InKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4gcmVzb2x2ZSgndGltZWQgb3V0JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSm9pblBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnVwZGF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHNlcnZlciBldmVudHMsIGFuZCBpbnN0cnVjdHMgY2hhbm5lbCB0byB0ZXJtaW5hdGUgb24gc2VydmVyLlxuICAgICAqIFRyaWdnZXJzIG9uQ2xvc2UoKSBob29rcy5cbiAgICAgKlxuICAgICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBhIGByZWNlaXZlYCBob29rIHRvIGJpbmQgdG8gdGhlIHNlcnZlciBhY2ssIGllOlxuICAgICAqIGNoYW5uZWwudW5zdWJzY3JpYmUoKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4gYWxlcnQoXCJsZWZ0IVwiKSApXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMubGVhdmluZztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmxvZygnY2hhbm5lbCcsIGBsZWF2ZSAke3RoaXMudG9waWN9YCk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCAnbGVhdmUnLCB0aGlzLl9qb2luUmVmKCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIC8vIERlc3Ryb3kgam9pblB1c2ggdG8gYXZvaWQgY29ubmVjdGlvbiB0aW1lb3V0cyBkdXJpbmcgdW5zY3JpcHRpb24gcGhhc2VcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIHt9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGxlYXZlUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ3RpbWVkIG91dCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGVhdmVQdXNoLnNlbmQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICAgICAgbGVhdmVQdXNoLnRyaWdnZXIoJ29rJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9mZXRjaFdpdGhUaW1lb3V0KHVybCwgb3B0aW9ucywgdGltZW91dCkge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBpZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNvY2tldC5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KSk7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9wdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICghdGhpcy5qb2luZWRPbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBgdHJpZWQgdG8gcHVzaCAnJHtldmVudH0nIHRvICcke3RoaXMudG9waWN9JyBiZWZvcmUgam9pbmluZy4gVXNlIGNoYW5uZWwuc3Vic2NyaWJlKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVzaEV2ZW50ID0gbmV3IFB1c2godGhpcywgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpO1xuICAgICAgICBpZiAodGhpcy5fY2FuUHVzaCgpKSB7XG4gICAgICAgICAgICBwdXNoRXZlbnQuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaEV2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICAgKlxuICAgICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzTWVtYmVyKHRvcGljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcGljID09PSB0b3BpYztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9qb2luUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWY7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlcih0eXBlLCBwYXlsb2FkLCByZWYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTO1xuICAgICAgICBjb25zdCBldmVudHMgPSBbY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbl07XG4gICAgICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICB0aHJvdyAnY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQpID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgKChfYyA9IChfYiA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyKTtcbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4gYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBpZiAoWydicm9hZGNhc3QnLCAncHJlc2VuY2UnLCAncG9zdGdyZXNfY2hhbmdlcyddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdpZCcgaW4gYmluZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZElkID0gYmluZC5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJpbmRJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2IgPSBwYXlsb2FkLmlkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKGJpbmRJZCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gJyonIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09IG51bGwgfHwgYmluZEV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kRXZlbnQudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gcGF5bG9hZC5kYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9lID0gKF9kID0gYmluZCA9PT0gbnVsbCB8fCBiaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmV2ZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kRXZlbnQgPT09ICgoX2YgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuZXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50b0xvY2FsZUxvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPSBwb3N0Z3Jlc0NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnJpY2hlZFBheWxvYWQpLCB0aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0xlYXZpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICEoKChfYSA9IGJpbmQudHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXIgJiZcbiAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uKSA9PiBjYWxsYmFjayhyZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jYW5QdXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQucmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6WyJDSEFOTkVMX0VWRU5UUyIsIkNIQU5ORUxfU1RBVEVTIiwiUHVzaCIsIlRpbWVyIiwiUmVhbHRpbWVQcmVzZW5jZSIsIlRyYW5zZm9ybWVycyIsImh0dHBFbmRwb2ludFVSTCIsIlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIiwiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyIsIlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTIiwiUmVhbHRpbWVDaGFubmVsIiwiY29uc3RydWN0b3IiLCJ0b3BpYyIsInBhcmFtcyIsImNvbmZpZyIsInNvY2tldCIsImJpbmRpbmdzIiwic3RhdGUiLCJjbG9zZWQiLCJqb2luZWRPbmNlIiwicHVzaEJ1ZmZlciIsInN1YlRvcGljIiwicmVwbGFjZSIsIk9iamVjdCIsImFzc2lnbiIsImJyb2FkY2FzdCIsImFjayIsInNlbGYiLCJwcmVzZW5jZSIsImtleSIsInByaXZhdGUiLCJ0aW1lb3V0Iiwiam9pblB1c2giLCJqb2luIiwicmVqb2luVGltZXIiLCJfcmVqb2luVW50aWxDb25uZWN0ZWQiLCJyZWNvbm5lY3RBZnRlck1zIiwicmVjZWl2ZSIsImpvaW5lZCIsInJlc2V0IiwiZm9yRWFjaCIsInB1c2hFdmVudCIsInNlbmQiLCJfb25DbG9zZSIsImxvZyIsIl9qb2luUmVmIiwiX3JlbW92ZSIsIl9vbkVycm9yIiwicmVhc29uIiwiX2lzTGVhdmluZyIsIl9pc0Nsb3NlZCIsImVycm9yZWQiLCJzY2hlZHVsZVRpbWVvdXQiLCJfaXNKb2luaW5nIiwiX29uIiwicmVwbHkiLCJwYXlsb2FkIiwicmVmIiwiX3RyaWdnZXIiLCJfcmVwbHlFdmVudE5hbWUiLCJicm9hZGNhc3RFbmRwb2ludFVSTCIsImVuZFBvaW50Iiwic3Vic2NyaWJlIiwiY2FsbGJhY2siLCJfYSIsIl9iIiwiaXNDb25uZWN0ZWQiLCJjb25uZWN0IiwiaXNQcml2YXRlIiwiZSIsIkNIQU5ORUxfRVJST1IiLCJDTE9TRUQiLCJhY2Nlc3NUb2tlblBheWxvYWQiLCJwb3N0Z3Jlc19jaGFuZ2VzIiwibWFwIiwiciIsImZpbHRlciIsImFjY2Vzc1Rva2VuVmFsdWUiLCJhY2Nlc3NfdG9rZW4iLCJ1cGRhdGVKb2luUGF5bG9hZCIsIl9yZWpvaW4iLCJzZXRBdXRoIiwidW5kZWZpbmVkIiwiU1VCU0NSSUJFRCIsImNsaWVudFBvc3RncmVzQmluZGluZ3MiLCJiaW5kaW5nc0xlbiIsImxlbmd0aCIsIm5ld1Bvc3RncmVzQmluZGluZ3MiLCJpIiwiY2xpZW50UG9zdGdyZXNCaW5kaW5nIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsInNlcnZlclBvc3RncmVzRmlsdGVyIiwicHVzaCIsImlkIiwidW5zdWJzY3JpYmUiLCJFcnJvciIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbHVlcyIsIlRJTUVEX09VVCIsInByZXNlbmNlU3RhdGUiLCJ0cmFjayIsIm9wdHMiLCJ0eXBlIiwidW50cmFjayIsIm9uIiwiYXJncyIsIl9jYW5QdXNoIiwiZW5kcG9pbnRfcGF5bG9hZCIsImF1dGhvcml6YXRpb24iLCJvcHRpb25zIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJhcGlrZXkiLCJhcGlLZXkiLCJib2R5IiwibWVzc2FnZXMiLCJyZXNwb25zZSIsIl9mZXRjaFdpdGhUaW1lb3V0IiwiY2FuY2VsIiwib2siLCJuYW1lIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfYyIsIl9wdXNoIiwidXBkYXRlUGF5bG9hZCIsImxlYXZpbmciLCJvbkNsb3NlIiwiY2xvc2UiLCJkZXN0cm95IiwibGVhdmVQdXNoIiwibGVhdmUiLCJ0cmlnZ2VyIiwidXJsIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRUaW1lb3V0IiwiX29uTWVzc2FnZSIsIl9ldmVudCIsIl9yZWYiLCJfaXNNZW1iZXIiLCJ0eXBlTG93ZXIiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImV2ZW50cyIsImluZGV4T2YiLCJoYW5kbGVkUGF5bG9hZCIsImluY2x1ZGVzIiwiYmluZCIsIl9kIiwiX2UiLCJfZiIsImJpbmRJZCIsImJpbmRFdmVudCIsImlkcyIsImRhdGEiLCJwb3N0Z3Jlc0NoYW5nZXMiLCJjb21taXRfdGltZXN0YW1wIiwiZXJyb3JzIiwiZW5yaWNoZWRQYXlsb2FkIiwiZXZlbnRUeXBlIiwibmV3Iiwib2xkIiwiX2dldFBheWxvYWRSZWNvcmRzIiwiX2lzSm9pbmVkIiwiam9pbmluZyIsImJpbmRpbmciLCJfb2ZmIiwiaXNFcXVhbCIsIm9iajEiLCJvYmoyIiwia2V5cyIsImsiLCJfbGVhdmVPcGVuVG9waWMiLCJyZXNlbmQiLCJyZWNvcmRzIiwiY29udmVydENoYW5nZURhdGEiLCJjb2x1bW5zIiwicmVjb3JkIiwib2xkX3JlY29yZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/serializer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\nconst noop = ()=>{};\nconst NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== \"undefined\";\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = [];\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        this.headers = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = 30000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            } else if (typeof fetch === \"undefined\") {\n                _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n            } else {\n                _fetch = fetch;\n            }\n            return (...args)=>_fetch(...args);\n        };\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_3__.httpEndpointURL)(endPoint);\n        if (options === null || options === void 0 ? void 0 : options.transport) {\n            this.transport = options.transport;\n        } else {\n            this.transport = null;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n        if (accessTokenValue) {\n            this.accessTokenValue = accessTokenValue;\n            this.apiKey = accessTokenValue;\n        }\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries)=>{\n            return [\n                1000,\n                2000,\n                5000,\n                10000\n            ][tries - 1] || 10000;\n        };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback)=>{\n            return callback(JSON.stringify(payload));\n        };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](async ()=>{\n            this.disconnect();\n            this.connect();\n        }, this.reconnectAfterMs);\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n        if (options === null || options === void 0 ? void 0 : options.worker) {\n            if (false) {}\n            this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n        this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        if (this.conn) {\n            return;\n        }\n        if (this.transport) {\n            this.conn = new this.transport(this.endpointURL(), undefined, {\n                headers: this.headers\n            });\n            return;\n        }\n        if (NATIVE_WEBSOCKET_AVAILABLE) {\n            this.conn = new WebSocket(this.endpointURL());\n            this.setupConnection();\n            return;\n        }\n        this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n            close: ()=>{\n                this.conn = null;\n            }\n        });\n        Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/ws\"), __webpack_require__.e(\"_32c4-_66e9\")]).then(__webpack_require__.bind(__webpack_require__, /*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\")).then(({ default: WS })=>{\n            this.conn = new WS(this.endpointURL(), undefined, {\n                headers: this.headers\n            });\n            this.setupConnection();\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: _lib_constants__WEBPACK_IMPORTED_MODULE_0__.VSN\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function() {}; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n            } else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;\n    }\n    channel(topic, params = {\n        config: {}\n    }) {\n        const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__[\"default\"](`realtime:${topic}`, params, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */ async setAuth(token = null) {\n        let tokenToSend = token || this.accessToken && await this.accessToken() || this.accessTokenValue;\n        if (tokenToSend) {\n            let parsed = null;\n            try {\n                parsed = JSON.parse(atob(tokenToSend.split(\".\")[1]));\n            } catch (_error) {}\n            if (parsed && parsed.exp) {\n                let now = Math.floor(Date.now() / 1000);\n                let valid = now - parsed.exp < 0;\n                if (!valid) {\n                    this.log(\"auth\", `InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                    return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim \"exp\" with value ${parsed.exp}`);\n                }\n            }\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                tokenToSend && channel.updateJoinPayload({\n                    access_token: tokenToSend\n                });\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.WS_CLOSE_NORMAL, \"hearbeat timeout\");\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        this.setAuth();\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c._joinRef() !== channel._joinRef());\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */ setupConnection() {\n        if (this.conn) {\n            this.conn.binaryType = \"arraybuffer\";\n            this.conn.onopen = ()=>this._onConnOpen();\n            this.conn.onerror = (error)=>this._onConnError(error);\n            this.conn.onmessage = (event)=>this._onConnMessage(event);\n            this.conn.onclose = (event)=>this._onConnClose(event);\n        }\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            let { topic, event, payload, ref } = msg;\n            if (ref && ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback)=>callback(msg));\n        });\n    }\n    /** @internal */ async _onConnOpen() {\n        this.log(\"transport\", `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this.reconnectTimer.reset();\n        if (!this.worker) {\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n        } else {\n            if (this.workerUrl) {\n                this.log(\"worker\", `starting worker for from ${this.workerUrl}`);\n            } else {\n                this.log(\"worker\", `starting default worker`);\n            }\n            const objectUrl = this._workerObjectUrl(this.workerUrl);\n            this.workerRef = new Worker(objectUrl);\n            this.workerRef.onerror = (error)=>{\n                this.log(\"worker\", \"worker error\", error.message);\n                this.workerRef.terminate();\n            };\n            this.workerRef.onmessage = (event)=>{\n                if (event.data.event === \"keepAlive\") {\n                    this.sendHeartbeat();\n                }\n            };\n            this.workerRef.postMessage({\n                event: \"start\",\n                interval: this.heartbeatIntervalMs\n            });\n        }\n        this.stateChangeCallbacks.open.forEach((callback)=>callback());\n    }\n    /** @internal */ _onConnClose(event) {\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback)=>callback(event));\n    }\n    /** @internal */ _onConnError(error) {\n        this.log(\"transport\", error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback)=>callback(error));\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n}\nclass WSWebSocketDummy {\n    constructor(address, _protocols, options){\n        this.binaryType = \"arraybuffer\";\n        this.onclose = ()=>{};\n        this.onerror = ()=>{};\n        this.onmessage = ()=>{};\n        this.onopen = ()=>{};\n        this.readyState = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting;\n        this.send = ()=>{};\n        this.url = null;\n        this.url = address;\n        this.close = options.close;\n    }\n} //# sourceMappingURL=RealtimeClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1SjtBQUM3RztBQUNWO0FBQ3FCO0FBQ0w7QUFDaEQsTUFBTVksT0FBTyxLQUFRO0FBQ3JCLE1BQU1DLDZCQUE2QixPQUFPQyxjQUFjO0FBQ3hELE1BQU1DLGdCQUFnQixDQUFDOzs7OztLQUtsQixDQUFDO0FBQ1MsTUFBTUM7SUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDREMsWUFBWUMsUUFBUSxFQUFFQyxPQUFPLENBQUU7UUFDM0IsSUFBSUM7UUFDSixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNMLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNNLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLE9BQU8sR0FBR3ZCLDJEQUFlQTtRQUM5QixJQUFJLENBQUN3QixNQUFNLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHeEIsMkRBQWVBO1FBQzlCLElBQUksQ0FBQ3lCLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0MsY0FBYyxHQUFHQztRQUN0QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxNQUFNLEdBQUdyQjtRQUNkLElBQUksQ0FBQ3NCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSTVCLHVEQUFVQTtRQUNoQyxJQUFJLENBQUM2QixvQkFBb0IsR0FBRztZQUN4QkMsTUFBTSxFQUFFO1lBQ1JDLE9BQU8sRUFBRTtZQUNUQyxPQUFPLEVBQUU7WUFDVEMsU0FBUyxFQUFFO1FB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QixJQUFJLENBQUN1RCxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNBLEdBQUcsR0FBR1k7UUFDWCxJQUFJLENBQUM3SSxLQUFLLEdBQUdwQixRQUFRb0IsS0FBSztJQUM5QjtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNsaWVudC5qcz82YjZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDT05ORUNUSU9OX1NUQVRFLCBERUZBVUxUX0hFQURFUlMsIERFRkFVTFRfVElNRU9VVCwgU09DS0VUX1NUQVRFUywgVFJBTlNQT1JUUywgVlNOLCBXU19DTE9TRV9OT1JNQUwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG5jb25zdCBOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSA9IHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgV09SS0VSX1NDUklQVCA9IGBcbiAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIHNldEludGVydmFsKCgpID0+IHBvc3RNZXNzYWdlKHsgZXZlbnQ6IFwia2VlcEFsaXZlXCIgfSksIGUuZGF0YS5pbnRlcnZhbCk7XG4gICAgfVxuICB9KTtgO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBTb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kUG9pbnQgVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBcIndzOi8vZXhhbXBsZS5jb20vc29ja2V0XCIsIFwid3NzOi8vZXhhbXBsZS5jb21cIiwgXCIvc29ja2V0XCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAgICogQHBhcmFtIGh0dHBFbmRwb2ludCBUaGUgc3RyaW5nIEhUVFAgZW5kcG9pbnQsIGllLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIiwgXCIvXCIgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNwb3J0IFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dCBUaGUgZGVmYXVsdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byB0cmlnZ2VyIHB1c2ggdGltZW91dHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyYW1zIFRoZSBvcHRpb25hbCBwYXJhbXMgdG8gcGFzcyB3aGVuIGNvbm5lY3RpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyBUaGUgb3B0aW9uYWwgaGVhZGVycyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zIFRoZSBtaWxsaXNlYyBpbnRlcnZhbCB0byBzZW5kIGEgaGVhcnRiZWF0IG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW107XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSAnJztcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSAnJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gREVGQVVMVF9IRUFERVJTO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQ7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IDMwMDAwO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICB0aGlzLnJlZiA9IDA7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbm9vcDtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvcGVuOiBbXSxcbiAgICAgICAgICAgIGNsb3NlOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBlaXRoZXIgY3VzdG9tIGZldGNoLCBpZiBwcm92aWRlZCwgb3IgZGVmYXVsdCBmZXRjaCB0byBtYWtlIEhUVFAgcmVxdWVzdHNcbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICAgICAgICAgIGxldCBfZmV0Y2g7XG4gICAgICAgICAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWA7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gaHR0cEVuZHBvaW50VVJMKGVuZFBvaW50KTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0aW9ucy50cmFuc3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dClcbiAgICAgICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dnZXIpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXM7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuVmFsdWUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBpa2V5O1xuICAgICAgICBpZiAoYWNjZXNzVG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNc1xuICAgICAgICAgICAgOiAodHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzEwMDAsIDIwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSlcbiAgICAgICAgICAgID8gb3B0aW9ucy5lbmNvZGVcbiAgICAgICAgICAgIDogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVjb2RlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZWNvZGUpXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVjb2RlXG4gICAgICAgICAgICA6IHRoaXMuc2VyaWFsaXplci5kZWNvZGUuYmluZCh0aGlzLnNlcmlhbGl6ZXIpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSB0aGlzLl9yZXNvbHZlRmV0Y2gob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZldGNoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtlciA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKSB8fCBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyVXJsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndvcmtlclVybDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hY2Nlc3NUb2tlbikgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdHMgdGhlIHNvY2tldCwgdW5sZXNzIGFscmVhZHkgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOQVRJVkVfV0VCU09DS0VUX0FWQUlMQUJMRSkge1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbmV3IFdlYlNvY2tldCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm4gPSBuZXcgV1NXZWJTb2NrZXREdW1teSh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgY2xvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGltcG9ydCgnd3MnKS50aGVuKCh7IGRlZmF1bHQ6IFdTIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyBXUyh0aGlzLmVuZHBvaW50VVJMKCksIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENvbm5lY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgICAqIEByZXR1cm5zIHN0cmluZyBUaGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICovXG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7IH07IC8vIG5vb3BcbiAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKGNvZGUsIHJlYXNvbiAhPT0gbnVsbCAmJiByZWFzb24gIT09IHZvaWQgMCA/IHJlYXNvbiA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvcGVuIGhhbmRsZXNcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBjcmVhdGVkIGNoYW5uZWxzXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYSBzaW5nbGUgY2hhbm5lbFxuICAgICAqIEBwYXJhbSBjaGFubmVsIEEgUmVhbHRpbWVDaGFubmVsIGluc3RhbmNlXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIGNoYW5uZWxzXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlQWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlc18xID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jaGFubmVscy5tYXAoKGNoYW5uZWwpID0+IGNoYW5uZWwudW5zdWJzY3JpYmUoKSkpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgKi9cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgICBjaGFubmVsKHRvcGljLCBwYXJhbXMgPSB7IGNvbmZpZzoge30gfSkge1xuICAgICAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICAgIHJldHVybiBjaGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBhIG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIG5vdCBjb25uZWN0ZWQsIHRoZSBtZXNzYWdlIGdldHMgZW5xdWV1ZWQgd2l0aGluIGEgbG9jYWwgYnVmZmVyLCBhbmQgc2VudCBvdXQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgbmV4dCBlc3RhYmxpc2hlZC5cbiAgICAgKi9cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gZGF0YTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmQocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZygncHVzaCcsIGAke3RvcGljfSAke2V2ZW50fSAoJHtyZWZ9KWAsIHBheWxvYWQpO1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEpXVCBhY2Nlc3MgdG9rZW4gdXNlZCBmb3IgY2hhbm5lbCBzdWJzY3JpcHRpb24gYXV0aG9yaXphdGlvbiBhbmQgUmVhbHRpbWUgUkxTLlxuICAgICAqXG4gICAgICogSWYgcGFyYW0gaXMgbnVsbCBpdCB3aWxsIHVzZSB0aGUgYGFjY2Vzc1Rva2VuYCBjYWxsYmFjayBmdW5jdGlvbiBvciB0aGUgdG9rZW4gc2V0IG9uIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBPbiBjYWxsYmFjayB1c2VkLCBpdCB3aWxsIHNldCB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIGludGVybmFsIHRvIHRoZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gQSBKV1Qgc3RyaW5nIHRvIG92ZXJyaWRlIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRBdXRoKHRva2VuID0gbnVsbCkge1xuICAgICAgICBsZXQgdG9rZW5Ub1NlbmQgPSB0b2tlbiB8fFxuICAgICAgICAgICAgKHRoaXMuYWNjZXNzVG9rZW4gJiYgKGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKSkpIHx8XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgIGlmICh0b2tlblRvU2VuZCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoYXRvYih0b2tlblRvU2VuZC5zcGxpdCgnLicpWzFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2Vycm9yKSB7IH1cbiAgICAgICAgICAgIGlmIChwYXJzZWQgJiYgcGFyc2VkLmV4cCkge1xuICAgICAgICAgICAgICAgIGxldCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsaWQgPSBub3cgLSBwYXJzZWQuZXhwIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdhdXRoJywgYEludmFsaWRKV1RUb2tlbjogSW52YWxpZCB2YWx1ZSBmb3IgSldUIGNsYWltIFwiZXhwXCIgd2l0aCB2YWx1ZSAke3BhcnNlZC5leHB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgSW52YWxpZEpXVFRva2VuOiBJbnZhbGlkIHZhbHVlIGZvciBKV1QgY2xhaW0gXCJleHBcIiB3aXRoIHZhbHVlICR7cGFyc2VkLmV4cH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSB0b2tlblRvU2VuZDtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgICAgIHRva2VuVG9TZW5kICYmIGNoYW5uZWwudXBkYXRlSm9pblBheWxvYWQoeyBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJiZWF0IHRpbWVvdXQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKCk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QXV0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAgICovXG4gICAgZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9tYWtlUmVmKCkge1xuICAgICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2xlYXZlT3BlblRvcGljKHRvcGljKSB7XG4gICAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSkpO1xuICAgICAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbW92ZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy5fam9pblJlZigpICE9PSBjaGFubmVsLl9qb2luUmVmKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGNvbm5lY3Rpb24gaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzZXR1cENvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5fb25Db25uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uQ2xvc2UoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgbGV0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IG1zZztcbiAgICAgICAgICAgIGlmIChyZWYgJiYgcmVmID09PSB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coJ3JlY2VpdmUnLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCAnJ30gJHt0b3BpY30gJHtldmVudH0gJHsocmVmICYmICcoJyArIHJlZiArICcpJykgfHwgJyd9YCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY2hhbm5lbCkgPT4gY2hhbm5lbC5faXNNZW1iZXIodG9waWMpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sobXNnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX29uQ29ubk9wZW4oKSB7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRwb2ludFVSTCgpfWApO1xuICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgd29ya2VyIGZvciBmcm9tICR7dGhpcy53b3JrZXJVcmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnd29ya2VyJywgYHN0YXJ0aW5nIGRlZmF1bHQgd29ya2VyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwpO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJSZWYgPSBuZXcgV29ya2VyKG9iamVjdFVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZi5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlclJlZi50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5ldmVudCA9PT0gJ2tlZXBBbGl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5DbG9zZShldmVudCkge1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2Nsb3NlJywgZXZlbnQpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YDtcbiAgICB9XG4gICAgX3dvcmtlck9iamVjdFVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdF91cmw7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfdXJsO1xuICAgIH1cbn1cbmNsYXNzIFdTV2ViU29ja2V0RHVtbXkge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIF9wcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25tZXNzYWdlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLm9ub3BlbiA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgICAgICB0aGlzLnNlbmQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy51cmwgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLmNsb3NlID0gb3B0aW9ucy5jbG9zZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiQ0hBTk5FTF9FVkVOVFMiLCJDT05ORUNUSU9OX1NUQVRFIiwiREVGQVVMVF9IRUFERVJTIiwiREVGQVVMVF9USU1FT1VUIiwiU09DS0VUX1NUQVRFUyIsIlRSQU5TUE9SVFMiLCJWU04iLCJXU19DTE9TRV9OT1JNQUwiLCJTZXJpYWxpemVyIiwiVGltZXIiLCJodHRwRW5kcG9pbnRVUkwiLCJSZWFsdGltZUNoYW5uZWwiLCJub29wIiwiTkFUSVZFX1dFQlNPQ0tFVF9BVkFJTEFCTEUiLCJXZWJTb2NrZXQiLCJXT1JLRVJfU0NSSVBUIiwiUmVhbHRpbWVDbGllbnQiLCJjb25zdHJ1Y3RvciIsImVuZFBvaW50Iiwib3B0aW9ucyIsIl9hIiwiYWNjZXNzVG9rZW5WYWx1ZSIsImFwaUtleSIsImNoYW5uZWxzIiwiaHR0cEVuZHBvaW50IiwiaGVhZGVycyIsInBhcmFtcyIsInRpbWVvdXQiLCJoZWFydGJlYXRJbnRlcnZhbE1zIiwiaGVhcnRiZWF0VGltZXIiLCJ1bmRlZmluZWQiLCJwZW5kaW5nSGVhcnRiZWF0UmVmIiwicmVmIiwibG9nZ2VyIiwiY29ubiIsInNlbmRCdWZmZXIiLCJzZXJpYWxpemVyIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJvcGVuIiwiY2xvc2UiLCJlcnJvciIsIm1lc3NhZ2UiLCJhY2Nlc3NUb2tlbiIsIl9yZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsIl9mZXRjaCIsImZldGNoIiwiYXJncyIsInRoZW4iLCJkZWZhdWx0Iiwid2Vic29ja2V0IiwidHJhbnNwb3J0IiwiT2JqZWN0IiwiYXNzaWduIiwiYXBpa2V5IiwicmVjb25uZWN0QWZ0ZXJNcyIsInRyaWVzIiwiZW5jb2RlIiwicGF5bG9hZCIsImNhbGxiYWNrIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlY29kZSIsImJpbmQiLCJyZWNvbm5lY3RUaW1lciIsImRpc2Nvbm5lY3QiLCJjb25uZWN0Iiwid29ya2VyIiwid2luZG93IiwiV29ya2VyIiwiRXJyb3IiLCJ3b3JrZXJVcmwiLCJlbmRwb2ludFVSTCIsInNldHVwQ29ubmVjdGlvbiIsIldTV2ViU29ja2V0RHVtbXkiLCJXUyIsIl9hcHBlbmRQYXJhbXMiLCJ2c24iLCJjb2RlIiwicmVhc29uIiwib25jbG9zZSIsImNsZWFySW50ZXJ2YWwiLCJyZXNldCIsImdldENoYW5uZWxzIiwicmVtb3ZlQ2hhbm5lbCIsImNoYW5uZWwiLCJzdGF0dXMiLCJ1bnN1YnNjcmliZSIsImxlbmd0aCIsInJlbW92ZUFsbENoYW5uZWxzIiwidmFsdWVzXzEiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibG9nIiwia2luZCIsIm1zZyIsImRhdGEiLCJjb25uZWN0aW9uU3RhdGUiLCJyZWFkeVN0YXRlIiwiY29ubmVjdGluZyIsIkNvbm5lY3RpbmciLCJPcGVuIiwiY2xvc2luZyIsIkNsb3NpbmciLCJDbG9zZWQiLCJpc0Nvbm5lY3RlZCIsInRvcGljIiwiY29uZmlnIiwiY2hhbiIsInB1c2giLCJldmVudCIsInJlc3VsdCIsInNlbmQiLCJzZXRBdXRoIiwidG9rZW4iLCJ0b2tlblRvU2VuZCIsInBhcnNlZCIsInBhcnNlIiwiYXRvYiIsInNwbGl0IiwiX2Vycm9yIiwiZXhwIiwibm93IiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsInZhbGlkIiwicmVqZWN0IiwiZm9yRWFjaCIsInVwZGF0ZUpvaW5QYXlsb2FkIiwiYWNjZXNzX3Rva2VuIiwiam9pbmVkT25jZSIsIl9pc0pvaW5lZCIsIl9wdXNoIiwic2VuZEhlYXJ0YmVhdCIsIl9tYWtlUmVmIiwiZmx1c2hTZW5kQnVmZmVyIiwibmV3UmVmIiwidG9TdHJpbmciLCJfbGVhdmVPcGVuVG9waWMiLCJkdXBDaGFubmVsIiwiZmluZCIsImMiLCJfaXNKb2luaW5nIiwiX3JlbW92ZSIsImZpbHRlciIsIl9qb2luUmVmIiwiYmluYXJ5VHlwZSIsIm9ub3BlbiIsIl9vbkNvbm5PcGVuIiwib25lcnJvciIsIl9vbkNvbm5FcnJvciIsIm9ubWVzc2FnZSIsIl9vbkNvbm5NZXNzYWdlIiwiX29uQ29ubkNsb3NlIiwicmF3TWVzc2FnZSIsIl9pc01lbWJlciIsIl90cmlnZ2VyIiwic2V0SW50ZXJ2YWwiLCJvYmplY3RVcmwiLCJfd29ya2VyT2JqZWN0VXJsIiwid29ya2VyUmVmIiwidGVybWluYXRlIiwicG9zdE1lc3NhZ2UiLCJpbnRlcnZhbCIsIl90cmlnZ2VyQ2hhbkVycm9yIiwic2NoZWR1bGVUaW1lb3V0IiwidXJsIiwia2V5cyIsInByZWZpeCIsIm1hdGNoIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJyZXN1bHRfdXJsIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiYWRkcmVzcyIsIl9wcm90b2NvbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n} //# sourceMappingURL=RealtimePresence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0EsR0FDTyxJQUFJQSxnQ0FBZ0M7QUFDMUMsVUFBVUEsK0JBQStCO0lBQ3RDQSwrQkFBK0IsQ0FBQyxPQUFPLEdBQUc7SUFDMUNBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsUUFBUSxHQUFHO0FBQy9DLEdBQUdBLG1DQUFvQ0EsQ0FBQUEsa0NBQWtDLENBQUM7QUFDM0QsTUFBTUM7SUFDakI7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0UsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUNDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUc7WUFDVkMsUUFBUSxLQUFRO1lBQ2hCQyxTQUFTLEtBQVE7WUFDakJDLFFBQVEsS0FBUTtRQUNwQjtRQUNBLE1BQU1DLFNBQVMsQ0FBQ1IsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtRLE1BQU0sS0FBSztZQUN4RVAsT0FBTztZQUNQUSxNQUFNO1FBQ1Y7UUFDQSxJQUFJLENBQUNWLE9BQU8sQ0FBQ1csR0FBRyxDQUFDRixPQUFPUCxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUNVO1lBQ2hDLE1BQU0sRUFBRU4sTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ0gsTUFBTTtZQUMvQyxJQUFJLENBQUNELE9BQU8sR0FBRyxJQUFJLENBQUNKLE9BQU8sQ0FBQ2EsUUFBUTtZQUNwQyxJQUFJLENBQUNYLEtBQUssR0FBR0osaUJBQWlCZ0IsU0FBUyxDQUFDLElBQUksQ0FB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b0JBQy9CLE9BQU9BO2dCQUNYO1lBQ0osT0FDSztnQkFDRHhDLFFBQVEsQ0FBQ08sSUFBSSxHQUFHYTtZQUNwQjtZQUNBLE9BQU9wQjtRQUNYLEdBQUcsQ0FBQztJQUNSO0lBQ0EsY0FBYyxHQUNkLE9BQU9jLFVBQVVvQixHQUFHLEVBQUU7UUFDbEIsT0FBT08sS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNUO0lBQ3JDO0lBQ0EsY0FBYyxHQUNkeEMsT0FBT2tELFFBQVEsRUFBRTtRQUNiLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ0MsTUFBTSxHQUFHa0Q7SUFDekI7SUFDQSxjQUFjLEdBQ2RqRCxRQUFRaUQsUUFBUSxFQUFFO1FBQ2QsSUFBSSxDQUFDbkQsTUFBTSxDQUFDRSxPQUFPLEdBQUdpRDtJQUMxQjtJQUNBLGNBQWMsR0FDZGhELE9BQU9nRCxRQUFRLEVBQUU7UUFDYixJQUFJLENBQUNuRCxNQUFNLENBQUNHLE1BQU0sR0FBR2dEO0lBQ3pCO0lBQ0EsY0FBYyxHQUNkdkMscUJBQXFCO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUNiLE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU8sS0FBSyxJQUFJLENBQUNKLE9BQU8sQ0FBQ2EsUUFBUTtJQUNsRTtBQUNKLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZVByZXNlbmNlLmpzP2NlYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9hc3NldHMvanMvcGhvZW5peC9wcmVzZW5jZS5qc1xuICBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvZDM0NGVjMGE3MzJhYjRlZTIwNDIxNWIzMWRlNjljZjRiZTcyZTNiZi9MSUNFTlNFLm1kXG4qL1xuZXhwb3J0IHZhciBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTKSB7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIlNZTkNcIl0gPSBcInN5bmNcIjtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiSk9JTlwiXSA9IFwiam9pblwiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgfHwgKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMgPSB7fSkpO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVhbHRpbWVQcmVzZW5jZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFByZXNlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgUmVhbHRpbWVDaGFubmVsXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0aW9ucyxcbiAgICAgKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogJ3N0YXRlJywgZGlmZjogJ2RpZmYnfX1gXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cykge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgICAgICAgb25Kb2luOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvbkxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvblN5bmM6ICgpID0+IHsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudHMpIHx8IHtcbiAgICAgICAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgICAqIGNsaWVudCdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGpvaW5zID0ge307XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgICAgICAgIG9uSm9pbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IChfYSA9IHN0YXRlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNsb25lRGVlcChvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uU3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIiwiUmVhbHRpbWVQcmVzZW5jZSIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsIm9wdHMiLCJzdGF0ZSIsInBlbmRpbmdEaWZmcyIsImpvaW5SZWYiLCJjYWxsZXIiLCJvbkpvaW4iLCJvbkxlYXZlIiwib25TeW5jIiwiZXZlbnRzIiwiZGlmZiIsIl9vbiIsIm5ld1N0YXRlIiwiX2pvaW5SZWYiLCJzeW5jU3RhdGUiLCJmb3JFYWNoIiwic3luY0RpZmYiLCJpblBlbmRpbmdTeW5jU3RhdGUiLCJwdXNoIiwia2V5IiwiY3VycmVudFByZXNlbmNlcyIsIm5ld1ByZXNlbmNlcyIsIl90cmlnZ2VyIiwiZXZlbnQiLCJsZWZ0UHJlc2VuY2VzIiwiY3VycmVudFN0YXRlIiwiY2xvbmVEZWVwIiwidHJhbnNmb3JtZWRTdGF0ZSIsInRyYW5zZm9ybVN0YXRlIiwiam9pbnMiLCJsZWF2ZXMiLCJtYXAiLCJwcmVzZW5jZXMiLCJuZXdQcmVzZW5jZVJlZnMiLCJtIiwicHJlc2VuY2VfcmVmIiwiY3VyUHJlc2VuY2VSZWZzIiwiam9pbmVkUHJlc2VuY2VzIiwiZmlsdGVyIiwiaW5kZXhPZiIsImxlbmd0aCIsIl9hIiwiam9pbmVkUHJlc2VuY2VSZWZzIiwiY3VyUHJlc2VuY2VzIiwidW5zaGlmdCIsInByZXNlbmNlUmVmc1RvUmVtb3ZlIiwib2JqIiwiZnVuYyIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJtZXRhcyIsInByZXNlbmNlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiY2FsbGJhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQzBIO0FBQ2hGO0FBQzBILENBQ2xOLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanM/NTU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhbHRpbWVDbGllbnQgZnJvbSAnLi9SZWFsdGltZUNsaWVudCc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsLCB7IFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCB9IGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlLCB7IFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIH0gZnJvbSAnLi9SZWFsdGltZVByZXNlbmNlJztcbmV4cG9ydCB7IFJlYWx0aW1lUHJlc2VuY2UsIFJlYWx0aW1lQ2hhbm5lbCwgUmVhbHRpbWVDbGllbnQsIFJFQUxUSU1FX0xJU1RFTl9UWVBFUywgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQsIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMsIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMsIFJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlJlYWx0aW1lQ2xpZW50IiwiUmVhbHRpbWVDaGFubmVsIiwiUkVBTFRJTUVfTElTVEVOX1RZUEVTIiwiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCJSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIiwiUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMiLCJSZWFsdGltZVByZXNlbmNlIiwiUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VSN: () => (/* binding */ VSN),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst VSN = \"1.0.0\";\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvQztBQUM3QixNQUFNQyxrQkFBa0I7SUFBRSxpQkFBaUIsQ0FBQyxZQUFZLEVBQUVELDZDQUFPQSxDQUFDLENBQUM7QUFBQyxFQUFFO0FBQ3RFLE1BQU1FLE1BQU0sUUFBUTtBQUNwQixNQUFNQyxrQkFBa0IsTUFBTTtBQUM5QixNQUFNQyxrQkFBa0IsS0FBSztBQUM3QixJQUFJQyxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDakRBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDM0NBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDOUNBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDakQsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUMvQixJQUFJQyxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7QUFDaEMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUNqQyxJQUFJQyxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxPQUFPLEdBQUc7SUFDekJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7QUFDckMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUNqQyxJQUFJQyxXQUFXO0FBQ3JCLFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQyxZQUFZLEdBQUc7QUFDOUIsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ3pCLElBQUlDLGlCQUFpQjtBQUMzQixVQUFVQSxnQkFBZ0I7SUFDdkJBLGdCQUFnQixDQUFDLGFBQWEsR0FBRztJQUNqQ0EsZ0JBQWdCLENBQUMsT0FBTyxHQUFHO0lBQzNCQSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUc7SUFDOUJBLGdCQUFnQixDQUFDLFNBQVMsR0FBRztBQUNqQyxHQUFHQSxvQkFBcUJBLENBQUFBLG1CQUFtQixDQUFDLEtBQzVDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcz9hYzEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBWU04gPSAnMS4wLjAnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwO1xuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG5leHBvcnQgdmFyIFNPQ0tFVF9TVEFURVM7XG4oZnVuY3Rpb24gKFNPQ0tFVF9TVEFURVMpIHtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjb25uZWN0aW5nXCJdID0gMF0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJvcGVuXCJdID0gMV0gPSBcIm9wZW5cIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zaW5nXCJdID0gMl0gPSBcImNsb3NpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zZWRcIl0gPSAzXSA9IFwiY2xvc2VkXCI7XG59KShTT0NLRVRfU1RBVEVTIHx8IChTT0NLRVRfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9TVEFURVM7XG4oZnVuY3Rpb24gKENIQU5ORUxfU1RBVEVTKSB7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJjbG9zZWRcIl0gPSBcImNsb3NlZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiZXJyb3JlZFwiXSA9IFwiZXJyb3JlZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmVkXCJdID0gXCJqb2luZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImpvaW5pbmdcIl0gPSBcImpvaW5pbmdcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImxlYXZpbmdcIl0gPSBcImxlYXZpbmdcIjtcbn0pKENIQU5ORUxfU1RBVEVTIHx8IChDSEFOTkVMX1NUQVRFUyA9IHt9KSk7XG5leHBvcnQgdmFyIENIQU5ORUxfRVZFTlRTO1xuKGZ1bmN0aW9uIChDSEFOTkVMX0VWRU5UUykge1xuICAgIENIQU5ORUxfRVZFTlRTW1wiY2xvc2VcIl0gPSBcInBoeF9jbG9zZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiZXJyb3JcIl0gPSBcInBoeF9lcnJvclwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiam9pblwiXSA9IFwicGh4X2pvaW5cIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcInJlcGx5XCJdID0gXCJwaHhfcmVwbHlcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImxlYXZlXCJdID0gXCJwaHhfbGVhdmVcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImFjY2Vzc190b2tlblwiXSA9IFwiYWNjZXNzX3Rva2VuXCI7XG59KShDSEFOTkVMX0VWRU5UUyB8fCAoQ0hBTk5FTF9FVkVOVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBUUkFOU1BPUlRTO1xuKGZ1bmN0aW9uIChUUkFOU1BPUlRTKSB7XG4gICAgVFJBTlNQT1JUU1tcIndlYnNvY2tldFwiXSA9IFwid2Vic29ja2V0XCI7XG59KShUUkFOU1BPUlRTIHx8IChUUkFOU1BPUlRTID0ge30pKTtcbmV4cG9ydCB2YXIgQ09OTkVDVElPTl9TVEFURTtcbihmdW5jdGlvbiAoQ09OTkVDVElPTl9TVEFURSkge1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDb25uZWN0aW5nXCJdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIk9wZW5cIl0gPSBcIm9wZW5cIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2luZ1wiXSA9IFwiY2xvc2luZ1wiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zZWRcIl0gPSBcImNsb3NlZFwiO1xufSkoQ09OTkVDVElPTl9TVEFURSB8fCAoQ09OTkVDVElPTl9TVEFURSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJERUZBVUxUX0hFQURFUlMiLCJWU04iLCJERUZBVUxUX1RJTUVPVVQiLCJXU19DTE9TRV9OT1JNQUwiLCJTT0NLRVRfU1RBVEVTIiwiQ0hBTk5FTF9TVEFURVMiLCJDSEFOTkVMX0VWRU5UUyIsIlRSQU5TUE9SVFMiLCJDT05ORUNUSU9OX1NUQVRFIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n} //# sourceMappingURL=push.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9wdXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ3BDLE1BQU1DO0lBQ2pCOzs7Ozs7O0tBT0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFVBQVVOLDJEQUFlLENBQUU7UUFDakUsSUFBSSxDQUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBR0M7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0FDLE9BQU9SLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ1MsZUFBZTtRQUNwQixJQUFJLENBQUNMLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUyxJQUFJO0lBQ2I7SUFDQUEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUMsWUFBWTtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxZQUFZO1FBQ2pCLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSixPQUFPLENBQUNnQixNQUFNLENBQUNDLElBQUksQ0FBQztZQUNyQkMsT0FBTyxJQUFJLENBQUNsQixPQUFPLENBQUNrQixLQUFLO1lBQ3pCakIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCSyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiWSxVQUFVLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLFFBQVE7UUFDbkM7SUFDSjtJQUNBQyxjQUFjbkIsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHb0IsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLE9BQU8sR0FBR0E7SUFDbEU7SUFDQXNCLFFBQVFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNiLFlBQVksQ0FBQ1csU0FBUztZQUMzQkMsU0FBUyxDQUFDQyxLQUFLLElBQUksQ0FBQ25CLFlBQVksTUFBTSxRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHQyxRQUFRO1FBQ3RGO1FBQ0EsSUFBSSxDQUFDbkIsUUFBUSxDQUFDUSxJQUFJLENBQUM7WUFBRVE7WUFBUUM7UUFBUztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBWCxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNWLFlBQVksRUFBRTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNnQixNQUFNLENBQUNhLFFBQVE7UUFDdkMsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQ1YsT0FBTyxDQUFDOEIsZUFBZSxDQUFDLElBQUksQ0FBQ3ZCLEdBQUc7UUFDckQsTUFBTW1CLFdBQVcsQ0FBQ3hCO1lBQ2QsSUFBSSxDQUFDVSxlQUFlO1lBQ3BCLElBQUksQ0FBQ21CLGNBQWM7WUFDbkIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHTjtZQUNwQixJQUFJLENBQUM4QixhQUFhLENBQUM5QjtRQUN2QjtRQUNBLElBQUksQ0FBQ0YsT0FBTyxDQUFDaUMsR0FBRyxDQUFDLElBQUksQ0FBQ3ZCLFFBQVEsRUFBRSxDQUFDLEdBQUdnQjtRQUNwQyxJQUFJLENBQUNyQixZQUFZLEdBQUc2QixXQUFXO1lBQzNCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUM3QixHQUFHLElBQUksQ0FBQ2hDLE9BQU87SUFDbkI7SUFDQWdDLFFBQVFWLE1BQU0sRUFBRUcsUUFBUSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDbEIsUUFBUSxFQUNiLElBQUksQ0FBQ1YsT0FBTyxDQUFDb0MsUUFBUSxDQUFDLElBQUksQ0FBQzFCLFFBQVEsRUFBRTtZQUFFZTtZQUFRRztRQUFTO0lBQ2hFO0lBQ0FTLFVBQVU7UUFDTixJQUFJLENBQUN6QixlQUFlO1FBQ3BCLElBQUksQ0FBQ21CLGNBQWM7SUFDdkI7SUFDQW5CLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNGLFFBQVEsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUNzQyxJQUFJLENBQUMsSUFBSSxDQUFDNUIsUUFBUSxFQUFFLENBQUM7SUFDdEM7SUFDQXFCLGlCQUFpQjtRQUNiUSxhQUFhLElBQUksQ0FBQ2xDLFlBQVk7UUFDOUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdDO0lBQ3hCO0lBQ0EwQixjQUFjLEVBQUVQLE1BQU0sRUFBRUcsUUFBUSxFQUFHLEVBQUU7UUFDakMsSUFBSSxDQUFDbkIsUUFBUSxDQUNSK0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVoQixNQUFNLEtBQUtBLFFBQzNCaUIsT0FBTyxDQUFDLENBQUNELElBQU1BLEVBQUVmLFFBQVEsQ0FBQ0U7SUFDbkM7SUFDQWQsYUFBYVcsTUFBTSxFQUFFO1FBQ2pCLE9BQU8sSUFBSSxDQUFDakIsWUFBWSxJQUFJLElBQUksQ0FBQ0EsWUFBWSxDQUFDaUIsTUFBTSxLQUFLQTtJQUM3RDtBQUNKLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvcHVzaC5qcz80NDhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICB0aGlzLnJlZiA9ICcnO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIHNlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gICAgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzXG4gICAgICAgICAgICAuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKVxuICAgICAgICAgICAgLmZvckVhY2goKGgpID0+IGguY2FsbGJhY2socmVzcG9uc2UpKTtcbiAgICB9XG4gICAgX2hhc1JlY2VpdmVkKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVzaC5qcy5tYXAiXSwibmFtZXMiOlsiREVGQVVMVF9USU1FT1VUIiwiUHVzaCIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsImV2ZW50IiwicGF5bG9hZCIsInRpbWVvdXQiLCJzZW50IiwidGltZW91dFRpbWVyIiwidW5kZWZpbmVkIiwicmVmIiwicmVjZWl2ZWRSZXNwIiwicmVjSG9va3MiLCJyZWZFdmVudCIsInJlc2VuZCIsIl9jYW5jZWxSZWZFdmVudCIsInNlbmQiLCJfaGFzUmVjZWl2ZWQiLCJzdGFydFRpbWVvdXQiLCJzb2NrZXQiLCJwdXNoIiwidG9waWMiLCJqb2luX3JlZiIsIl9qb2luUmVmIiwidXBkYXRlUGF5bG9hZCIsIk9iamVjdCIsImFzc2lnbiIsInJlY2VpdmUiLCJzdGF0dXMiLCJjYWxsYmFjayIsIl9hIiwicmVzcG9uc2UiLCJfbWFrZVJlZiIsIl9yZXBseUV2ZW50TmFtZSIsIl9jYW5jZWxUaW1lb3V0IiwiX21hdGNoUmVjZWl2ZSIsIl9vbiIsInNldFRpbWVvdXQiLCJ0cmlnZ2VyIiwiX3RyaWdnZXIiLCJkZXN0cm95IiwiX29mZiIsImNsZWFyVGltZW91dCIsImZpbHRlciIsImgiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\n// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nclass Serializer {\n    constructor(){\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === \"string\") {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return {\n            ref: null,\n            topic: topic,\n            event: event,\n            payload: data\n        };\n    }\n} //# sourceMappingURL=serializer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwySEFBMkg7QUFDM0gsOEVBQThFO0FBQy9ELE1BQU1BO0lBQ2pCQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsT0FBT0MsVUFBVSxFQUFFQyxRQUFRLEVBQUU7UUFDekIsSUFBSUQsV0FBV0gsV0FBVyxLQUFLSyxhQUFhO1lBQ3hDLE9BQU9ELFNBQVMsSUFBSSxDQUFDRSxhQUFhLENBQUNIO1FBQ3ZDO1FBQ0EsSUFBSSxPQUFPQSxlQUFlLFVBQVU7WUFDaEMsT0FBT0MsU0FBU0csS0FBS0MsS0FBSyxDQUFDTDtRQUMvQjtRQUNBLE9BQU9DLFNBQVMsQ0FBQztJQUNyQjtJQUNBRSxjQUFjRyxNQUFNLEVBQUU7UUFDbEIsTUFBTUMsT0FBTyxJQUFJQyxTQUFTRjtRQUMxQixNQUFNRyxVQUFVLElBQUlDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0wsUUFBUUMsTUFBTUU7SUFDL0M7SUFDQUUsaUJBQWlCTCxNQUFNLEVBQUVDLElBQUksRUFBRUUsT0FBTyxFQUFFO1FBQ3BDLE1BQU1HLFlBQVlMLEtBQUtNLFFBQVEsQ0FBQztRQUNoQyxNQUFNQyxZQUFZUCxLQUFLTSxRQUFRLENBQUM7UUFDaEMsSUFBSUUsU0FBUyxJQUFJLENBQUNqQixhQUFhLEdBQUc7UUFDbEMsTUFBTWtCLFFBQVFQLFFBQVFWLE1BQU0sQ0FBQ08sT0FBT1csS0FBSyxDQUFDRixRQUFRQSxTQUFTSDtRQUMzREcsU0FBU0EsU0FBU0g7UUFDbEIsTUFBTU0sUUFBUVQsUUFBUVYsTUFBTSxDQUFDTyxPQUFPVyxLQUFLLENBQUNGLFFBQVFBLFNBQVNEO1FBQzNEQyxTQUFTQSxTQUFTRDtRQUNsQixNQUFNSyxPQUFPZixLQUFLQyxLQUFLLENBQUNJLFFBQVFWLE1BQU0sQ0FBQ08sT0FBT1csS0FBSyxDQUFDRixRQUFRVCxPQUFPYyxVQUFVO1FBQzdFLE9BQU87WUFBRUMsS0FBSztZQUFNTCxPQUFPQTtZQUFPRSxPQUFPQTtZQUFPSSxTQUFTSDtRQUFLO0lBQ2xFO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzPzgxZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2NvbW1pdC9jZjA5OGU5Y2Y3YTQ0ZWU2NDc5ZDMxZDkxMWE5N2QzYzc0MzBjNmZlXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLkhFQURFUl9MRU5HVEggPSAxO1xuICAgIH1cbiAgICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShyYXdQYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gICAgX2JpbmFyeURlY29kZShidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKTtcbiAgICB9XG4gICAgX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgICAgY29uc3QgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgY29uc3QgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDI7XG4gICAgICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCkpKTtcbiAgICAgICAgcmV0dXJuIHsgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbIlNlcmlhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIkhFQURFUl9MRU5HVEgiLCJkZWNvZGUiLCJyYXdQYXlsb2FkIiwiY2FsbGJhY2siLCJBcnJheUJ1ZmZlciIsIl9iaW5hcnlEZWNvZGUiLCJKU09OIiwicGFyc2UiLCJidWZmZXIiLCJ2aWV3IiwiRGF0YVZpZXciLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJfZGVjb2RlQnJvYWRjYXN0IiwidG9waWNTaXplIiwiZ2V0VWludDgiLCJldmVudFNpemUiLCJvZmZzZXQiLCJ0b3BpYyIsInNsaWNlIiwiZXZlbnQiLCJkYXRhIiwiYnl0ZUxlbmd0aCIsInJlZiIsInBheWxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n} //# sourceMappingURL=timer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDYyxNQUFNQTtJQUNqQkMsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLENBQUU7UUFDN0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLEtBQUssR0FBR0M7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0osUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDckI7SUFDQUksUUFBUTtRQUNKLElBQUksQ0FBQ0QsS0FBSyxHQUFHO1FBQ2JFLGFBQWEsSUFBSSxDQUFDSixLQUFLO0lBQzNCO0lBQ0EsOERBQThEO0lBQzlESyxrQkFBa0I7UUFDZEQsYUFBYSxJQUFJLENBQUNKLEtBQUs7UUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdNLFdBQVc7WUFDcEIsSUFBSSxDQUFDSixLQUFLLEdBQUcsSUFBSSxDQUFDQSxLQUFLLEdBQUc7WUFDMUIsSUFBSSxDQUFDSixRQUFRO1FBQ2pCLEdBQUcsSUFBSSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDRyxLQUFLLEdBQUc7SUFDbkM7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzPzExNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIH1cbiAgICAvLyBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDE7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIl0sIm5hbWVzIjpbIlRpbWVyIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsInRpbWVyQ2FsYyIsInRpbWVyIiwidW5kZWZpbmVkIiwidHJpZXMiLCJyZXNldCIsImNsZWFyVGltZW91dCIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl)=>{\n    let url = socketUrl;\n    url = url.replace(/^ws/i, \"http\");\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, \"\");\n    return url.replace(/\\/+$/, \"\");\n}; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0QsMEVBQTBFO0FBQzFFLHlGQUF5RjtBQUNsRixJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxNQUFNLEdBQUc7SUFDdkJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7QUFDakMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qzs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLE1BQU1DLG9CQUFvQixDQUFDQyxTQUFTQyxRQUFRQyxVQUFVLENBQUMsQ0FBQztJQUMzRCxJQUFJQztJQUNKLE1BQU1DLFlBQVksQ0FBQ0QsS0FBS0QsUUFBUUUsU0FBUyxNQUFNLFFBQVFELE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUU7SUFDOUUsT0FBT0UsT0FBT0MsSUFBSSxDQUFDTCxRQUFRTSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7UUFDcENELEdBQUcsQ0FBQ0MsUUFBUSxHQUFHQyxjQUFjRCxTQUFTVCxTQUFTQyxRQUFRRztRQUN2RCxPQUFPSTtJQUNYLEdBQUcsQ0FBQztBQUNSLEVBQUU7QUFDRjs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUUsZ0JBQWdCLENBQUNDLFlBQVlYLFNBQVNDLFFBQVFHO0lBQ3ZELE1BQU1RLFNBQVNaLFFBQVFhLElBQUksQ0FBQyxDQUFDQyxJQUFNQSxFQUFFQyxJQUFJLEtBQUtKO0lBQzlDLE1BQU1LLFVBQVVKLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPSyxJQUFJO0lBQzNFLE1BQU1DLFFBQVFqQixNQUFNLENBQUNVLFdBQVc7SUFDaEMsSUFBSUssV0FBVyxDQUFDWixVQUFVZSxRQUFRLENBQUNILFVBQVU7UUFDekMsT0FBT0ksWUFBWUosU0FBU0U7SUFDaEM7SUFDQSxPQUFPRyxLQUFLSDtBQUNoQixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUUsY0FBYyxDQUFDSCxNQUFNQztJQUM5QiwyQkFBMkI7SUFDM0IsSUFBSUQsS0FBS0ssTUFBTSxDQUFDLE9BQU8sS0FBSztRQUN4QixNQUFNQyxXQUFXTixLQUFLTyxLQUFLLENBQUMsR0FBR1AsS0FBS1EsTUFBTTtRQUMxQyxPQUFPQyxRQUFRUixPQUFPSztJQUMxQjtJQUNBLHdDQUF3QztJQUN4QyxPQUFRTjtRQUNKLEtBQUtuQixjQUFjNkIsSUFBSTtZQUNuQixPQUFPQyxVQUFVVjtRQUNyQixLQUFLcEIsY0FBYytCLE1BQU07UUFDekIsS0FBSy9CLGNBQWNnQyxNQUFNO1FBQ3pCLEtBQUtoQyxjQUFjaUMsSUFBSTtRQUN2QixLQUFLakMsY0FBY2tDLElBQUk7UUFDdkIsS0FBS2xDLGNBQWNtQyxJQUFJO1FBQ3ZCLEtBQUtuQyxjQUFjb0MsT0FBTztRQUMxQixLQUFLcEMsY0FBY3FDLEdBQUc7WUFDbEIsT0FBT0MsU0FBU2xCO1FBQ3BCLEtBQUtwQixjQUFjdUMsSUFBSTtRQUN2QixLQUFLdkMsY0FBY3dDLEtBQUs7WUFDcEIsT0FBT0MsT0FBT3JCO1FBQ2xCLEtBQUtwQixjQUFjMEMsU0FBUztZQUN4QixPQUFPQyxrQkFBa0J2QixRQUFRLHlDQUF5QztRQUM5RSxLQUFLcEIsY0FBYzRDLE9BQU87UUFDMUIsS0FBSzVDLGNBQWM2QyxJQUFJO1FBQ3ZCLEtBQUs3QyxjQUFjOEMsU0FBUztRQUM1QixLQUFLOUMsY0FBYytDLFNBQVM7UUFDNUIsS0FBSy9DLGNBQWNnRCxTQUFTO1FBQzVCLEtBQUtoRCxjQUFjaUQsS0FBSztRQUN4QixLQUFLakQsY0FBY2tELE9BQU87UUFDMUIsS0FBS2xELGNBQWNtRCxJQUFJO1FBQ3ZCLEtBQUtuRCxjQUFjb0QsSUFBSTtRQUN2QixLQUFLcEQsY0FBY3FELFdBQVc7UUFDOUIsS0FBS3JELGNBQWNzRCxNQUFNO1FBQ3pCLEtBQUt0RCxjQUFjdUQsT0FBTztRQUMxQixLQUFLdkQsY0FBY3dELFNBQVM7WUFDeEIsT0FBT2pDLEtBQUtIO1FBQ2hCO1lBQ0ksdUNBQXVDO1lBQ3ZDLE9BQU9HLEtBQUtIO0lBQ3BCO0FBQ0osRUFBRTtBQUNGLE1BQU1HLE9BQU8sQ0FBQ0g7SUFDVixPQUFPQTtBQUNYO0FBQ08sTUFBTVUsWUFBWSxDQUFDVjtJQUN0QixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWDtZQUNJLE9BQU9BO0lBQ2Y7QUFDSixFQUFFO0FBQ0ssTUFBTWtCLFdBQVcsQ0FBQ2xCO0lBQ3JCLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzNCLE1BQU1xQyxjQUFjQyxXQUFXdEM7UUFDL0IsSUFBSSxDQUFDdUMsT0FBT0MsS0FBSyxDQUFDSCxjQUFjO1lBQzVCLE9BQU9BO1FBQ1g7SUFDSjtJQUNBLE9BQU9yQztBQUNYLEVBQUU7QUFDSyxNQUFNcUIsU0FBUyxDQUFDckI7SUFDbkIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsSUFBSTtZQUNBLE9BQU95QyxLQUFLQyxLQUFLLENBQUMxQztRQUN0QixFQUNBLE9BQU8yQyxPQUFPO1lBQ1ZDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGtCQUFrQixFQUFFRixNQUFNLENBQUM7WUFDeEMsT0FBTzNDO1FBQ1g7SUFDSjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1RLFVBQVUsQ0FBQ1IsT0FBT0Q7SUFDM0IsSUFBSSxPQUFPQyxVQUFVLFVBQVU7UUFDM0IsT0FBT0E7SUFDWDtJQUNBLE1BQU04QyxVQUFVOUMsTUFBTU8sTUFBTSxHQUFHO0lBQy9CLE1BQU13QyxhQUFhL0MsS0FBSyxDQUFDOEMsUUFBUTtJQUNqQyxNQUFNRSxZQUFZaEQsS0FBSyxDQUFDLEVBQUU7SUFDMUIsK0RBQStEO0lBQy9ELElBQUlnRCxjQUFjLE9BQU9ELGVBQWUsS0FBSztRQUN6QyxJQUFJRTtRQUNKLE1BQU1DLFVBQVVsRCxNQUFNTSxLQUFLLENBQUMsR0FBR3dDO1FBQy9CLCtEQUErRDtRQUMvRCxJQUFJO1lBQ0FHLE1BQU1SLEtBQUtDLEtBQUssQ0FBQyxNQUFNUSxVQUFVO1FBQ3JDLEVBQ0EsT0FBT0MsR0FBRztZQUNOLDREQUE0RDtZQUM1REYsTUFBTUMsVUFBVUEsUUFBUUUsS0FBSyxDQUFDLE9BQU8sRUFBRTtRQUMzQztRQUNBLE9BQU9ILElBQUlJLEdBQUcsQ0FBQyxDQUFDQyxNQUFRcEQsWUFBWUgsTUFBTXVEO0lBQzlDO0lBQ0EsT0FBT3REO0FBQ1gsRUFBRTtBQUNGOzs7Ozs7Q0FNQyxHQUNNLE1BQU11QixvQkFBb0IsQ0FBQ3ZCO0lBQzlCLElBQUksT0FBT0EsVUFBVSxVQUFVO1FBQzNCLE9BQU9BLE1BQU11RCxPQUFPLENBQUMsS0FBSztJQUM5QjtJQUNBLE9BQU92RDtBQUNYLEVBQUU7QUFDSyxNQUFNd0Qsa0JBQWtCLENBQUNDO0lBQzVCLElBQUlDLE1BQU1EO0lBQ1ZDLE1BQU1BLElBQUlILE9BQU8sQ0FBQyxRQUFRO0lBQzFCRyxNQUFNQSxJQUFJSCxPQUFPLENBQUMsbURBQW1EO0lBQ3JFLE9BQU9HLElBQUlILE9BQU8sQ0FBQyxRQUFRO0FBQy9CLEVBQUUsQ0FDRix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanM/M2ZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCB0aGUgY2hhbmdlIFBheWxvYWQgaW50byBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxuZXhwb3J0IHZhciBQb3N0Z3Jlc1R5cGVzO1xuKGZ1bmN0aW9uIChQb3N0Z3Jlc1R5cGVzKSB7XG4gICAgUG9zdGdyZXNUeXBlc1tcImFic3RpbWVcIl0gPSBcImFic3RpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlXCJdID0gXCJkYXRlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImRhdGVyYW5nZVwiXSA9IFwiZGF0ZXJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0NFwiXSA9IFwiZmxvYXQ0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0OFwiXSA9IFwiZmxvYXQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDJcIl0gPSBcImludDJcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NFwiXSA9IFwiaW50NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ0cmFuZ2VcIl0gPSBcImludDRyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4XCJdID0gXCJpbnQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDhyYW5nZVwiXSA9IFwiaW50OHJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25cIl0gPSBcImpzb25cIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wianNvbmJcIl0gPSBcImpzb25iXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm1vbmV5XCJdID0gXCJtb25leVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJudW1lcmljXCJdID0gXCJudW1lcmljXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm9pZFwiXSA9IFwib2lkXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInJlbHRpbWVcIl0gPSBcInJlbHRpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lXCJdID0gXCJ0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcFwiXSA9IFwidGltZXN0YW1wXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcHR6XCJdID0gXCJ0aW1lc3RhbXB0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1ldHpcIl0gPSBcInRpbWV0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3JhbmdlXCJdID0gXCJ0c3JhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRzdHpyYW5nZVwiXSA9IFwidHN0enJhbmdlXCI7XG59KShQb3N0Z3Jlc1R5cGVzIHx8IChQb3N0Z3Jlc1R5cGVzID0ge30pKTtcbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgYW4gb2JqZWN0IG9mIHN0cmluZyB2YWx1ZXMgdGhlbiBjb252ZXJ0cyBlYWNoIHN0cmluZyB2YWx1ZVxuICogdG8gaXRzIG1hcHBlZCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbWFwIG9mIHZhcmlvdXMgb3B0aW9ucyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBtYXBwZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2tpcFR5cGVzIFRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKlxuICogQGV4YW1wbGUgY29udmVydENoYW5nZURhdGEoW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTonMzMnfSwge30pXG4gKiAvLz0+eyBmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogMzMgfVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENoYW5nZURhdGEgPSAoY29sdW1ucywgcmVjb3JkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2tpcFR5cGVzID0gKF9hID0gb3B0aW9ucy5za2lwVHlwZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRoZSB2YWx1ZSBvZiBhbiBpbmRpdmlkdWFsIGNvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uTmFtZSBUaGUgY29sdW1uIHRoYXQgeW91IHdhbnQgdG8gY29udmVydFxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnMgQWxsIG9mIHRoZSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIFRoZSBtYXAgb2Ygc3RyaW5nIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheX0gc2tpcFR5cGVzIEFuIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge29iamVjdH0gVXNlbGVzcyBpbmZvcm1hdGlvblxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbXSlcbiAqIC8vPT4gMzNcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbJ2ludDQnXSlcbiAqIC8vPT4gXCIzM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q29sdW1uID0gKGNvbHVtbk5hbWUsIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4udHlwZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXTtcbiAgICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Q2VsbChjb2xUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBub29wKHZhbHVlKTtcbn07XG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBpcyBgbnVsbGAsIHJldHVybnMgbnVsbC5cbiAqIE90aGVyd2lzZSBjb252ZXJ0cyB0aGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHBvc3RncmVzIGNvbHVtbiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNlbGwgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnYm9vbCcsICd0JylcbiAqIC8vPT4gdHJ1ZVxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2ludDgnLCAnMTAnKVxuICogLy89PiAxMFxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ19pbnQ0JywgJ3sxLDIsMyw0fScpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENlbGwgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgICBpZiAodHlwZS5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGUuc2xpY2UoMSwgdHlwZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdG9BcnJheSh2YWx1ZSwgZGF0YVR5cGUpO1xuICAgIH1cbiAgICAvLyBJZiBub3QgbnVsbCwgY29udmVydCB0byBjb3JyZWN0IHR5cGUuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5ib29sOlxuICAgICAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgICAgICAgIHJldHVybiB0b0pzb24odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wOlxuICAgICAgICAgICAgcmV0dXJuIHRvVGltZXN0YW1wU3RyaW5nKHZhbHVlKTsgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmFic3RpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDRyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMucmVsdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcHR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3R6cmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3Qgbm9vcCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Cb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEpTT04gcGFyc2UgZXJyb3I6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBQb3N0Z3JlcyBBcnJheSBpbnRvIGEgbmF0aXZlIEpTIGFycmF5XG4gKlxuICogQGV4YW1wbGUgdG9BcnJheSgne30nLCAnaW50NCcpXG4gKiAvLz0+IFtdXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7XCJbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKVwiLFwiKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl1cIn0nLCAnZGF0ZXJhbmdlJylcbiAqIC8vPT4gWydbMjAyMS0wMS0wMSwyMDIxLTEyLTMxKScsICcoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXSddXG4gKiBAZXhhbXBsZSB0b0FycmF5KFsxLDIsMyw0XSwgJ2ludDQnKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RJZHggPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGNsb3NlQnJhY2UgPSB2YWx1ZVtsYXN0SWR4XTtcbiAgICBjb25zdCBvcGVuQnJhY2UgPSB2YWx1ZVswXTtcbiAgICAvLyBDb25maXJtIHZhbHVlIGlzIGEgUG9zdGdyZXMgYXJyYXkgYnkgY2hlY2tpbmcgY3VybHkgYnJhY2tldHNcbiAgICBpZiAob3BlbkJyYWNlID09PSAneycgJiYgY2xvc2VCcmFjZSA9PT0gJ30nKSB7XG4gICAgICAgIGxldCBhcnI7XG4gICAgICAgIGNvbnN0IHZhbFRyaW0gPSB2YWx1ZS5zbGljZSgxLCBsYXN0SWR4KTtcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiB0byBzZXBhcmF0ZSBQb3N0Z3JlcyBhcnJheSBkYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhcnIgPSBKU09OLnBhcnNlKCdbJyArIHZhbFRyaW0gKyAnXScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBzcGxpdHRpbmcgb24gY29tbWEgZG9lcyBub3QgY292ZXIgYWxsIGVkZ2UgY2FzZXNcbiAgICAgICAgICAgIGFyciA9IHZhbFRyaW0gPyB2YWxUcmltLnNwbGl0KCcsJykgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyLm1hcCgodmFsKSA9PiBjb252ZXJ0Q2VsbCh0eXBlLCB2YWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbi8qKlxuICogRml4ZXMgdGltZXN0YW1wIHRvIGJlIElTTy04NjAxLiBTd2FwcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgZGF0ZSBhbmQgdGltZSBmb3IgYSAnVCdcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UvaXNzdWVzLzE4XG4gKlxuICogQGV4YW1wbGUgdG9UaW1lc3RhbXBTdHJpbmcoJzIwMTktMDktMTAgMDA6MDA6MDAnKVxuICogLy89PiAnMjAxOS0wOS0xMFQwMDowMDowMCdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvVGltZXN0YW1wU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJyAnLCAnVCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IGh0dHBFbmRwb2ludFVSTCA9IChzb2NrZXRVcmwpID0+IHtcbiAgICBsZXQgdXJsID0gc29ja2V0VXJsO1xuICAgIHVybCA9IHVybC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKTtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvKFxcL3NvY2tldFxcL3dlYnNvY2tldHxcXC9zb2NrZXR8XFwvd2Vic29ja2V0KVxcLz8kL2ksICcnKTtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyskLywgJycpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybWVycy5qcy5tYXAiXSwibmFtZXMiOlsiUG9zdGdyZXNUeXBlcyIsImNvbnZlcnRDaGFuZ2VEYXRhIiwiY29sdW1ucyIsInJlY29yZCIsIm9wdGlvbnMiLCJfYSIsInNraXBUeXBlcyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJyZWNfa2V5IiwiY29udmVydENvbHVtbiIsImNvbHVtbk5hbWUiLCJjb2x1bW4iLCJmaW5kIiwieCIsIm5hbWUiLCJjb2xUeXBlIiwidHlwZSIsInZhbHVlIiwiaW5jbHVkZXMiLCJjb252ZXJ0Q2VsbCIsIm5vb3AiLCJjaGFyQXQiLCJkYXRhVHlwZSIsInNsaWNlIiwibGVuZ3RoIiwidG9BcnJheSIsImJvb2wiLCJ0b0Jvb2xlYW4iLCJmbG9hdDQiLCJmbG9hdDgiLCJpbnQyIiwiaW50NCIsImludDgiLCJudW1lcmljIiwib2lkIiwidG9OdW1iZXIiLCJqc29uIiwianNvbmIiLCJ0b0pzb24iLCJ0aW1lc3RhbXAiLCJ0b1RpbWVzdGFtcFN0cmluZyIsImFic3RpbWUiLCJkYXRlIiwiZGF0ZXJhbmdlIiwiaW50NHJhbmdlIiwiaW50OHJhbmdlIiwibW9uZXkiLCJyZWx0aW1lIiwidGV4dCIsInRpbWUiLCJ0aW1lc3RhbXB0eiIsInRpbWV0eiIsInRzcmFuZ2UiLCJ0c3R6cmFuZ2UiLCJwYXJzZWRWYWx1ZSIsInBhcnNlRmxvYXQiLCJOdW1iZXIiLCJpc05hTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImxhc3RJZHgiLCJjbG9zZUJyYWNlIiwib3BlbkJyYWNlIiwiYXJyIiwidmFsVHJpbSIsIl8iLCJzcGxpdCIsIm1hcCIsInZhbCIsInJlcGxhY2UiLCJodHRwRW5kcG9pbnRVUkwiLCJzb2NrZXRVcmwiLCJ1cmwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"2.11.2\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz8xZmQ1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuMTEuMic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/StorageClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient)\n/* harmony export */ });\n/* harmony import */ var _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packages/StorageFileApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\");\n/* harmony import */ var _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packages/StorageBucketApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\");\n\n\nclass StorageClient extends _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, headers = {}, fetch){\n        super(url, headers, fetch);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */ from(id) {\n        return new _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.url, this.headers, id, this.fetch);\n    }\n} //# sourceMappingURL=StorageClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvU3RvcmFnZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDSTtBQUNwRCxNQUFNRSxzQkFBc0JELGtFQUFnQkE7SUFDL0NFLFlBQVlDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxDQUFFO1FBQ2xDLEtBQUssQ0FBQ0YsS0FBS0MsU0FBU0M7SUFDeEI7SUFDQTs7OztLQUlDLEdBQ0RDLEtBQUtDLEVBQUUsRUFBRTtRQUNMLE9BQU8sSUFBSVIsZ0VBQWNBLENBQUMsSUFBSSxDQUFDSSxHQUFHLEVBQUUsSUFBSSxDQUFDQyxPQUFPLEVBQUVHLElBQUksSUFBSSxDQUFDRixLQUFLO0lBQ3BFO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvU3RvcmFnZUNsaWVudC5qcz9hOGNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJztcbmltcG9ydCBTdG9yYWdlQnVja2V0QXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaSc7XG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgYnVja2V0IGlkIHRvIG9wZXJhdGUgb24uXG4gICAgICovXG4gICAgZnJvbShpZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJTdG9yYWdlRmlsZUFwaSIsIlN0b3JhZ2VCdWNrZXRBcGkiLCJTdG9yYWdlQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2giLCJmcm9tIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQztBQUM3QixNQUFNQyxrQkFBa0I7SUFBRSxpQkFBaUIsQ0FBQyxXQUFXLEVBQUVELDZDQUFPQSxDQUFDLENBQUM7QUFBQyxFQUFFLENBQzVFLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzPzc5OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJERUZBVUxUX0hFQURFUlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError)\n/* harmony export */ });\nclass StorageError extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n}\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nclass StorageApiError extends StorageError {\n    constructor(message, status){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status\n        };\n    }\n}\nclass StorageUnknownError extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sTUFBTUEscUJBQXFCQztJQUM5QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTQyxlQUFlQyxLQUFLO0lBQ2hDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUNoRjtBQUNPLE1BQU1DLHdCQUF3QlI7SUFDakNFLFlBQVlDLE9BQU8sRUFBRU0sTUFBTSxDQUFFO1FBQ3pCLEtBQUssQ0FBQ047UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0ksTUFBTSxHQUFHQTtJQUNsQjtJQUNBQyxTQUFTO1FBQ0wsT0FBTztZQUNITCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmRixTQUFTLElBQUksQ0FBQ0EsT0FBTztZQUNyQk0sUUFBUSxJQUFJLENBQUNBLE1BQU07UUFDdkI7SUFDSjtBQUNKO0FBQ08sTUFBTUUsNEJBQTRCWDtJQUNyQ0UsWUFBWUMsT0FBTyxFQUFFUyxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTyxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcz80YTlhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBTdG9yYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fX2lzU3RvcmFnZUVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNTdG9yYWdlRXJyb3InIGluIGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBcGlFcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUFwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VVbmtub3duRXJyb3IgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIlN0b3JhZ2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiX19pc1N0b3JhZ2VFcnJvciIsIm5hbWUiLCJpc1N0b3JhZ2VFcnJvciIsImVycm9yIiwiU3RvcmFnZUFwaUVycm9yIiwic3RhdHVzIiwidG9KU09OIiwiU3RvcmFnZVVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/fetch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject, options)=>__awaiter(void 0, void 0, void 0, function*() {\n        const Res = yield (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveResponse)();\n        if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n            error.json().then((err)=>{\n                reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageApiError(_getErrorMessage(err), error.status || 500));\n            }).catch((err)=>{\n                reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(err), err));\n            });\n        } else {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(error), error));\n        }\n    });\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    if (body) {\n        params.body = JSON.stringify(body);\n    }\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve, reject)=>{\n            fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n                if (!result.ok) throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n                return result.json();\n            }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n        });\n    });\n}\nfunction get(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"GET\", url, options, parameters);\n    });\n}\nfunction post(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n    });\n}\nfunction put(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"PUT\", url, options, parameters, body);\n    });\n}\nfunction head(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"HEAD\", url, Object.assign(Object.assign({}, options), {\n            noResolveJson: true\n        }), parameters);\n    });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body);\n    });\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDZ0U7QUFDcEI7QUFDNUMsTUFBTVUsbUJBQW1CLENBQUNDLE1BQVFBLElBQUlDLEdBQUcsSUFBSUQsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSUksS0FBSyxJQUFJ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SyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPNkMsZUFBZUMsU0FBUyxPQUFPQyxLQUFLaEIsU0FBU1EsWUFBWUM7SUFDcEU7QUFDSjtBQUNPLFNBQVNhLEtBQUtQLE9BQU8sRUFBRUMsR0FBRyxFQUFFaEIsT0FBTyxFQUFFUSxVQUFVO0lBQ2xELE9BQU92QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE9BQU82QyxlQUFlQyxTQUFTLFFBQVFDLEtBQUtKLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2IsVUFBVTtZQUFFRSxlQUFlO1FBQUssSUFBSU07SUFDcEg7QUFDSjtBQUNPLFNBQVNlLE9BQU9SLE9BQU8sRUFBRUMsR0FBRyxFQUFFUCxJQUFJLEVBQUVULE9BQU8sRUFBRVEsVUFBVTtJQUMxRCxPQUFPdkMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPNkMsZUFBZUMsU0FBUyxVQUFVQyxLQUFLaEIsU0FBU1EsWUFBWUM7SUFDdkU7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanM/YzA0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IFN0b3JhZ2VBcGlFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IHJlc29sdmVSZXNwb25zZSB9IGZyb20gJy4vaGVscGVycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBoYW5kbGVFcnJvciA9IChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBSZXMgPSB5aWVsZCByZXNvbHZlUmVzcG9uc2UoKTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBSZXMgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbikpIHtcbiAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIC5qc29uKClcbiAgICAgICAgICAgIC50aGVuKChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgU3RvcmFnZUFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIGVycikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgZXJyb3IpKTtcbiAgICB9XG59KTtcbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuZnVuY3Rpb24gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0Lm9rKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuanNvbigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0dFVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycyk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zdChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BPU1QnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHB1dChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BVVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGVhZChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0hFQUQnLCB1cmwsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgbm9SZXNvbHZlSnNvbjogdHJ1ZSB9KSwgcGFyYW1ldGVycyk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnREVMRVRFJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJTdG9yYWdlQXBpRXJyb3IiLCJTdG9yYWdlVW5rbm93bkVycm9yIiwicmVzb2x2ZVJlc3BvbnNlIiwiX2dldEVycm9yTWVzc2FnZSIsImVyciIsIm1zZyIsIm1lc3NhZ2UiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImhhbmRsZUVycm9yIiwib3B0aW9ucyIsIlJlcyIsIm5vUmVzb2x2ZUpzb24iLCJqc29uIiwic3RhdHVzIiwiY2F0Y2giLCJfZ2V0UmVxdWVzdFBhcmFtcyIsIm1ldGhvZCIsInBhcmFtZXRlcnMiLCJib2R5IiwicGFyYW1zIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsIl9oYW5kbGVSZXF1ZXN0IiwiZmV0Y2hlciIsInVybCIsIm9rIiwiZGF0YSIsImdldCIsInBvc3QiLCJwdXQiLCJoZWFkIiwicmVtb3ZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/helpers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursiveToCamel: () => (/* binding */ recursiveToCamel),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse)\n/* harmony export */ });\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst resolveResponse = ()=>__awaiter(void 0, void 0, void 0, function*() {\n        if (typeof Response === \"undefined\") {\n            // @ts-ignore\n            return (yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23))).Response;\n        }\n        return Response;\n    });\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) {\n        return item.map((el)=>recursiveToCamel(el));\n    } else if (typeof item === \"function\" || item !== Object(item)) {\n        return item;\n    }\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n}; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsSUFBSUEsWUFBWSxTQUFLLElBQUksU0FBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ08sTUFBTU8sZUFBZSxDQUFDQztJQUN6QixJQUFJQztJQUNKLElBQUlELGFBQWE7UUFDYkMsU0FBU0Q7SUFDYixPQUNLLElBQUksT0FBT0UsVUFBVSxhQUFhO1FBQ25DRCxTQUFTLENBQUMsR0FBR0UsT0FBUyxnTEFBTyxDQUF3Qk4sSUFBSSxDQUFDLENBQUMsRUFBRU8sU0FBU0YsTUFBSyxFQUFFLEdBQUtBLFVBQVNDO0lBQy9GLE9BQ0s7UUFDREYsU0FBU0M7SUFDYjtJQUNBLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRixVQUFVRTtBQUNsQyxFQUFFO0FBQ0ssTUFBTUUsa0JBQWtCLElBQU16QixVQUFVLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25FLElBQUksT0FBTzBCLGFBQWEsYUFBYTtZQUNqQyxhQUFhO1lBQ2IsT0FBTyxDQUFDLE1BQU0sZ0xBQTZCLEVBQUdBLFFBQVE7UUFDMUQ7UUFDQSxPQUFPQTtJQUNYLEdBQUc7QUFDSSxNQUFNQyxtQkFBbUIsQ0FBQ0M7SUFDN0IsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1FBQ3JCLE9BQU9BLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQyxLQUFPTCxpQkFBaUJLO0lBQzdDLE9BQ0ssSUFBSSxPQUFPSixTQUFTLGNBQWNBLFNBQVNLLE9BQU9MLE9BQU87UUFDMUQsT0FBT0E7SUFDWDtJQUNBLE1BQU1iLFNBQVMsQ0FBQztJQUNoQmtCLE9BQU9DLE9BQU8sQ0FBQ04sTUFBTU8sT0FBTyxDQUFDLENBQUMsQ0FBQ0MsS0FBSzlCLE1BQU07UUFDdEMsTUFBTStCLFNBQVNELElBQUlFLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQ0MsSUFBTUEsRUFBRUMsV0FBVyxHQUFHRixPQUFPLENBQUMsU0FBUztRQUNwRnZCLE1BQU0sQ0FBQ3NCLE9BQU8sR0FBR1YsaUJBQWlCckI7SUFDdEM7SUFDQSxPQUFPUztBQUNYLEVBQUUsQ0FDRixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanM/YTQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCByZXNvbHZlUmVzcG9uc2UgPSAoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAoeWllbGQgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpKS5SZXNwb25zZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlO1xufSk7XG5leHBvcnQgY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubWFwKChlbCkgPT4gcmVjdXJzaXZlVG9DYW1lbChlbCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyB8fCBpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdLZXkgPSBrZXkucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvWy1fXS9nLCAnJykpO1xuICAgICAgICByZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJfZmV0Y2giLCJmZXRjaCIsImFyZ3MiLCJkZWZhdWx0IiwicmVzb2x2ZVJlc3BvbnNlIiwiUmVzcG9uc2UiLCJyZWN1cnNpdmVUb0NhbWVsIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImVsIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJuZXdLZXkiLCJyZXBsYWNlIiwiYyIsInRvVXBwZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// generated by genversion\nconst version = \"2.7.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDBCQUEwQjtBQUNuQixNQUFNQSxVQUFVLFFBQVEsQ0FDL0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzP2ZhMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2VuZXJhdGVkIGJ5IGdlbnZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNy4xJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageBucketApi)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass StorageBucketApi {\n    constructor(url, headers = {}, fetch){\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */ listBuckets() {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket`, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */ getBucket(id) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket/${id}`, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     */ createBucket(id, options = {\n        public: false\n    }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */ updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put)(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */ emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */ deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=StorageBucketApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNtRDtBQUNKO0FBQ087QUFDUjtBQUMvQixNQUFNYztJQUNqQkMsWUFBWUMsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxLQUFLLENBQUU7UUFDbEMsSUFB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LE9BQU87Z0JBQUs7WUFDL0IsRUFDQSxPQUFPQSxPQUFPO2dCQUNWLElBQUlmLDJEQUFjQSxDQUFDZSxRQUFRO29CQUN2QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpLmpzP2I1MjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuICAgICAqL1xuICAgIGxpc3RCdWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXRgLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFN0b3JhZ2UgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIGNyZWF0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuIEJ5IGRlZmF1bHQsIGJ1Y2tldHMgYXJlIHByaXZhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG4gICAgICogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuICAgICAqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG4gICAgICogQHJldHVybnMgbmV3bHkgY3JlYXRlZCBidWNrZXQgaWRcbiAgICAgKi9cbiAgICBjcmVhdGVCdWNrZXQoaWQsIG9wdGlvbnMgPSB7XG4gICAgICAgIHB1YmxpYzogZmFsc2UsXG4gICAgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBTdG9yYWdlIGJ1Y2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBidWNrZXQgeW91IGFyZSB1cGRhdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWMgVGhlIHZpc2liaWxpdHkgb2YgdGhlIGJ1Y2tldC4gUHVibGljIGJ1Y2tldHMgZG9uJ3QgcmVxdWlyZSBhbiBhdXRob3JpemF0aW9uIHRva2VuIHRvIGRvd25sb2FkIG9iamVjdHMsIGJ1dCBzdGlsbCByZXF1aXJlIGEgdmFsaWQgdG9rZW4gZm9yIGFsbCBvdGhlciBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZpbGVTaXplTGltaXQgc3BlY2lmaWVzIHRoZSBtYXggZmlsZSBzaXplIGluIGJ5dGVzIHRoYXQgY2FuIGJlIHVwbG9hZGVkIHRvIHRoaXMgYnVja2V0LlxuICAgICAqIFRoZSBnbG9iYWwgZmlsZSBzaXplIGxpbWl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHZhbHVlLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGRvZXNuJ3Qgc2V0IGEgcGVyIGJ1Y2tldCBmaWxlIHNpemUgbGltaXQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyBzcGVjaWZpZXMgdGhlIGFsbG93ZWQgbWltZSB0eXBlcyB0aGF0IHRoaXMgYnVja2V0IGNhbiBhY2NlcHQgZHVyaW5nIHVwbG9hZC5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBhbGxvd3MgZmlsZXMgd2l0aCBhbGwgbWltZSB0eXBlcyB0byBiZSB1cGxvYWRlZC5cbiAgICAgKiBFYWNoIG1pbWUgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIGEgd2lsZGNhcmQsIGUuZy4gaW1hZ2UvKiwgb3IgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIGUuZy4gaW1hZ2UvcG5nLlxuICAgICAqL1xuICAgIHVwZGF0ZUJ1Y2tldChpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcHV0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5QnVja2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGJ1Y2tldC4gQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0LlxuICAgICAqIFlvdSBtdXN0IGZpcnN0IGBlbXB0eSgpYCB0aGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGRlbGV0ZS5cbiAgICAgKi9cbiAgICBkZWxldGVCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlbW92ZSh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwge30sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQnVja2V0QXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJERUZBVUxUX0hFQURFUlMiLCJpc1N0b3JhZ2VFcnJvciIsImdldCIsInBvc3QiLCJwdXQiLCJyZW1vdmUiLCJyZXNvbHZlRmV0Y2giLCJTdG9yYWdlQnVja2V0QXBpIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2giLCJPYmplY3QiLCJhc3NpZ24iLCJsaXN0QnVja2V0cyIsImRhdGEiLCJlcnJvciIsImdldEJ1Y2tldCIsImlkIiwiY3JlYXRlQnVja2V0Iiwib3B0aW9ucyIsInB1YmxpYyIsIm5hbWUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiZGVsZXRlQnVja2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageFileApi)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nclass StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch){\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveFetch)(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                let headers = Object.assign(Object.assign({}, this.headers), method === \"POST\" && {\n                    \"x-upsert\": String(options.upsert)\n                });\n                const metadata = options.metadata;\n                if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append(\"cacheControl\", options.cacheControl);\n                    if (metadata) {\n                        body.append(\"metadata\", this.encodeMetadata(metadata));\n                    }\n                    body.append(\"\", fileBody);\n                } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append(\"cacheControl\", options.cacheControl);\n                    if (metadata) {\n                        body.append(\"metadata\", this.encodeMetadata(metadata));\n                    }\n                } else {\n                    body = fileBody;\n                    headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                    headers[\"content-type\"] = options.contentType;\n                    if (metadata) {\n                        headers[\"x-metadata\"] = this.toBase64(this.encodeMetadata(metadata));\n                    }\n                }\n                if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {\n                    headers = Object.assign(Object.assign({}, headers), fileOptions.headers);\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({\n                    method,\n                    body: body,\n                    headers\n                }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                    duplex: options.duplex\n                } : {}));\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: {\n                            path: cleanPath,\n                            id: data.Id,\n                            fullPath: data.Key\n                        },\n                        error: null\n                    };\n                } else {\n                    const error = data;\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const cleanPath = this._removeEmptyFolders(path);\n            const _path = this._getFinalPath(cleanPath);\n            const url = new URL(this.url + `/object/upload/sign/${_path}`);\n            url.searchParams.set(\"token\", token);\n            try {\n                let body;\n                const options = Object.assign({\n                    upsert: DEFAULT_FILE_OPTIONS.upsert\n                }, fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), {\n                    \"x-upsert\": String(options.upsert)\n                });\n                if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append(\"cacheControl\", options.cacheControl);\n                    body.append(\"\", fileBody);\n                } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append(\"cacheControl\", options.cacheControl);\n                } else {\n                    body = fileBody;\n                    headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                    headers[\"content-type\"] = options.contentType;\n                }\n                const res = yield this.fetch(url.toString(), {\n                    method: \"PUT\",\n                    body: body,\n                    headers\n                });\n                const data = yield res.json();\n                if (res.ok) {\n                    return {\n                        data: {\n                            path: cleanPath,\n                            fullPath: data.Key\n                        },\n                        error: null\n                    };\n                } else {\n                    const error = data;\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */ createSignedUploadUrl(path, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                let _path = this._getFinalPath(path);\n                const headers = Object.assign({}, this.headers);\n                if (options === null || options === void 0 ? void 0 : options.upsert) {\n                    headers[\"x-upsert\"] = \"true\";\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {\n                    headers\n                });\n                const url = new URL(this.url + data.url);\n                const token = url.searchParams.get(\"token\");\n                if (!token) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageError(\"No token returned by API\");\n                }\n                return {\n                    data: {\n                        signedUrl: url.toString(),\n                        path,\n                        token\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */ move(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */ copy(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: {\n                        path: data.Key\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ createSignedUrl(path, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                let _path = this._getFinalPath(path);\n                let data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({\n                    expiresIn\n                }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                    transform: options.transform\n                } : {}), {\n                    headers: this.headers\n                });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n                data = {\n                    signedUrl\n                };\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */ createSignedUrls(paths, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {\n                    expiresIn,\n                    paths\n                }, {\n                    headers: this.headers\n                });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n                return {\n                    data: data.map((datum)=>Object.assign(Object.assign({}, datum), {\n                            signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null\n                        })),\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ download(path, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\";\n            const renderPath = wantsTransformation ? \"render/image/authenticated\" : \"object\";\n            const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n            const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                    headers: this.headers,\n                    noResolveJson: true\n                });\n                const data = yield res.blob();\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing file.\n     * @param path\n     */ info(path) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const _path = this._getFinalPath(path);\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/object/info/${_path}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.recursiveToCamel)(data),\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks the existence of a file.\n     * @param path\n     */ exists(path) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const _path = this._getFinalPath(path);\n            try {\n                yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.head)(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: true,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error) && error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError) {\n                    const originalError = error.originalError;\n                    if ([\n                        400,\n                        404\n                    ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {\n                        return {\n                            data: false,\n                            error\n                        };\n                    }\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") {\n            _queryString.push(downloadQueryParam);\n        }\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\";\n        const renderPath = wantsTransformation ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") {\n            _queryString.push(transformationQuery);\n        }\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") {\n            queryString = `?${queryString}`;\n        }\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */ remove(paths) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */ // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */ // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     */ list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {\n                    prefix: path || \"\"\n                });\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {\n                    headers: this.headers\n                }, parameters);\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") {\n            return Buffer.from(data).toString(\"base64\");\n        }\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) {\n            params.push(`width=${transform.width}`);\n        }\n        if (transform.height) {\n            params.push(`height=${transform.height}`);\n        }\n        if (transform.resize) {\n            params.push(`resize=${transform.resize}`);\n        }\n        if (transform.format) {\n            params.push(`format=${transform.format}`);\n        }\n        if (transform.quality) {\n            params.push(`quality=${transform.quality}`);\n        }\n        return params.join(\"&\");\n    }\n} //# sourceMappingURL=StorageFileApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNrRjtBQUMzQjtBQUNTO0FBQ2hFLE1BQU1nQix5QkFBeUI7SUFDM0JDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRO1FBQ0pDLFFBQVE7UUFDUkMsT0FBTztJQUNYO0FB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QUFJdEMsVUFBVXVDLE1BQU0sRUFBRTtZQUNsQkgsT0FBT2IsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFdkIsVUFBVXVDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDO1FBQ0EsSUFBSXZDLFVBQVV3QyxNQUFNLEVBQUU7WUFDbEJKLE9BQU9iLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRXZCLFVBQVV3QyxNQUFNLENBQUMsQ0FBQztRQUM1QztRQUNBLElBQUl4QyxVQUFVeUMsT0FBTyxFQUFFO1lBQ25CTCxPQUFPYixJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUV2QixVQUFVeUMsT0FBTyxDQUFDLENBQUM7UUFDOUM7UUFDQSxPQUFPTCxPQUFPWixJQUFJLENBQUM7SUFDdkI7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaS5qcz8xNThhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0LCBoZWFkLCBwb3N0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVjdXJzaXZlVG9DYW1lbCwgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuY29uc3QgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgICBsaW1pdDogMTAwLFxuICAgIG9mZnNldDogMCxcbiAgICBzb3J0Qnk6IHtcbiAgICAgICAgY29sdW1uOiAnbmFtZScsXG4gICAgICAgIG9yZGVyOiAnYXNjJyxcbiAgICB9LFxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgICB1cHNlcnQ6IGZhbHNlLFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VGaWxlQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgYnVja2V0SWQsIGZldGNoKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWQ7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0aG9kIEhUVFAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIChtZXRob2QgPT09ICdQT1NUJyAmJiB7ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ3gtbWV0YWRhdGEnXSA9IHRoaXMudG9CYXNlNjQodGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuUGF0aCA9IHRoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIHRoaXMuZmV0Y2goYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIE9iamVjdC5hc3NpZ24oeyBtZXRob2QsIGJvZHk6IGJvZHksIGhlYWRlcnMgfSwgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVwbGV4KSA/IHsgZHVwbGV4OiBvcHRpb25zLmR1cGxleCB9IDoge30pKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBwYXRoOiBjbGVhblBhdGgsIGlkOiBkYXRhLklkLCBmdWxsUGF0aDogZGF0YS5LZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGxvYWQocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUE9TVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkVG9TaWduZWRVcmwocGF0aCwgdG9rZW4sIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBgL29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWApO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHVwc2VydDogREVGQVVMVF9GSUxFX09QVElPTlMudXBzZXJ0IH0sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCB7ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5mZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBmdWxsUGF0aDogZGF0YS5LZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAgICogU2lnbmVkIHVwbG9hZCBVUkxzIGNhbiBiZSB1c2VkIHRvIHVwbG9hZCBmaWxlcyB0byB0aGUgYnVja2V0IHdpdGhvdXQgZnVydGhlciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBUaGV5IGFyZSB2YWxpZCBmb3IgMiBob3Vycy5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICovXG4gICAgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ3gtdXBzZXJ0J10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLCB7fSwgeyBoZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBkYXRhLnVybCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgndG9rZW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoJ05vIHRva2VuIHJldHVybmVkIGJ5IEFQSScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNpZ25lZFVybDogdXJsLnRvU3RyaW5nKCksIHBhdGgsIHRva2VuIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICAgIHVwZGF0ZShwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKCdQVVQnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tUGF0aCBUaGUgb3JpZ2luYWwgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIHRvUGF0aCBUaGUgbmV3IGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBuZXcgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLW5ldy5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIG1vdmUoZnJvbVBhdGgsIHRvUGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L21vdmVgLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VLZXk6IGZyb21QYXRoLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uQnVja2V0LFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1jb3B5LnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvY29weWAsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgICAgICAgICAgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwYXRoOiBkYXRhLktleSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTCBleHBpcmVzLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgYSBVUkwgd2hpY2ggaXMgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7X3BhdGh9YCwgT2JqZWN0LmFzc2lnbih7IGV4cGlyZXNJbiB9LCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkpLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgICAgICAgICAgICA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRVcmwgPSBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXRhLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKTtcbiAgICAgICAgICAgICAgICBkYXRhID0geyBzaWduZWRVcmwgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbXVsdGlwbGUgc2lnbmVkIFVSTHMuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhzIFRoZSBmaWxlIHBhdGhzIHRvIGJlIGRvd25sb2FkZWQsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWVzLiBGb3IgZXhhbXBsZSBgWydmb2xkZXIvaW1hZ2UucG5nJywgJ2ZvbGRlcjIvaW1hZ2UyLnBuZyddYC5cbiAgICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTHMgZXhwaXJlLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgVVJMcyB3aGljaCBhcmUgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAgICovXG4gICAgY3JlYXRlU2lnbmVkVXJscyhwYXRocywgZXhwaXJlc0luLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3Qvc2lnbi8ke3RoaXMuYnVja2V0SWR9YCwgeyBleHBpcmVzSW4sIHBhdGhzIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgICAgICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEubWFwKChkYXR1bSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0dW0pLCB7IHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBkb3dubG9hZChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZCcgOiAnb2JqZWN0JztcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlcy5ibG9iKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIGluZm8ocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVjdXJzaXZlVG9DYW1lbChkYXRhKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGV4aXN0ZW5jZSBvZiBhIGZpbGUuXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBleGlzdHMocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGhlYWQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHRydWUsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpICYmIGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZVVua25vd25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEVycm9yID0gZXJyb3Iub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFs0MDAsIDQwNF0uaW5jbHVkZXMob3JpZ2luYWxFcnJvciA9PT0gbnVsbCB8fCBvcmlnaW5hbEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbEVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGZhbHNlLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IHRoZSBVUkwgZm9yIGFuIGFzc2V0IGluIGEgcHVibGljIGJ1Y2tldC4gSWYgeW91IGRvIG5vdCB3YW50IHRvIHVzZSB0aGlzIGZ1bmN0aW9uLCB5b3UgY2FuIGNvbnN0cnVjdCB0aGUgcHVibGljIFVSTCBieSBjb25jYXRlbmF0aW5nIHRoZSBidWNrZXQgVVJMIHdpdGggdGhlIHBhdGggdG8gdGhlIGFzc2V0LlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdmVyaWZ5IGlmIHRoZSBidWNrZXQgaXMgcHVibGljLiBJZiBhIHB1YmxpYyBVUkwgaXMgY3JlYXRlZCBmb3IgYSBidWNrZXQgd2hpY2ggaXMgbm90IHB1YmxpYywgeW91IHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQgdGhlIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggYW5kIG5hbWUgb2YgdGhlIGZpbGUgdG8gZ2VuZXJhdGUgdGhlIHB1YmxpYyBVUkwgZm9yLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgVHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBnZXRQdWJsaWNVcmwocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgY29uc3QgX3F1ZXJ5U3RyaW5nID0gW107XG4gICAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgICA/IGBkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgaWYgKGRvd25sb2FkUXVlcnlQYXJhbSAhPT0gJycpIHtcbiAgICAgICAgICAgIF9xdWVyeVN0cmluZy5wdXNoKGRvd25sb2FkUXVlcnlQYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2FudHNUcmFuc2Zvcm1hdGlvbiA9IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICBjb25zdCByZW5kZXJQYXRoID0gd2FudHNUcmFuc2Zvcm1hdGlvbiA/ICdyZW5kZXIvaW1hZ2UnIDogJ29iamVjdCc7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1hdGlvblF1ZXJ5ICE9PSAnJykge1xuICAgICAgICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2godHJhbnNmb3JtYXRpb25RdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLmpvaW4oJyYnKTtcbiAgICAgICAgaWYgKHF1ZXJ5U3RyaW5nICE9PSAnJykge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmcgPSBgPyR7cXVlcnlTdHJpbmd9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogeyBwdWJsaWNVcmw6IGVuY29kZVVSSShgJHt0aGlzLnVybH0vJHtyZW5kZXJQYXRofS9wdWJsaWMvJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWApIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgZmlsZXMgd2l0aGluIHRoZSBzYW1lIGJ1Y2tldFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGhzIEFuIGFycmF5IG9mIGZpbGVzIHRvIGRlbGV0ZSwgaW5jbHVkaW5nIHRoZSBwYXRoIGFuZCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIFtgJ2ZvbGRlci9pbWFnZS5wbmcnYF0uXG4gICAgICovXG4gICAgcmVtb3ZlKHBhdGhzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCByZW1vdmUodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke3RoaXMuYnVja2V0SWR9YCwgeyBwcmVmaXhlczogcGF0aHMgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIC8vIGFzeW5jIGdldE1ldGFkYXRhKFxuICAgIC8vICAgaWQ6IHN0cmluZ1xuICAgIC8vICk6IFByb21pc2U8XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAgIC8vICAgICAgIGVycm9yOiBudWxsXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IG51bGxcbiAgICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgLy8gICAgIH1cbiAgICAvLyA+IHtcbiAgICAvLyAgIHRyeSB7XG4gICAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB0aHJvdyBlcnJvclxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gbWV0YSB0aGUgbmV3IGZpbGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICAvLyBhc3luYyB1cGRhdGVNZXRhZGF0YShcbiAgICAvLyAgIGlkOiBzdHJpbmcsXG4gICAgLy8gICBtZXRhOiBNZXRhZGF0YVxuICAgIC8vICk6IFByb21pc2U8XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAgIC8vICAgICAgIGVycm9yOiBudWxsXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IG51bGxcbiAgICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgLy8gICAgIH1cbiAgICAvLyA+IHtcbiAgICAvLyAgIHRyeSB7XG4gICAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgIC8vICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgLy8gICAgICAgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCxcbiAgICAvLyAgICAgICB7IC4uLm1ldGEgfSxcbiAgICAvLyAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgLy8gICAgIClcbiAgICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB0aHJvdyBlcnJvclxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgdGhlIGZpbGVzIHdpdGhpbiBhIGJ1Y2tldC5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZm9sZGVyIHBhdGguXG4gICAgICovXG4gICAgbGlzdChwYXRoLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyksIG9wdGlvbnMpLCB7IHByZWZpeDogcGF0aCB8fCAnJyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QvJHt0aGlzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcbiAgICB9XG4gICAgdG9CYXNlNjQoZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ0b2EoZGF0YSk7XG4gICAgfVxuICAgIF9nZXRGaW5hbFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5idWNrZXRJZH0vJHtwYXRofWA7XG4gICAgfVxuICAgIF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBpZiAodHJhbnNmb3JtLndpZHRoKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgd2lkdGg9JHt0cmFuc2Zvcm0ud2lkdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucmVzaXplKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgcmVzaXplPSR7dHJhbnNmb3JtLnJlc2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLmZvcm1hdCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYGZvcm1hdD0ke3RyYW5zZm9ybS5mb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5xdWFsaXR5KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMuam9pbignJicpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3JhZ2VGaWxlQXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJpc1N0b3JhZ2VFcnJvciIsIlN0b3JhZ2VFcnJvciIsIlN0b3JhZ2VVbmtub3duRXJyb3IiLCJnZXQiLCJoZWFkIiwicG9zdCIsInJlbW92ZSIsInJlY3Vyc2l2ZVRvQ2FtZWwiLCJyZXNvbHZlRmV0Y2giLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwiY29udGVudFR5cGUiLCJ1cHNlcnQiLCJTdG9yYWdlRmlsZUFwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImJ1Y2tldElkIiwiZmV0Y2giLCJ1cGxvYWRPclVwZGF0ZSIsIm1ldGhvZCIsInBhdGgiLCJmaWxlQm9keSIsImZpbGVPcHRpb25zIiwiYm9keSIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJTdHJpbmciLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwidG9CYXNlNjQiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwicmVzIiwiZHVwbGV4IiwiZGF0YSIsImpzb24iLCJvayIsImlkIiwiSWQiLCJmdWxsUGF0aCIsIktleSIsImVycm9yIiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIm1hcCIsImRhdHVtIiwid2FudHNUcmFuc2Zvcm1hdGlvbiIsInJlbmRlclBhdGgiLCJ0cmFuc2Zvcm1hdGlvblF1ZXJ5IiwidHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmciLCJxdWVyeVN0cmluZyIsIm5vUmVzb2x2ZUpzb24iLCJibG9iIiwiaW5mbyIsImV4aXN0cyIsIm9yaWdpbmFsRXJyb3IiLCJpbmNsdWRlcyIsInN0YXR1cyIsImdldFB1YmxpY1VybCIsIl9xdWVyeVN0cmluZyIsInB1c2giLCJqb2luIiwicHVibGljVXJsIiwicHJlZml4ZXMiLCJsaXN0IiwicGFyYW1ldGVycyIsInByZWZpeCIsIkpTT04iLCJzdHJpbmdpZnkiLCJCdWZmZXIiLCJmcm9tIiwiYnRvYSIsInJlcGxhY2UiLCJwYXJhbXMiLCJ3aWR0aCIsImhlaWdodCIsInJlc2l6ZSIsImZvcm1hdCIsInF1YWxpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SupabaseClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/storage-js */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/SupabaseAuthClient */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\");\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */ class SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.global.fetch A custom fetch implementation.\n     * @param options.global.headers Any additional headers to send with each network request.\n     */ constructor(supabaseUrl, supabaseKey, options){\n        var _a, _b, _c;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl) throw new Error(\"supabaseUrl is required.\");\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        const _supabaseUrl = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.stripTrailingSlash)(supabaseUrl);\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, \"ws\");\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        // default storage key uses the supabase project ref as a namespace\n        const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DB_OPTIONS,\n            realtime: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_REALTIME_OPTIONS,\n            auth: Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_AUTH_OPTIONS), {\n                storageKey: defaultStorageKey\n            }),\n            global: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : \"\";\n        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n        if (!settings.accessToken) {\n            this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(Object.assign({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(`${_supabaseUrl}/rest/v1`, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch\n        });\n        if (!settings.accessToken) {\n            this._listenForAuthEvents();\n        }\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsClient(this.functionsUrl, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */ get storage() {\n        return new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__.StorageClient(this.storageUrl, this.headers, this.fetch);\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */ from(relation) {\n        return this.rest.from(relation);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.schema\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ rpc(fn, args = {}, options = {}) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n     *\n     * @param {string} name - The name of the Realtime channel.\n     * @param {Object} opts - The options to pass to the Realtime channel.\n     *\n     */ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n     * Returns all Realtime channels.\n     */ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n     * Unsubscribes and removes Realtime channel from Realtime client.\n     *\n     * @param {RealtimeChannel} channel - The name of the Realtime channel.\n     *\n     */ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n     * Unsubscribes and removes all Realtime channels from Realtime client.\n     */ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    _getAccessToken() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.accessToken) {\n                return yield this.accessToken();\n            }\n            const { data } = yield this.auth.getSession();\n            return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;\n        });\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, storageKey, flowType, lock, debug }, headers, fetch) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__.SupabaseAuthClient({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, authHeaders), headers),\n            storageKey: storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            flowType,\n            lock,\n            debug,\n            fetch,\n            // auth checks if there is a custom authorizaiton header using this flag\n            // so it knows whether to return an error when getUser is called with no session\n            hasCustomAuthorizationHeader: \"Authorization\" in this.headers\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n            params: Object.assign({\n                apikey: this.supabaseKey\n            }, options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        let data = this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n        return data;\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = undefined;\n        }\n    }\n} //# sourceMappingURL=SupabaseClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL1N1cGFiYXNlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUN5RDtBQUNDO0FBQ0Y7QUFDc0I7QUFDZ0Q7QUFDbEY7QUFDNkI7QUFDWDtBQUM5RDs7OztDQUlDLEdBQ2MsTUFBTW9CO0lBQ2pCOzs7Ozs7Ozs7OztLQVdDLEdBQ0RDLFlBQVlD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T0FBTztZQUNyQixJQUFJSCxVQUFVLFdBQ1YsSUFBSSxDQUFDdkQsSUFBSSxDQUFDMkQsT0FBTztZQUNyQixJQUFJLENBQUNGLGtCQUFrQixHQUFHRztRQUM5QjtJQUNKO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZXB0YS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL1N1cGFiYXNlQ2xpZW50LmpzPzNmNzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGdW5jdGlvbnNDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJztcbmltcG9ydCB7IFBvc3RncmVzdENsaWVudCwgfSBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJztcbmltcG9ydCB7IFJlYWx0aW1lQ2xpZW50LCB9IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcyc7XG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IGFzIFN1cGFiYXNlU3RvcmFnZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdG9yYWdlLWpzJztcbmltcG9ydCB7IERFRkFVTFRfR0xPQkFMX09QVElPTlMsIERFRkFVTFRfREJfT1BUSU9OUywgREVGQVVMVF9BVVRIX09QVElPTlMsIERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUywgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZmV0Y2hXaXRoQXV0aCB9IGZyb20gJy4vbGliL2ZldGNoJztcbmltcG9ydCB7IHN0cmlwVHJhaWxpbmdTbGFzaCwgYXBwbHlTZXR0aW5nRGVmYXVsdHMgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCc7XG4vKipcbiAqIFN1cGFiYXNlIENsaWVudC5cbiAqXG4gKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBhYmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuZmV0Y2ggQSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmhlYWRlcnMgQW55IGFkZGl0aW9uYWwgaGVhZGVycyB0byBzZW5kIHdpdGggZWFjaCBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnN1cGFiYXNlVXJsID0gc3VwYWJhc2VVcmw7XG4gICAgICAgIHRoaXMuc3VwYWJhc2VLZXkgPSBzdXBhYmFzZUtleTtcbiAgICAgICAgaWYgKCFzdXBhYmFzZVVybClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGlmICghc3VwYWJhc2VLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjb25zdCBfc3VwYWJhc2VVcmwgPSBzdHJpcFRyYWlsaW5nU2xhc2goc3VwYWJhc2VVcmwpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9yZWFsdGltZS92MWAucmVwbGFjZSgvXmh0dHAvaSwgJ3dzJyk7XG4gICAgICAgIHRoaXMuYXV0aFVybCA9IGAke19zdXBhYmFzZVVybH0vYXV0aC92MWA7XG4gICAgICAgIHRoaXMuc3RvcmFnZVVybCA9IGAke19zdXBhYmFzZVVybH0vc3RvcmFnZS92MWA7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25zVXJsID0gYCR7X3N1cGFiYXNlVXJsfS9mdW5jdGlvbnMvdjFgO1xuICAgICAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7bmV3IFVSTCh0aGlzLmF1dGhVcmwpLmhvc3RuYW1lLnNwbGl0KCcuJylbMF19LWF1dGgtdG9rZW5gO1xuICAgICAgICBjb25zdCBERUZBVUxUUyA9IHtcbiAgICAgICAgICAgIGRiOiBERUZBVUxUX0RCX09QVElPTlMsXG4gICAgICAgICAgICByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLFxuICAgICAgICAgICAgYXV0aDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIHsgc3RvcmFnZUtleTogZGVmYXVsdFN0b3JhZ2VLZXkgfSksXG4gICAgICAgICAgICBnbG9iYWw6IERFRkFVTFRfR0xPQkFMX09QVElPTlMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30sIERFRkFVTFRTKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gKF9hID0gc2V0dGluZ3MuYXV0aC5zdG9yYWdlS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gKF9iID0gc2V0dGluZ3MuZ2xvYmFsLmhlYWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICBpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KChfYyA9IHNldHRpbmdzLmF1dGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LCB0aGlzLmhlYWRlcnMsIHNldHRpbmdzLmdsb2JhbC5mZXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc2V0dGluZ3MuYWNjZXNzVG9rZW47XG4gICAgICAgICAgICB0aGlzLmF1dGggPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgICAgICAgICBnZXQ6IChfLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3N1cGFiYXNlLWpzOiBTdXBhYmFzZSBDbGllbnQgaXMgY29uZmlndXJlZCB3aXRoIHRoZSBhY2Nlc3NUb2tlbiBvcHRpb24sIGFjY2Vzc2luZyBzdXBhYmFzZS5hdXRoLiR7U3RyaW5nKHByb3ApfSBpcyBub3QgcG9zc2libGVgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoV2l0aEF1dGgoc3VwYWJhc2VLZXksIHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcyksIHNldHRpbmdzLmdsb2JhbC5mZXRjaCk7XG4gICAgICAgIHRoaXMucmVhbHRpbWUgPSB0aGlzLl9pbml0UmVhbHRpbWVDbGllbnQoT2JqZWN0LmFzc2lnbih7IGhlYWRlcnM6IHRoaXMuaGVhZGVycywgYWNjZXNzVG9rZW46IHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcykgfSwgc2V0dGluZ3MucmVhbHRpbWUpKTtcbiAgICAgICAgdGhpcy5yZXN0ID0gbmV3IFBvc3RncmVzdENsaWVudChgJHtfc3VwYWJhc2VVcmx9L3Jlc3QvdjFgLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBmdW5jdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBjdXN0b21GZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cGFiYXNlIFN0b3JhZ2UgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdXNlci1nZW5lcmF0ZWQgY29udGVudCwgc3VjaCBhcyBwaG90b3Mgb3IgdmlkZW9zLlxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1cGFiYXNlU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwsIHRoaXMuaGVhZGVycywgdGhpcy5mZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbik7XG4gICAgfVxuICAgIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuc2NoZW1hXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LnNjaGVtYShzY2hlbWEpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnJwY1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgcnBjKGZuLCBhcmdzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LnJwYyhmbiwgYXJncywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBSZWFsdGltZSBjaGFubmVsIHdpdGggQnJvYWRjYXN0LCBQcmVzZW5jZSwgYW5kIFBvc3RncmVzIENoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNoYW5uZWwobmFtZSwgb3B0cyA9IHsgY29uZmlnOiB7fSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmNoYW5uZWwobmFtZSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzLlxuICAgICAqL1xuICAgIGdldENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5nZXRDaGFubmVscygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgUmVhbHRpbWUgY2hhbm5lbCBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhbHRpbWVDaGFubmVsfSBjaGFubmVsIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQ2hhbm5lbChjaGFubmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBSZWFsdGltZSBjaGFubmVscyBmcm9tIFJlYWx0aW1lIGNsaWVudC5cbiAgICAgKi9cbiAgICByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUucmVtb3ZlQWxsQ2hhbm5lbHMoKTtcbiAgICB9XG4gICAgX2dldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5hY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB5aWVsZCB0aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KHsgYXV0b1JlZnJlc2hUb2tlbiwgcGVyc2lzdFNlc3Npb24sIGRldGVjdFNlc3Npb25JblVybCwgc3RvcmFnZSwgc3RvcmFnZUtleSwgZmxvd1R5cGUsIGxvY2ssIGRlYnVnLCB9LCBoZWFkZXJzLCBmZXRjaCkge1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICAgICAgICBhcGlrZXk6IGAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdXBhYmFzZUF1dGhDbGllbnQoe1xuICAgICAgICAgICAgdXJsOiB0aGlzLmF1dGhVcmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1dGhIZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIGZsb3dUeXBlLFxuICAgICAgICAgICAgbG9jayxcbiAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgZmV0Y2gsXG4gICAgICAgICAgICAvLyBhdXRoIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGN1c3RvbSBhdXRob3JpemFpdG9uIGhlYWRlciB1c2luZyB0aGlzIGZsYWdcbiAgICAgICAgICAgIC8vIHNvIGl0IGtub3dzIHdoZXRoZXIgdG8gcmV0dXJuIGFuIGVycm9yIHdoZW4gZ2V0VXNlciBpcyBjYWxsZWQgd2l0aCBubyBzZXNzaW9uXG4gICAgICAgICAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiAnQXV0aG9yaXphdGlvbicgaW4gdGhpcy5oZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhbHRpbWVDbGllbnQodGhpcy5yZWFsdGltZVVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXJhbXM6IE9iamVjdC5hc3NpZ24oeyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgfSkpO1xuICAgIH1cbiAgICBfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudCA9PT0gJ1NJR05FRF9PVVQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnNldEF1dGgoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgPT0gJ1NUT1JBR0UnKVxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5zaWduT3V0KCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1cGFiYXNlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJGdW5jdGlvbnNDbGllbnQiLCJQb3N0Z3Jlc3RDbGllbnQiLCJSZWFsdGltZUNsaWVudCIsIlN0b3JhZ2VDbGllbnQiLCJTdXBhYmFzZVN0b3JhZ2VDbGllbnQiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TIiwiREVGQVVMVF9EQl9PUFRJT05TIiwiREVGQVVMVF9BVVRIX09QVElPTlMiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiLCJmZXRjaFdpdGhBdXRoIiwic3RyaXBUcmFpbGluZ1NsYXNoIiwiYXBwbHlTZXR0aW5nRGVmYXVsdHMiLCJTdXBhYmFzZUF1dGhDbGllbnQiLCJTdXBhYmFzZUNsaWVudCIsImNvbnN0cnVjdG9yIiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJFcnJvciIsIl9zdXBhYmFzZVVybCIsInJlYWx0aW1lVXJsIiwicmVwbGFjZSIsImF1dGhVcmwiLCJzdG9yYWdlVXJsIiwiZnVuY3Rpb25zVXJsIiwiZGVmYXVsdFN0b3JhZ2VLZXkiLCJVUkwiLCJob3N0bmFtZSIsInNwbGl0IiwiREVGQVVMVFMiLCJkYiIsInJlYWx0aW1lIiwiYXV0aCIsIk9iamVjdCIsImFzc2lnbiIsInN0b3JhZ2VLZXkiLCJnbG9iYWwiLCJzZXR0aW5ncyIsImhlYWRlcnMiLCJhY2Nlc3NUb2tlbiIsIl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50IiwiZmV0Y2giLCJQcm94eSIsImdldCIsIl8iLCJwcm9wIiwiU3RyaW5nIiwiX2dldEFjY2Vzc1Rva2VuIiwiYmluZCIsIl9pbml0UmVhbHRpbWVDbGllbnQiLCJyZXN0Iiwic2NoZW1hIiwiX2xpc3RlbkZvckF1dGhFdmVudHMiLCJmdW5jdGlvbnMiLCJjdXN0b21GZXRjaCIsInN0b3JhZ2UiLCJmcm9tIiwicmVsYXRpb24iLCJycGMiLCJmbiIsImFyZ3MiLCJjaGFubmVsIiwibmFtZSIsIm9wdHMiLCJjb25maWciLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJyZW1vdmVBbGxDaGFubmVscyIsImRhdGEiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsImZsb3dUeXBlIiwibG9jayIsImRlYnVnIiwiYXV0aEhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYXBpa2V5IiwidXJsIiwiaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciIsInBhcmFtcyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJfaGFuZGxlVG9rZW5DaGFuZ2VkIiwic291cmNlIiwidG9rZW4iLCJjaGFuZ2VkQWNjZXNzVG9rZW4iLCJzZXRBdXRoIiwic2lnbk91dCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimePresence),\n/* harmony export */   SupabaseClient: () => (/* reexport safe */ _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.navigatorLock)\n/* harmony export */ });\n/* harmony import */ var _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SupabaseClient */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n\n\n\n\n\n\n/**\n * Creates a new Supabase Client.\n */ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"](supabaseUrl, supabaseKey, options);\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNaO0FBQ3VCO0FBQzhFO0FBQ2pHO0FBQ3VCO0FBQzdEOztDQUVDLEdBQ00sTUFBTVEsZUFBZSxDQUFDQyxhQUFhQyxhQUFhQztJQUNuRCxPQUFPLElBQUlYLHVEQUFjQSxDQUFDUyxhQUFhQyxhQUFhQztBQUN4RCxFQUFFLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9pbmRleC5qcz9iMzI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50JztcbmV4cG9ydCAqIGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJztcbmV4cG9ydCB7IFBvc3RncmVzdEVycm9yLCB9IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnO1xuZXhwb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlN1cGFiYXNlQ2xpZW50IiwiUG9zdGdyZXN0RXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uc0Vycm9yIiwiRnVuY3Rpb25SZWdpb24iLCJkZWZhdWx0IiwiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsIm9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupabaseAuthClient: () => (/* binding */ SupabaseAuthClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\nclass SupabaseAuthClient extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n} //# sourceMappingURL=SupabaseAuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDeEMsTUFBTUMsMkJBQTJCRCx5REFBVUE7SUFDOUNFLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO0lBQ1Y7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL1N1cGFiYXNlQXV0aENsaWVudC5qcz8xZDI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF1dGhDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcyc7XG5leHBvcnQgY2xhc3MgU3VwYWJhc2VBdXRoQ2xpZW50IGV4dGVuZHMgQXV0aENsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdXBhYmFzZUF1dGhDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIkF1dGhDbGllbnQiLCJTdXBhYmFzZUF1dGhDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUTH_OPTIONS: () => (/* binding */ DEFAULT_AUTH_OPTIONS),\n/* harmony export */   DEFAULT_DB_OPTIONS: () => (/* binding */ DEFAULT_DB_OPTIONS),\n/* harmony export */   DEFAULT_GLOBAL_OPTIONS: () => (/* binding */ DEFAULT_GLOBAL_OPTIONS),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_REALTIME_OPTIONS: () => (/* binding */ DEFAULT_REALTIME_OPTIONS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\");\n\nlet JS_ENV = \"\";\n// @ts-ignore\nif (typeof Deno !== \"undefined\") {\n    JS_ENV = \"deno\";\n} else if (typeof document !== \"undefined\") {\n    JS_ENV = \"web\";\n} else if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    JS_ENV = \"react-native\";\n} else {\n    JS_ENV = \"node\";\n}\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLElBQUlDLFNBQVM7QUFDYixhQUFhO0FBQ2IsSUFBSSxPQUFPQyxTQUFTLGFBQWE7SUFDN0JELFNBQVM7QUFDYixPQUNLLElBQUksT0FBT0UsYUFBYSxhQUFhO0lBQ3RDRixTQUFTO0FBQ2IsT0FDSyxJQUFJLE9BQU9HLGNBQWMsZUFBZUEsVUFBVUMsT0FBTyxLQUFLLGVBQWU7SUFDOUVKLFNBQVM7QUFDYixPQUNLO0lBQ0RBLFNBQVM7QUFDYjtBQUNPLE1BQU1LLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFlBQVksRUFBRUwsT0FBTyxDQUFDLEVBQUVELDZDQUFPQSxDQUFDLENBQUM7QUFBQyxFQUFFO0FBQ2hGLE1BQU1PLHlCQUF5QjtJQUNsQ0MsU0FBU0Y7QUFDYixFQUFFO0FBQ0ssTUFBTUcscUJBQXFCO0lBQzlCQyxRQUFRO0FBQ1osRUFBRTtBQUNLLE1BQU1DLHVCQUF1QjtJQUNoQ0Msa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNkLEVBQUU7QUFDSyxNQUFNQywyQkFBMkIsQ0FBQyxFQUFFLENBQzNDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcz9iZTcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xubGV0IEpTX0VOViA9ICcnO1xuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTX0VOViA9ICdkZW5vJztcbn1cbmVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU19FTlYgPSAnd2ViJztcbn1cbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgSlNfRU5WID0gJ3JlYWN0LW5hdGl2ZSc7XG59XG5lbHNlIHtcbiAgICBKU19FTlYgPSAnbm9kZSc7XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdXBhYmFzZS1qcy0ke0pTX0VOVn0vJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0ge1xuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9EQl9PUFRJT05TID0ge1xuICAgIHNjaGVtYTogJ3B1YmxpYycsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVVUSF9PUFRJT05TID0ge1xuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMgPSB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkpTX0VOViIsIkRlbm8iLCJkb2N1bWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJERUZBVUxUX0hFQURFUlMiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TIiwiaGVhZGVycyIsIkRFRkFVTFRfREJfT1BUSU9OUyIsInNjaGVtYSIsIkRFRkFVTFRfQVVUSF9PUFRJT05TIiwiYXV0b1JlZnJlc2hUb2tlbiIsInBlcnNpc3RTZXNzaW9uIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwiZmxvd1R5cGUiLCJERUZBVUxUX1JFQUxUSU1FX09QVElPTlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveHeadersConstructor: () => (/* binding */ resolveHeadersConstructor)\n/* harmony export */ });\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\");\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__);\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\n\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (_supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0___default());\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    if (typeof Headers === \"undefined\") {\n        return _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;\n    }\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init)=>__awaiter(void 0, void 0, void 0, function*() {\n            var _a;\n            const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n            let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n            if (!headers.has(\"apikey\")) {\n                headers.set(\"apikey\", supabaseKey);\n            }\n            if (!headers.has(\"Authorization\")) {\n                headers.set(\"Authorization\", `Bearer ${accessToken}`);\n            }\n            return fetch1(input, Object.assign(Object.assign({}, init), {\n                headers\n            }));\n        });\n}; //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLElBQUlBLFlBQVksU0FBSyxJQUFJLFNBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLGFBQWE7QUFDaUU7QUFDdkUsTUFBTVUsZUFBZSxDQUFDQztJQUN6QixJQUFJQztJQUNKLElBQUlELGFBQWE7UUFDYkMsU0FBU0Q7SUFDYixPQUNLLElBQUksT0FBT0UsVUFBVSxhQUFhO1FBQ25DRCxTQUFTTCw2REFBU0E7SUFDdEIsT0FDSztRQUNESyxTQUFTQztJQUNiO0lBQ0EsT0FBTyxDQUFDLEdBQUdDLE9BQVNGLFVBQVVFO0FBQ2xDLEVBQUU7QUFDSyxNQUFNQyw0QkFBNEI7SUFDckMsSUFBSSxPQUFPUCxZQUFZLGFBQWE7UUFDaEMsT0FBT0MseURBQWdCQTtJQUMzQjtJQUNBLE9BQU9EO0FBQ1gsRUFBRTtBQUNLLE1BQU1RLGdCQUFnQixDQUFDQyxhQUFhQyxnQkFBZ0JQO0lBQ3ZELE1BQU1FLFNBQVFILGFBQWFDO0lBQzNCLE1BQU1RLHFCQUFxQko7SUFDM0IsT0FBTyxDQUFDSyxPQUFPQyxPQUFTakMsVUFBVSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRztZQUN0RCxJQUFJa0M7WUFDSixNQUFNQyxjQUFjLENBQUNELEtBQU0sTUFBTUosZ0JBQWdCLE1BQU8sUUFBUUksT0FBTyxLQUFLLElBQUlBLEtBQUtMO1lBQ3JGLElBQUlPLFVBQVUsSUFBSUwsbUJBQW1CRSxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS0csT0FBTztZQUM3RixJQUFJLENBQUNBLFFBQVFDLEdBQUcsQ0FBQyxXQUFXO2dCQUN4QkQsUUFBUUUsR0FBRyxDQUFDLFVBQVVUO1lBQzFCO1lBQ0EsSUFBSSxDQUFDTyxRQUFRQyxHQUFHLENBQUMsa0JBQWtCO2dCQUMvQkQsUUFBUUUsR0FBRyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRUgsWUFBWSxDQUFDO1lBQ3hEO1lBQ0EsT0FBT1YsT0FBTU8sT0FBT08sT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHUCxPQUFPO2dCQUFFRztZQUFRO1FBQ3pFO0FBQ0osRUFBRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzPzI1NGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgbm9kZUZldGNoLCB7IEhlYWRlcnMgYXMgTm9kZUZldGNoSGVhZGVycyB9IGZyb20gJ0BzdXBhYmFzZS9ub2RlLWZldGNoJztcbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSBub2RlRmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuZXhwb3J0IGNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gTm9kZUZldGNoSGVhZGVycztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRlcnM7XG59O1xuZXhwb3J0IGNvbnN0IGZldGNoV2l0aEF1dGggPSAoc3VwYWJhc2VLZXksIGdldEFjY2Vzc1Rva2VuLCBjdXN0b21GZXRjaCkgPT4ge1xuICAgIGNvbnN0IGZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICBjb25zdCBIZWFkZXJzQ29uc3RydWN0b3IgPSByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIChpbnB1dCwgaW5pdCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSAoeWllbGQgZ2V0QWNjZXNzVG9rZW4oKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN1cGFiYXNlS2V5O1xuICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpO1xuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdBdXRob3JpemF0aW9uJykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChpbnB1dCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0KSwgeyBoZWFkZXJzIH0pKTtcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5Iiwibm9kZUZldGNoIiwiSGVhZGVycyIsIk5vZGVGZXRjaEhlYWRlcnMiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsIl9mZXRjaCIsImZldGNoIiwiYXJncyIsInJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IiLCJmZXRjaFdpdGhBdXRoIiwic3VwYWJhc2VLZXkiLCJnZXRBY2Nlc3NUb2tlbiIsIkhlYWRlcnNDb25zdHJ1Y3RvciIsImlucHV0IiwiaW5pdCIsIl9hIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwiaGFzIiwic2V0IiwiT2JqZWN0IiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applySettingDefaults: () => (/* binding */ applySettingDefaults),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   stripTrailingSlash: () => (/* binding */ stripTrailingSlash),\n/* harmony export */   uuid: () => (/* binding */ uuid)\n/* harmony export */ });\nvar __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nfunction stripTrailingSlash(url) {\n    return url.replace(/\\/$/, \"\");\n}\nconst isBrowser = ()=>\"undefined\" !== \"undefined\";\nfunction applySettingDefaults(options, defaults) {\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;\n    const result = {\n        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),\n        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),\n        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),\n        global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions),\n        accessToken: ()=>__awaiter(this, void 0, void 0, function*() {\n                return \"\";\n            })\n    };\n    if (options.accessToken) {\n        result.accessToken = options.accessToken;\n    } else {\n        // hack around Required<>\n        delete result.accessToken;\n    }\n    return result;\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxJQUFJQSxZQUFZLFNBQUssSUFBSSxTQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDTyxTQUFTTztJQUNaLE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFVQyxDQUFDO1FBQ3RFLElBQUlDLElBQUksS0FBTUUsTUFBTSxLQUFLLEtBQU0sR0FBR0MsSUFBSUosS0FBSyxNQUFNQyxJQUFJLElBQUssTUFBTztRQUNqRSxPQUFPRyxFQUFFQyxRQUFRLENBQUM7SUFDdEI7QUFDSjtBQUNPLFNBQVNDLG1CQUFtQkMsR0FBRztJQUNsQyxPQUFPQSxJQUFJUixPQUFPLENBQUMsT0FBTztBQUM5QjtBQUNPLE1BQU1TLFlBQVksSUFBTSxnQkFBa0IsWUFBWTtBQUN0RCxTQUFTQyxxQkFBcUJDLE9BQU8sRUFBRUMsUUFBUTtJQUNsRCxNQUFNLEVBQUVDLElBQUlDLFNBQVMsRUFBRUMsTUFBTUMsV0FBVyxFQUFFQyxVQUFVQyxlQUFlLEVBQUVDLFFBQVFDLGFBQWEsRUFBRyxHQUFHVDtJQUNoRyxNQUFNLEVBQUVFLElBQUlRLGtCQUFrQixFQUFFTixNQUFNTyxvQkFBb0IsRUFBRUwsVUFBVU0sd0JBQXdCLEVBQUVKLFFBQVFLLHNCQUFzQixFQUFHLEdBQUdaO0lBQ3BJLE1BQU1qQixTQUFTO1FBQ1hrQixJQUFJWSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdMLHFCQUFxQlA7UUFDekRDLE1BQU1VLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0osdUJBQXVCTjtRQUM3REMsVUFBVVEsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCwyQkFBMkJMO1FBQ3JFQyxRQUFRTSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdGLHlCQUF5Qko7UUFDakVPLGFBQWEsSUFBTS9DLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7Z0JBQWUsT0FBTztZQUFJO0lBQ2pGO0lBQ0EsSUFBSStCLFFBQVFnQixXQUFXLEVBQUU7UUFDckJoQyxPQUFPZ0MsV0FBVyxHQUFHaEIsUUFBUWdCLFdBQVc7SUFDNUMsT0FDSztRQUNELHlCQUF5QjtRQUN6QixPQUFPaEMsT0FBT2dDLFdBQVc7SUFDN0I7SUFDQSxPQUFPaEM7QUFDWCxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlcHRhLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanM/OWE2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHsgZGI6IGRiT3B0aW9ucywgYXV0aDogYXV0aE9wdGlvbnMsIHJlYWx0aW1lOiByZWFsdGltZU9wdGlvbnMsIGdsb2JhbDogZ2xvYmFsT3B0aW9ucywgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBkYjogREVGQVVMVF9EQl9PUFRJT05TLCBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUywgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUywgZ2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TLCB9ID0gZGVmYXVsdHM7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBkYjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0RCX09QVElPTlMpLCBkYk9wdGlvbnMpLFxuICAgICAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwgYXV0aE9wdGlvbnMpLFxuICAgICAgICByZWFsdGltZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMpLCByZWFsdGltZU9wdGlvbnMpLFxuICAgICAgICBnbG9iYWw6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9HTE9CQUxfT1BUSU9OUyksIGdsb2JhbE9wdGlvbnMpLFxuICAgICAgICBhY2Nlc3NUb2tlbjogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gJyc7IH0pLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGhhY2sgYXJvdW5kIFJlcXVpcmVkPD5cbiAgICAgICAgZGVsZXRlIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsInV1aWQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwidiIsInRvU3RyaW5nIiwic3RyaXBUcmFpbGluZ1NsYXNoIiwidXJsIiwiaXNCcm93c2VyIiwiYXBwbHlTZXR0aW5nRGVmYXVsdHMiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJkYiIsImRiT3B0aW9ucyIsImF1dGgiLCJhdXRoT3B0aW9ucyIsInJlYWx0aW1lIiwicmVhbHRpbWVPcHRpb25zIiwiZ2xvYmFsIiwiZ2xvYmFsT3B0aW9ucyIsIkRFRkFVTFRfREJfT1BUSU9OUyIsIkRFRkFVTFRfQVVUSF9PUFRJT05TIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsIk9iamVjdCIsImFzc2lnbiIsImFjY2Vzc1Rva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nconst version = \"2.49.1\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz80ODI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNDkuMSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-helpers-shared/dist/index.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BrowserCookieAuthStorageAdapter: () => (/* binding */ BrowserCookieAuthStorageAdapter),\n/* harmony export */   CookieAuthStorageAdapter: () => (/* binding */ CookieAuthStorageAdapter),\n/* harmony export */   DEFAULT_COOKIE_OPTIONS: () => (/* binding */ DEFAULT_COOKIE_OPTIONS),\n/* harmony export */   createSupabaseClient: () => (/* binding */ createSupabaseClient),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   parseCookies: () => (/* binding */ export_parseCookies),\n/* harmony export */   parseSupabaseCookie: () => (/* binding */ parseSupabaseCookie),\n/* harmony export */   serializeCookie: () => (/* binding */ export_serializeCookie),\n/* harmony export */   stringifySupabaseSession: () => (/* binding */ stringifySupabaseSession)\n/* harmony export */ });\n/* harmony import */ var jose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jose */ \"(ssr)/./node_modules/jose/dist/node/esm/util/base64url.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/supabase-js */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n// ../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js\nvar require_cookie = __commonJS({\n    \"../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js\" (exports) {\n        \"use strict\";\n        exports.parse = parse3;\n        exports.serialize = serialize3;\n        var __toString = Object.prototype.toString;\n        var fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n        function parse3(str, options) {\n            if (typeof str !== \"string\") {\n                throw new TypeError(\"argument str must be a string\");\n            }\n            var obj = {};\n            var opt = options || {};\n            var dec = opt.decode || decode;\n            var index = 0;\n            while(index < str.length){\n                var eqIdx = str.indexOf(\"=\", index);\n                if (eqIdx === -1) {\n                    break;\n                }\n                var endIdx = str.indexOf(\";\", index);\n                if (endIdx === -1) {\n                    endIdx = str.length;\n                } else if (endIdx < eqIdx) {\n                    index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n                    continue;\n                }\n                var key = str.slice(index, eqIdx).trim();\n                if (void 0 === obj[key]) {\n                    var val = str.slice(eqIdx + 1, endIdx).trim();\n                    if (val.charCodeAt(0) === 34) {\n                        val = val.slice(1, -1);\n                    }\n                    obj[key] = tryDecode(val, dec);\n                }\n                index = endIdx + 1;\n            }\n            return obj;\n        }\n        function serialize3(name, val, options) {\n            var opt = options || {};\n            var enc = opt.encode || encode;\n            if (typeof enc !== \"function\") {\n                throw new TypeError(\"option encode is invalid\");\n            }\n            if (!fieldContentRegExp.test(name)) {\n                throw new TypeError(\"argument name is invalid\");\n            }\n            var value = enc(val);\n            if (value && !fieldContentRegExp.test(value)) {\n                throw new TypeError(\"argument val is invalid\");\n            }\n            var str = name + \"=\" + value;\n            if (null != opt.maxAge) {\n                var maxAge = opt.maxAge - 0;\n                if (isNaN(maxAge) || !isFinite(maxAge)) {\n                    throw new TypeError(\"option maxAge is invalid\");\n                }\n                str += \"; Max-Age=\" + Math.floor(maxAge);\n            }\n            if (opt.domain) {\n                if (!fieldContentRegExp.test(opt.domain)) {\n                    throw new TypeError(\"option domain is invalid\");\n                }\n                str += \"; Domain=\" + opt.domain;\n            }\n            if (opt.path) {\n                if (!fieldContentRegExp.test(opt.path)) {\n                    throw new TypeError(\"option path is invalid\");\n                }\n                str += \"; Path=\" + opt.path;\n            }\n            if (opt.expires) {\n                var expires = opt.expires;\n                if (!isDate(expires) || isNaN(expires.valueOf())) {\n                    throw new TypeError(\"option expires is invalid\");\n                }\n                str += \"; Expires=\" + expires.toUTCString();\n            }\n            if (opt.httpOnly) {\n                str += \"; HttpOnly\";\n            }\n            if (opt.secure) {\n                str += \"; Secure\";\n            }\n            if (opt.priority) {\n                var priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n                switch(priority){\n                    case \"low\":\n                        str += \"; Priority=Low\";\n                        break;\n                    case \"medium\":\n                        str += \"; Priority=Medium\";\n                        break;\n                    case \"high\":\n                        str += \"; Priority=High\";\n                        break;\n                    default:\n                        throw new TypeError(\"option priority is invalid\");\n                }\n            }\n            if (opt.sameSite) {\n                var sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n                switch(sameSite){\n                    case true:\n                        str += \"; SameSite=Strict\";\n                        break;\n                    case \"lax\":\n                        str += \"; SameSite=Lax\";\n                        break;\n                    case \"strict\":\n                        str += \"; SameSite=Strict\";\n                        break;\n                    case \"none\":\n                        str += \"; SameSite=None\";\n                        break;\n                    default:\n                        throw new TypeError(\"option sameSite is invalid\");\n                }\n            }\n            return str;\n        }\n        function decode(str) {\n            return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n        }\n        function encode(val) {\n            return encodeURIComponent(val);\n        }\n        function isDate(val) {\n            return __toString.call(val) === \"[object Date]\" || val instanceof Date;\n        }\n        function tryDecode(str, decode2) {\n            try {\n                return decode2(str);\n            } catch (e) {\n                return str;\n            }\n        }\n    }\n});\n// src/browserCookieStorage.ts\nvar import_cookie2 = __toESM(require_cookie());\n// src/utils/cookies.ts\nvar import_cookie = __toESM(require_cookie());\n\nfunction parseSupabaseCookie(str) {\n    if (!str) {\n        return null;\n    }\n    try {\n        const session = JSON.parse(str);\n        if (!session) {\n            return null;\n        }\n        if (session.constructor.name === \"Object\") {\n            return session;\n        }\n        if (session.constructor.name !== \"Array\") {\n            throw new Error(`Unexpected format: ${session.constructor.name}`);\n        }\n        const [_header, payloadStr, _signature] = session[0].split(\".\");\n        const payload = jose__WEBPACK_IMPORTED_MODULE_0__.decode(payloadStr);\n        const decoder = new TextDecoder();\n        const { exp, sub, ...user } = JSON.parse(decoder.decode(payload));\n        return {\n            expires_at: exp,\n            expires_in: exp - Math.round(Date.now() / 1e3),\n            token_type: \"bearer\",\n            access_token: session[0],\n            refresh_token: session[1],\n            provider_token: session[2],\n            provider_refresh_token: session[3],\n            user: {\n                id: sub,\n                factors: session[4],\n                ...user\n            }\n        };\n    } catch (err) {\n        console.warn(\"Failed to parse cookie string:\", err);\n        return null;\n    }\n}\nfunction stringifySupabaseSession(session) {\n    var _a;\n    return JSON.stringify([\n        session.access_token,\n        session.refresh_token,\n        session.provider_token,\n        session.provider_refresh_token,\n        ((_a = session.user) == null ? void 0 : _a.factors) ?? null\n    ]);\n}\n// src/utils/helpers.ts\nfunction isBrowser() {\n    return  false && 0;\n}\n// src/utils/constants.ts\nvar DEFAULT_COOKIE_OPTIONS = {\n    path: \"/\",\n    sameSite: \"lax\",\n    maxAge: 60 * 60 * 24 * 365 * 1e3\n};\n// src/chunker.ts\nfunction createChunkRegExp(chunkSize) {\n    return new RegExp(\".{1,\" + chunkSize + \"}\", \"g\");\n}\nvar MAX_CHUNK_SIZE = 3180;\nvar MAX_CHUNK_REGEXP = createChunkRegExp(MAX_CHUNK_SIZE);\nfunction createChunks(key, value, chunkSize) {\n    const re = chunkSize !== void 0 ? createChunkRegExp(chunkSize) : MAX_CHUNK_REGEXP;\n    const chunkCount = Math.ceil(value.length / (chunkSize ?? MAX_CHUNK_SIZE));\n    if (chunkCount === 1) {\n        return [\n            {\n                name: key,\n                value\n            }\n        ];\n    }\n    const chunks = [];\n    const values = value.match(re);\n    values == null ? void 0 : values.forEach((value2, i)=>{\n        const name = `${key}.${i}`;\n        chunks.push({\n            name,\n            value: value2\n        });\n    });\n    return chunks;\n}\nfunction combineChunks(key, retrieveChunk = ()=>{\n    return null;\n}) {\n    let values = [];\n    for(let i = 0;; i++){\n        const chunkName = `${key}.${i}`;\n        const chunk = retrieveChunk(chunkName);\n        if (!chunk) {\n            break;\n        }\n        values.push(chunk);\n    }\n    return values.length ? values.join(\"\") : null;\n}\n// src/cookieAuthStorageAdapter.ts\nvar CookieAuthStorageAdapter = class {\n    constructor(cookieOptions){\n        this.cookieOptions = {\n            ...DEFAULT_COOKIE_OPTIONS,\n            ...cookieOptions,\n            maxAge: DEFAULT_COOKIE_OPTIONS.maxAge\n        };\n    }\n    getItem(key) {\n        const value = this.getCookie(key);\n        if (key.endsWith(\"-code-verifier\") && value) {\n            return value;\n        }\n        if (value) {\n            return JSON.stringify(parseSupabaseCookie(value));\n        }\n        const chunks = combineChunks(key, (chunkName)=>{\n            return this.getCookie(chunkName);\n        });\n        return chunks !== null ? JSON.stringify(parseSupabaseCookie(chunks)) : null;\n    }\n    setItem(key, value) {\n        if (key.endsWith(\"-code-verifier\")) {\n            this.setCookie(key, value);\n            return;\n        }\n        let session = JSON.parse(value);\n        const sessionStr = stringifySupabaseSession(session);\n        const sessionChunks = createChunks(key, sessionStr);\n        sessionChunks.forEach((sess)=>{\n            this.setCookie(sess.name, sess.value);\n        });\n    }\n    removeItem(key) {\n        this._deleteSingleCookie(key);\n        this._deleteChunkedCookies(key);\n    }\n    _deleteSingleCookie(key) {\n        if (this.getCookie(key)) {\n            this.deleteCookie(key);\n        }\n    }\n    _deleteChunkedCookies(key, from = 0) {\n        for(let i = from;; i++){\n            const cookieName = `${key}.${i}`;\n            const value = this.getCookie(cookieName);\n            if (value === void 0) {\n                break;\n            }\n            this.deleteCookie(cookieName);\n        }\n    }\n};\n// src/browserCookieStorage.ts\nvar BrowserCookieAuthStorageAdapter = class extends CookieAuthStorageAdapter {\n    constructor(cookieOptions){\n        super(cookieOptions);\n    }\n    getCookie(name) {\n        if (!isBrowser()) return null;\n        const cookies = (0, import_cookie2.parse)(document.cookie);\n        return cookies[name];\n    }\n    setCookie(name, value) {\n        if (!isBrowser()) return null;\n        document.cookie = (0, import_cookie2.serialize)(name, value, {\n            ...this.cookieOptions,\n            httpOnly: false\n        });\n    }\n    deleteCookie(name) {\n        if (!isBrowser()) return null;\n        document.cookie = (0, import_cookie2.serialize)(name, \"\", {\n            ...this.cookieOptions,\n            maxAge: 0,\n            httpOnly: false\n        });\n    }\n};\n// src/createClient.ts\n\nfunction createSupabaseClient(supabaseUrl, supabaseKey, options) {\n    var _a;\n    const browser = isBrowser();\n    return (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_1__.createClient)(supabaseUrl, supabaseKey, {\n        ...options,\n        auth: {\n            flowType: \"pkce\",\n            autoRefreshToken: browser,\n            detectSessionInUrl: browser,\n            persistSession: true,\n            storage: options.auth.storage,\n            // fix this in supabase-js\n            ...((_a = options.auth) == null ? void 0 : _a.storageKey) ? {\n                storageKey: options.auth.storageKey\n            } : {}\n        }\n    });\n}\nvar export_parseCookies = import_cookie.parse;\nvar export_serializeCookie = import_cookie.serialize;\n /*! Bundled license information:\n\ncookie/index.js:\n  (*!\n   * cookie\n   * Copyright(c) 2012-2014 Roman Shtylman\n   * Copyright(c) 2015 Douglas Christopher Wilson\n   * MIT Licensed\n   *)\n*/  //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtaGVscGVycy1zaGFyZWQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxXQUFXQyxPQUFPQyxNQUFNO0FBQzVCLElBQUlDLFlBQVlGLE9BQU9HLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CSixPQUFPSyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CTixPQUFPTyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZVIsT0FBT1MsY0FBYztBQUN4QyxJQUFJQyxlQUFlVixPQUFPVyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsYUFBYSxDQUFDQyxJQUFJQyxNQUFRLFNBQVNDO1FBQ3JDLE9BQU9ELE9BQU8sQ0FBQyxHQUFHRCxFQUFFLENBQUNSLGtCQUFrQlEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUNDLE1BQU07WUFBRUUsU0FBUyxDQUFDO1FBQUUsR0FBR0EsT0FBTyxFQUFFRixNQUFNQSxJQUFJRSxPQUFPO0lBQ3BHO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPakIsa0JBQWtCYyxNQUNoQyxJQUFJLENBQUNWLGFBQWFjLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNuQixVQUFVaUIsSUFBSUksS0FBSztZQUFFRSxLQUFLLElBQU1MLElBQUksQ0FBQ0csSUFBSTtZQUFFRyxZQUFZLENBQUVKLENBQUFBLE9BQU9sQixpQkFBaUJnQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtJLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9QO0FBQ1Q7QUFDQSxJQUFJUSxVQUFVLENBQUNaLEtBQUthLFlBQVlDLFNBQVlBLENBQUFBLFNBQVNkLE9BQU8sT0FBT2hCLFNBQVNTLGFBQWFPLFFBQVEsQ0FB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QUksRUFBRTtRQUNqQixJQUFJLENBQUM0RCxhQUNILE9BQU87UUFDVEUsU0FBU3dDLE1BQU0sR0FBRyxDQUFDLEdBQUc3RSxlQUFlaEQsU0FBUyxFQUFFdUIsTUFBTSxJQUFJO1lBQ3hELEdBQUcsSUFBSSxDQUFDc0YsYUFBYTtZQUNyQmxGLFFBQVE7WUFDUlcsVUFBVTtRQUNaO0lBQ0Y7QUFDRjtBQUVBLHNCQUFzQjtBQUMrQjtBQUNyRCxTQUFTeUYscUJBQXFCQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTNILE9BQU87SUFDN0QsSUFBSTJFO0lBQ0osTUFBTWlELFVBQVUvQztJQUNoQixPQUFPMkMsbUVBQVlBLENBQUNFLGFBQWFDLGFBQWE7UUFDNUMsR0FBRzNILE9BQU87UUFDVjZILE1BQU07WUFDSkMsVUFBVTtZQUNWQyxrQkFBa0JIO1lBQ2xCSSxvQkFBb0JKO1lBQ3BCSyxnQkFBZ0I7WUFDaEJDLFNBQVNsSSxRQUFRNkgsSUFBSSxDQUFDSyxPQUFPO1lBQzdCLDBCQUEwQjtZQUMxQixHQUFHLENBQUMsQ0FBQ3ZELEtBQUszRSxRQUFRNkgsSUFBSSxLQUFLLE9BQU8sS0FBSyxJQUFJbEQsR0FBR3dELFVBQVUsSUFBSTtnQkFDMURBLFlBQVluSSxRQUFRNkgsSUFBSSxDQUFDTSxVQUFVO1lBQ3JDLElBQUksQ0FBQyxDQUFDO1FBQ1I7SUFDRjtBQUNGO0FBQ0EsSUFBSUMsc0JBQXNCekYsY0FBY25ELEtBQUs7QUFDN0MsSUFBSTZJLHlCQUF5QjFGLGNBQWNqRCxTQUFTO0FBV2xELENBQ0Y7Ozs7Ozs7OztBQVNBLElBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtc2hhcmVkL2Rpc3QvaW5kZXgubWpzPzM2YjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Nvb2tpZUAwLjUuMC9ub2RlX21vZHVsZXMvY29va2llL2luZGV4LmpzXG52YXIgcmVxdWlyZV9jb29raWUgPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY29va2llQDAuNS4wL25vZGVfbW9kdWxlcy9jb29raWUvaW5kZXguanNcIihleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZXhwb3J0cy5wYXJzZSA9IHBhcnNlMztcbiAgICBleHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTM7XG4gICAgdmFyIF9fdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHZhciBmaWVsZENvbnRlbnRSZWdFeHAgPSAvXltcXHUwMDA5XFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHUwMGZmXSskLztcbiAgICBmdW5jdGlvbiBwYXJzZTMoc3RyLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBkZWMgPSBvcHQuZGVjb2RlIHx8IGRlY29kZTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlcUlkeCA9IHN0ci5pbmRleE9mKFwiPVwiLCBpbmRleCk7XG4gICAgICAgIGlmIChlcUlkeCA9PT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kSWR4ID0gc3RyLmluZGV4T2YoXCI7XCIsIGluZGV4KTtcbiAgICAgICAgaWYgKGVuZElkeCA9PT0gLTEpIHtcbiAgICAgICAgICBlbmRJZHggPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKGVuZElkeCA8IGVxSWR4KSB7XG4gICAgICAgICAgaW5kZXggPSBzdHIubGFzdEluZGV4T2YoXCI7XCIsIGVxSWR4IC0gMSkgKyAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBzdHIuc2xpY2UoaW5kZXgsIGVxSWR4KS50cmltKCk7XG4gICAgICAgIGlmICh2b2lkIDAgPT09IG9ialtrZXldKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0ci5zbGljZShlcUlkeCArIDEsIGVuZElkeCkudHJpbSgpO1xuICAgICAgICAgIGlmICh2YWwuY2hhckNvZGVBdCgwKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ialtrZXldID0gdHJ5RGVjb2RlKHZhbCwgZGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IGVuZElkeCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXJpYWxpemUzKG5hbWUsIHZhbCwgb3B0aW9ucykge1xuICAgICAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgZW5jID0gb3B0LmVuY29kZSB8fCBlbmNvZGU7XG4gICAgICBpZiAodHlwZW9mIGVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gZW5jb2RlIGlzIGludmFsaWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBuYW1lIGlzIGludmFsaWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBlbmModmFsKTtcbiAgICAgIGlmICh2YWx1ZSAmJiAhZmllbGRDb250ZW50UmVnRXhwLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCB2YWwgaXMgaW52YWxpZFwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHIgPSBuYW1lICsgXCI9XCIgKyB2YWx1ZTtcbiAgICAgIGlmIChudWxsICE9IG9wdC5tYXhBZ2UpIHtcbiAgICAgICAgdmFyIG1heEFnZSA9IG9wdC5tYXhBZ2UgLSAwO1xuICAgICAgICBpZiAoaXNOYU4obWF4QWdlKSB8fCAhaXNGaW5pdGUobWF4QWdlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gbWF4QWdlIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBNYXgtQWdlPVwiICsgTWF0aC5mbG9vcihtYXhBZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5kb21haW4pIHtcbiAgICAgICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQuZG9tYWluKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gZG9tYWluIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBEb21haW49XCIgKyBvcHQuZG9tYWluO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5wYXRoKSB7XG4gICAgICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LnBhdGgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBwYXRoIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBQYXRoPVwiICsgb3B0LnBhdGg7XG4gICAgICB9XG4gICAgICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICAgICAgdmFyIGV4cGlyZXMgPSBvcHQuZXhwaXJlcztcbiAgICAgICAgaWYgKCFpc0RhdGUoZXhwaXJlcykgfHwgaXNOYU4oZXhwaXJlcy52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbiBleHBpcmVzIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IFwiOyBFeHBpcmVzPVwiICsgZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5odHRwT25seSkge1xuICAgICAgICBzdHIgKz0gXCI7IEh0dHBPbmx5XCI7XG4gICAgICB9XG4gICAgICBpZiAob3B0LnNlY3VyZSkge1xuICAgICAgICBzdHIgKz0gXCI7IFNlY3VyZVwiO1xuICAgICAgfVxuICAgICAgaWYgKG9wdC5wcmlvcml0eSkge1xuICAgICAgICB2YXIgcHJpb3JpdHkgPSB0eXBlb2Ygb3B0LnByaW9yaXR5ID09PSBcInN0cmluZ1wiID8gb3B0LnByaW9yaXR5LnRvTG93ZXJDYXNlKCkgOiBvcHQucHJpb3JpdHk7XG4gICAgICAgIHN3aXRjaCAocHJpb3JpdHkpIHtcbiAgICAgICAgICBjYXNlIFwibG93XCI6XG4gICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PUxvd1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICAgICAgc3RyICs9IFwiOyBQcmlvcml0eT1NZWRpdW1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJoaWdoXCI6XG4gICAgICAgICAgICBzdHIgKz0gXCI7IFByaW9yaXR5PUhpZ2hcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9uIHByaW9yaXR5IGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHQuc2FtZVNpdGUpIHtcbiAgICAgICAgdmFyIHNhbWVTaXRlID0gdHlwZW9mIG9wdC5zYW1lU2l0ZSA9PT0gXCJzdHJpbmdcIiA/IG9wdC5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpIDogb3B0LnNhbWVTaXRlO1xuICAgICAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgc3RyICs9IFwiOyBTYW1lU2l0ZT1TdHJpY3RcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsYXhcIjpcbiAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9TGF4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICAgICAgICBzdHIgKz0gXCI7IFNhbWVTaXRlPVN0cmljdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgIHN0ciArPSBcIjsgU2FtZVNpdGU9Tm9uZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gc2FtZVNpdGUgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKFwiJVwiKSAhPT0gLTEgPyBkZWNvZGVVUklDb21wb25lbnQoc3RyKSA6IHN0cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gICAgICByZXR1cm4gX190b1N0cmluZy5jYWxsKHZhbCkgPT09IFwiW29iamVjdCBEYXRlXVwiIHx8IHZhbCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyeURlY29kZShzdHIsIGRlY29kZTIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUyKHN0cik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLy8gc3JjL2Jyb3dzZXJDb29raWVTdG9yYWdlLnRzXG52YXIgaW1wb3J0X2Nvb2tpZTIgPSBfX3RvRVNNKHJlcXVpcmVfY29va2llKCkpO1xuXG4vLyBzcmMvdXRpbHMvY29va2llcy50c1xudmFyIGltcG9ydF9jb29raWUgPSBfX3RvRVNNKHJlcXVpcmVfY29va2llKCkpO1xuaW1wb3J0IHsgYmFzZTY0dXJsIH0gZnJvbSBcImpvc2VcIjtcbmZ1bmN0aW9uIHBhcnNlU3VwYWJhc2VDb29raWUoc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9uID0gSlNPTi5wYXJzZShzdHIpO1xuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChzZXNzaW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH1cbiAgICBpZiAoc2Vzc2lvbi5jb25zdHJ1Y3Rvci5uYW1lICE9PSBcIkFycmF5XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBmb3JtYXQ6ICR7c2Vzc2lvbi5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgIH1cbiAgICBjb25zdCBbX2hlYWRlciwgcGF5bG9hZFN0ciwgX3NpZ25hdHVyZV0gPSBzZXNzaW9uWzBdLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBwYXlsb2FkID0gYmFzZTY0dXJsLmRlY29kZShwYXlsb2FkU3RyKTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgY29uc3QgeyBleHAsIHN1YiwgLi4udXNlciB9ID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShwYXlsb2FkKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGlyZXNfYXQ6IGV4cCxcbiAgICAgIGV4cGlyZXNfaW46IGV4cCAtIE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgICB0b2tlbl90eXBlOiBcImJlYXJlclwiLFxuICAgICAgYWNjZXNzX3Rva2VuOiBzZXNzaW9uWzBdLFxuICAgICAgcmVmcmVzaF90b2tlbjogc2Vzc2lvblsxXSxcbiAgICAgIHByb3ZpZGVyX3Rva2VuOiBzZXNzaW9uWzJdLFxuICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbjogc2Vzc2lvblszXSxcbiAgICAgIHVzZXI6IHtcbiAgICAgICAgaWQ6IHN1YixcbiAgICAgICAgZmFjdG9yczogc2Vzc2lvbls0XSxcbiAgICAgICAgLi4udXNlclxuICAgICAgfVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBwYXJzZSBjb29raWUgc3RyaW5nOlwiLCBlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdXBhYmFzZVNlc3Npb24oc2Vzc2lvbikge1xuICB2YXIgX2E7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShbXG4gICAgc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgc2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgIHNlc3Npb24ucHJvdmlkZXJfdG9rZW4sXG4gICAgc2Vzc2lvbi5wcm92aWRlcl9yZWZyZXNoX3Rva2VuLFxuICAgICgoX2EgPSBzZXNzaW9uLnVzZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mYWN0b3JzKSA/PyBudWxsXG4gIF0pO1xufVxuXG4vLyBzcmMvdXRpbHMvaGVscGVycy50c1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuXG4vLyBzcmMvdXRpbHMvY29uc3RhbnRzLnRzXG52YXIgREVGQVVMVF9DT09LSUVfT1BUSU9OUyA9IHtcbiAgcGF0aDogXCIvXCIsXG4gIHNhbWVTaXRlOiBcImxheFwiLFxuICBtYXhBZ2U6IDYwICogNjAgKiAyNCAqIDM2NSAqIDFlM1xufTtcblxuLy8gc3JjL2NodW5rZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rUmVnRXhwKGNodW5rU2l6ZSkge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIi57MSxcIiArIGNodW5rU2l6ZSArIFwifVwiLCBcImdcIik7XG59XG52YXIgTUFYX0NIVU5LX1NJWkUgPSAzMTgwO1xudmFyIE1BWF9DSFVOS19SRUdFWFAgPSBjcmVhdGVDaHVua1JlZ0V4cChNQVhfQ0hVTktfU0laRSk7XG5mdW5jdGlvbiBjcmVhdGVDaHVua3Moa2V5LCB2YWx1ZSwgY2h1bmtTaXplKSB7XG4gIGNvbnN0IHJlID0gY2h1bmtTaXplICE9PSB2b2lkIDAgPyBjcmVhdGVDaHVua1JlZ0V4cChjaHVua1NpemUpIDogTUFYX0NIVU5LX1JFR0VYUDtcbiAgY29uc3QgY2h1bmtDb3VudCA9IE1hdGguY2VpbCh2YWx1ZS5sZW5ndGggLyAoY2h1bmtTaXplID8/IE1BWF9DSFVOS19TSVpFKSk7XG4gIGlmIChjaHVua0NvdW50ID09PSAxKSB7XG4gICAgcmV0dXJuIFt7IG5hbWU6IGtleSwgdmFsdWUgfV07XG4gIH1cbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGNvbnN0IHZhbHVlcyA9IHZhbHVlLm1hdGNoKHJlKTtcbiAgdmFsdWVzID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZXMuZm9yRWFjaCgodmFsdWUyLCBpKSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGAke2tleX0uJHtpfWA7XG4gICAgY2h1bmtzLnB1c2goeyBuYW1lLCB2YWx1ZTogdmFsdWUyIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNodW5rcztcbn1cbmZ1bmN0aW9uIGNvbWJpbmVDaHVua3Moa2V5LCByZXRyaWV2ZUNodW5rID0gKCkgPT4ge1xuICByZXR1cm4gbnVsbDtcbn0pIHtcbiAgbGV0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgOyBpKyspIHtcbiAgICBjb25zdCBjaHVua05hbWUgPSBgJHtrZXl9LiR7aX1gO1xuICAgIGNvbnN0IGNodW5rID0gcmV0cmlldmVDaHVuayhjaHVua05hbWUpO1xuICAgIGlmICghY2h1bmspIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YWx1ZXMucHVzaChjaHVuayk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyB2YWx1ZXMuam9pbihcIlwiKSA6IG51bGw7XG59XG5cbi8vIHNyYy9jb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIudHNcbnZhciBDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNvb2tpZU9wdGlvbnMpIHtcbiAgICB0aGlzLmNvb2tpZU9wdGlvbnMgPSB7XG4gICAgICAuLi5ERUZBVUxUX0NPT0tJRV9PUFRJT05TLFxuICAgICAgLi4uY29va2llT3B0aW9ucyxcbiAgICAgIG1heEFnZTogREVGQVVMVF9DT09LSUVfT1BUSU9OUy5tYXhBZ2VcbiAgICB9O1xuICB9XG4gIGdldEl0ZW0oa2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldENvb2tpZShrZXkpO1xuICAgIGlmIChrZXkuZW5kc1dpdGgoXCItY29kZS12ZXJpZmllclwiKSAmJiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZVN1cGFiYXNlQ29va2llKHZhbHVlKSk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IGNvbWJpbmVDaHVua3Moa2V5LCAoY2h1bmtOYW1lKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb29raWUoY2h1bmtOYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2h1bmtzICE9PSBudWxsID8gSlNPTi5zdHJpbmdpZnkocGFyc2VTdXBhYmFzZUNvb2tpZShjaHVua3MpKSA6IG51bGw7XG4gIH1cbiAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS5lbmRzV2l0aChcIi1jb2RlLXZlcmlmaWVyXCIpKSB7XG4gICAgICB0aGlzLnNldENvb2tpZShrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlc3Npb24gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICBjb25zdCBzZXNzaW9uU3RyID0gc3RyaW5naWZ5U3VwYWJhc2VTZXNzaW9uKHNlc3Npb24pO1xuICAgIGNvbnN0IHNlc3Npb25DaHVua3MgPSBjcmVhdGVDaHVua3Moa2V5LCBzZXNzaW9uU3RyKTtcbiAgICBzZXNzaW9uQ2h1bmtzLmZvckVhY2goKHNlc3MpID0+IHtcbiAgICAgIHRoaXMuc2V0Q29va2llKHNlc3MubmFtZSwgc2Vzcy52YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXkpIHtcbiAgICB0aGlzLl9kZWxldGVTaW5nbGVDb29raWUoa2V5KTtcbiAgICB0aGlzLl9kZWxldGVDaHVua2VkQ29va2llcyhrZXkpO1xuICB9XG4gIF9kZWxldGVTaW5nbGVDb29raWUoa2V5KSB7XG4gICAgaWYgKHRoaXMuZ2V0Q29va2llKGtleSkpIHtcbiAgICAgIHRoaXMuZGVsZXRlQ29va2llKGtleSk7XG4gICAgfVxuICB9XG4gIF9kZWxldGVDaHVua2VkQ29va2llcyhrZXksIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IDsgaSsrKSB7XG4gICAgICBjb25zdCBjb29raWVOYW1lID0gYCR7a2V5fS4ke2l9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRDb29raWUoY29va2llTmFtZSk7XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVsZXRlQ29va2llKGNvb2tpZU5hbWUpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2Jyb3dzZXJDb29raWVTdG9yYWdlLnRzXG52YXIgQnJvd3NlckNvb2tpZUF1dGhTdG9yYWdlQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoY29va2llT3B0aW9ucykge1xuICAgIHN1cGVyKGNvb2tpZU9wdGlvbnMpO1xuICB9XG4gIGdldENvb2tpZShuYW1lKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvb2tpZXMgPSAoMCwgaW1wb3J0X2Nvb2tpZTIucGFyc2UpKGRvY3VtZW50LmNvb2tpZSk7XG4gICAgcmV0dXJuIGNvb2tpZXNbbmFtZV07XG4gIH1cbiAgc2V0Q29va2llKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9ICgwLCBpbXBvcnRfY29va2llMi5zZXJpYWxpemUpKG5hbWUsIHZhbHVlLCB7XG4gICAgICAuLi50aGlzLmNvb2tpZU9wdGlvbnMsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBkZWxldGVDb29raWUobmFtZSkge1xuICAgIGlmICghaXNCcm93c2VyKCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2N1bWVudC5jb29raWUgPSAoMCwgaW1wb3J0X2Nvb2tpZTIuc2VyaWFsaXplKShuYW1lLCBcIlwiLCB7XG4gICAgICAuLi50aGlzLmNvb2tpZU9wdGlvbnMsXG4gICAgICBtYXhBZ2U6IDAsXG4gICAgICBodHRwT25seTogZmFsc2VcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2NyZWF0ZUNsaWVudC50c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiO1xuZnVuY3Rpb24gY3JlYXRlU3VwYWJhc2VDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlS2V5LCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYnJvd3NlciA9IGlzQnJvd3NlcigpO1xuICByZXR1cm4gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0aDoge1xuICAgICAgZmxvd1R5cGU6IFwicGtjZVwiLFxuICAgICAgYXV0b1JlZnJlc2hUb2tlbjogYnJvd3NlcixcbiAgICAgIGRldGVjdFNlc3Npb25JblVybDogYnJvd3NlcixcbiAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgc3RvcmFnZTogb3B0aW9ucy5hdXRoLnN0b3JhZ2UsXG4gICAgICAvLyBmaXggdGhpcyBpbiBzdXBhYmFzZS1qc1xuICAgICAgLi4uKChfYSA9IG9wdGlvbnMuYXV0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0b3JhZ2VLZXkpID8ge1xuICAgICAgICBzdG9yYWdlS2V5OiBvcHRpb25zLmF1dGguc3RvcmFnZUtleVxuICAgICAgfSA6IHt9XG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBvcnRfcGFyc2VDb29raWVzID0gaW1wb3J0X2Nvb2tpZS5wYXJzZTtcbnZhciBleHBvcnRfc2VyaWFsaXplQ29va2llID0gaW1wb3J0X2Nvb2tpZS5zZXJpYWxpemU7XG5leHBvcnQge1xuICBCcm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyLFxuICBDb29raWVBdXRoU3RvcmFnZUFkYXB0ZXIsXG4gIERFRkFVTFRfQ09PS0lFX09QVElPTlMsXG4gIGNyZWF0ZVN1cGFiYXNlQ2xpZW50LFxuICBpc0Jyb3dzZXIsXG4gIGV4cG9ydF9wYXJzZUNvb2tpZXMgYXMgcGFyc2VDb29raWVzLFxuICBwYXJzZVN1cGFiYXNlQ29va2llLFxuICBleHBvcnRfc2VyaWFsaXplQ29va2llIGFzIHNlcmlhbGl6ZUNvb2tpZSxcbiAgc3RyaW5naWZ5U3VwYWJhc2VTZXNzaW9uXG59O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuY29va2llL2luZGV4LmpzOlxuICAoKiFcbiAgICogY29va2llXG4gICAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgUm9tYW4gU2h0eWxtYW5cbiAgICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAgICogTUlUIExpY2Vuc2VkXG4gICAqKVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGUiLCJPYmplY3QiLCJjcmVhdGUiLCJfX2RlZlByb3AiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2dldFByb3RvT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9faGFzT3duUHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX19jb21tb25KUyIsImNiIiwibW9kIiwiX19yZXF1aXJlIiwiZXhwb3J0cyIsIl9fY29weVByb3BzIiwidG8iLCJmcm9tIiwiZXhjZXB0IiwiZGVzYyIsImtleSIsImNhbGwiLCJnZXQiLCJlbnVtZXJhYmxlIiwiX190b0VTTSIsImlzTm9kZU1vZGUiLCJ0YXJnZXQiLCJfX2VzTW9kdWxlIiwidmFsdWUiLCJyZXF1aXJlX2Nvb2tpZSIsInBhcnNlIiwicGFyc2UzIiwic2VyaWFsaXplIiwic2VyaWFsaXplMyIsIl9fdG9TdHJpbmciLCJ0b1N0cmluZyIsImZpZWxkQ29udGVudFJlZ0V4cCIsInN0ciIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJvYmoiLCJvcHQiLCJkZWMiLCJkZWNvZGUiLCJpbmRleCIsImxlbmd0aCIsImVxSWR4IiwiaW5kZXhPZiIsImVuZElkeCIsImxhc3RJbmRleE9mIiwic2xpY2UiLCJ0cmltIiwidmFsIiwiY2hhckNvZGVBdCIsInRyeURlY29kZSIsIm5hbWUiLCJlbmMiLCJlbmNvZGUiLCJ0ZXN0IiwibWF4QWdlIiwiaXNOYU4iLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImRvbWFpbiIsInBhdGgiLCJleHBpcmVzIiwiaXNEYXRlIiwidmFsdWVPZiIsInRvVVRDU3RyaW5nIiwiaHR0cE9ubHkiLCJzZWN1cmUiLCJwcmlvcml0eSIsInRvTG93ZXJDYXNlIiwic2FtZVNpdGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJEYXRlIiwiZGVjb2RlMiIsImUiLCJpbXBvcnRfY29va2llMiIsImltcG9ydF9jb29raWUiLCJiYXNlNjR1cmwiLCJwYXJzZVN1cGFiYXNlQ29va2llIiwic2Vzc2lvbiIsIkpTT04iLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiX2hlYWRlciIsInBheWxvYWRTdHIiLCJfc2lnbmF0dXJlIiwic3BsaXQiLCJwYXlsb2FkIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZXhwIiwic3ViIiwidXNlciIsImV4cGlyZXNfYXQiLCJleHBpcmVzX2luIiwicm91bmQiLCJub3ciLCJ0b2tlbl90eXBlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiIsInByb3ZpZGVyX3Rva2VuIiwicHJvdmlkZXJfcmVmcmVzaF90b2tlbiIsImlkIiwiZmFjdG9ycyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwic3RyaW5naWZ5U3VwYWJhc2VTZXNzaW9uIiwiX2EiLCJzdHJpbmdpZnkiLCJpc0Jyb3dzZXIiLCJ3aW5kb3ciLCJkb2N1bWVudCIsIkRFRkFVTFRfQ09PS0lFX09QVElPTlMiLCJjcmVhdGVDaHVua1JlZ0V4cCIsImNodW5rU2l6ZSIsIlJlZ0V4cCIsIk1BWF9DSFVOS19TSVpFIiwiTUFYX0NIVU5LX1JFR0VYUCIsImNyZWF0ZUNodW5rcyIsInJlIiwiY2h1bmtDb3VudCIsImNlaWwiLCJjaHVua3MiLCJ2YWx1ZXMiLCJtYXRjaCIsImZvckVhY2giLCJ2YWx1ZTIiLCJpIiwicHVzaCIsImNvbWJpbmVDaHVua3MiLCJyZXRyaWV2ZUNodW5rIiwiY2h1bmtOYW1lIiwiY2h1bmsiLCJqb2luIiwiQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIiwiY29va2llT3B0aW9ucyIsImdldEl0ZW0iLCJnZXRDb29raWUiLCJlbmRzV2l0aCIsInNldEl0ZW0iLCJzZXRDb29raWUiLCJzZXNzaW9uU3RyIiwic2Vzc2lvbkNodW5rcyIsInNlc3MiLCJyZW1vdmVJdGVtIiwiX2RlbGV0ZVNpbmdsZUNvb2tpZSIsIl9kZWxldGVDaHVua2VkQ29va2llcyIsImRlbGV0ZUNvb2tpZSIsImNvb2tpZU5hbWUiLCJCcm93c2VyQ29va2llQXV0aFN0b3JhZ2VBZGFwdGVyIiwiY29va2llcyIsImNvb2tpZSIsImNyZWF0ZUNsaWVudCIsImNyZWF0ZVN1cGFiYXNlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsImJyb3dzZXIiLCJhdXRoIiwiZmxvd1R5cGUiLCJhdXRvUmVmcmVzaFRva2VuIiwiZGV0ZWN0U2Vzc2lvbkluVXJsIiwicGVyc2lzdFNlc3Npb24iLCJzdG9yYWdlIiwic3RvcmFnZUtleSIsImV4cG9ydF9wYXJzZUNvb2tpZXMiLCJleHBvcnRfc2VyaWFsaXplQ29va2llIiwicGFyc2VDb29raWVzIiwic2VyaWFsaXplQ29va2llIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-helpers-shared/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\");\n\nconst { PostgrestClient, PostgrestQueryBuilder, PostgrestFilterBuilder, PostgrestTransformBuilder, PostgrestBuilder, PostgrestError } = _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__;\n\n// compatibility with CJS output\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2VzbS93cmFwcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFtQztBQUNuQyxNQUFNLEVBQ0pDLGVBQWUsRUFDZkMscUJBQXFCLEVBQ3JCQyxzQkFBc0IsRUFDdEJDLHlCQUF5QixFQUN6QkMsZ0JBQWdCLEVBQ2hCQyxjQUFjLEVBQ2YsR0FBR04sMENBQUtBO0FBU1I7QUFFRCxnQ0FBZ0M7QUFDaEMsaUVBQWU7SUFDYkM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVwdGEtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9lc20vd3JhcHBlci5tanM/ZjlkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaW5kZXggZnJvbSAnLi4vY2pzL2luZGV4LmpzJ1xuY29uc3Qge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59ID0gaW5kZXhcblxuZXhwb3J0IHtcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0Q2xpZW50LFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsXG4gIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsXG4gIFBvc3RncmVzdEVycm9yLFxufVxuXG4vLyBjb21wYXRpYmlsaXR5IHdpdGggQ0pTIG91dHB1dFxuZXhwb3J0IGRlZmF1bHQge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG4iXSwibmFtZXMiOlsiaW5kZXgiLCJQb3N0Z3Jlc3RDbGllbnQiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIiwiUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciIsIlBvc3RncmVzdEJ1aWxkZXIiLCJQb3N0Z3Jlc3RFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\n");

/***/ })

};
;